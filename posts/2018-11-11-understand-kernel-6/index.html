<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="ffutop"><meta property="og:url" content="https://www.ffutop.com/posts/2018-11-11-understand-kernel-6/"><link rel=canonical href=https://www.ffutop.com/posts/2018-11-11-understand-kernel-6/><link rel=apple-touch-icon href=favicon.ico><link rel=icon href=favicon.ico><link rel=shortcut href=favicon.ico><link rel=alternate type=application/atom+xml href=https://www.ffutop.com/index.xml title="Utop's Blog"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.ffutop.com\/"},"articleSection":"posts","name":"理解 Linux Kernel (6) - read \u0026 write","headline":"理解 Linux Kernel (6) - read \u0026 write","description":"前一篇已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。\n首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;sys\/types.h\u0026gt; #include \u0026lt;sys\/stat.h\u0026gt; int panic() { fprintf(stderr, \u0026#34;%s (errno=%d)\\n\u0026#34;, strerror(errno), errno); return -1; } int main(int argc, char *argv[]) { \/* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) *\/ int fd = open(\u0026#34;\/root\/frw.txt\u0026#34;, O_RDWR | O_CREAT); if (fd == -1) return panic(); \/* 向文件写入 Hello World! 共计 12 个字符 *\/ ssize_t wsize = write(fd, \u0026#34;Hello World!\u0026#34;, 12); if (wsize == -1) return panic(); \/* 重定位文件读写指针 *\/ off_t off = lseek(fd, 0, SEEK_SET); if (off == -1) return panic(); char* buf = (char *) malloc(wsize); \/* 读取文件内容 *\/ ssize_t rsize = read(fd, buf, wsize); if (rsize == -1) return panic(); printf(\u0026#34;%s\\n\u0026#34;, buf); free(buf); \/* 关闭文件 *\/ int stat = close(fd); if (stat == -1) return panic(); return 0; } ","inLanguage":"en-US","author":"ffutop","creator":"ffutop","publisher":"ffutop","accountablePerson":"ffutop","copyrightHolder":"ffutop","copyrightYear":"2018","datePublished":"2018-11-11 00:00:00 \u002b0000 UTC","dateModified":"2018-11-11 00:00:00 \u002b0000 UTC","url":"https:\/\/www.ffutop.com\/posts\/2018-11-11-understand-kernel-6\/","keywords":["Linux","Kernel","File System","read \u0026 write"]}</script><title>理解 Linux Kernel (6) - read & write</title><meta property="og:title" content="理解 Linux Kernel (6) - read & write"><meta property="og:type" content="article"><meta property="og:description" content="前一篇已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。
首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/stat.h&amp;gt; int panic() { fprintf(stderr, &amp;#34;%s (errno=%d)\n&amp;#34;, strerror(errno), errno); return -1; } int main(int argc, char *argv[]) { /* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */ int fd = open(&amp;#34;/root/frw.txt&amp;#34;, O_RDWR | O_CREAT); if (fd == -1) return panic(); /* 向文件写入 Hello World! 共计 12 个字符 */ ssize_t wsize = write(fd, &amp;#34;Hello World!&amp;#34;, 12); if (wsize == -1) return panic(); /* 重定位文件读写指针 */ off_t off = lseek(fd, 0, SEEK_SET); if (off == -1) return panic(); char* buf = (char *) malloc(wsize); /* 读取文件内容 */ ssize_t rsize = read(fd, buf, wsize); if (rsize == -1) return panic(); printf(&amp;#34;%s\n&amp;#34;, buf); free(buf); /* 关闭文件 */ int stat = close(fd); if (stat == -1) return panic(); return 0; } "><meta name=description content="前一篇已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。
首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/stat.h&amp;gt; int panic() { fprintf(stderr, &amp;#34;%s (errno=%d)\n&amp;#34;, strerror(errno), errno); return -1; } int main(int argc, char *argv[]) { /* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */ int fd = open(&amp;#34;/root/frw.txt&amp;#34;, O_RDWR | O_CREAT); if (fd == -1) return panic(); /* 向文件写入 Hello World! 共计 12 个字符 */ ssize_t wsize = write(fd, &amp;#34;Hello World!&amp;#34;, 12); if (wsize == -1) return panic(); /* 重定位文件读写指针 */ off_t off = lseek(fd, 0, SEEK_SET); if (off == -1) return panic(); char* buf = (char *) malloc(wsize); /* 读取文件内容 */ ssize_t rsize = read(fd, buf, wsize); if (rsize == -1) return panic(); printf(&amp;#34;%s\n&amp;#34;, buf); free(buf); /* 关闭文件 */ int stat = close(fd); if (stat == -1) return panic(); return 0; } "><meta property="og:locale" content="zh-cmn-Hans-CN"><meta property="og:image" content="favicon.ico"><style>body{font-family:-apple-system,BlinkMacSystemFont,segoe ui,noto sans,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji;font-weight:400;margin:0 20px}article{max-width:800px;margin-left:auto;margin-right:auto}a{color:#333;text-decoration:none}a:hover{font-weight:600;text-decoration:underline}.post-ads{margin:50px 0}.markdown-body{color-scheme:light;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;margin:0;color:#1f2328;background-color:#fff;font-family:-apple-system,BlinkMacSystemFont,segoe ui,noto sans,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji;font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}.markdown-body h1:hover .anchor .octicon-link:before,.markdown-body h2:hover .anchor .octicon-link:before,.markdown-body h3:hover .anchor .octicon-link:before,.markdown-body h4:hover .anchor .octicon-link:before,.markdown-body h5:hover .anchor .octicon-link:before,.markdown-body h6:hover .anchor .octicon-link:before{width:16px;height:16px;content:' ';display:inline-block;background-color:currentColor;-webkit-mask-image:url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");mask-image:url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>")}.markdown-body details,.markdown-body figcaption,.markdown-body figure{display:block}.markdown-body summary{display:list-item}.markdown-body [hidden]{display:none!important}.markdown-body a{background-color:transparent;color:#0969da;text-decoration:none}.markdown-body abbr[title]{border-bottom:none;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}.markdown-body b,.markdown-body strong{font-weight:600}.markdown-body dfn{font-style:italic}.markdown-body h1{margin:.67em 0;font-weight:600;padding-bottom:.3em;font-size:2em;border-bottom:1px solid #d1d9e0b3}.markdown-body mark{background-color:#fff8c5;color:#1f2328}.markdown-body small{font-size:90%}.markdown-body sub,.markdown-body sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}.markdown-body sub{bottom:-.25em}.markdown-body sup{top:-.5em}.markdown-body img{border-style:none;max-width:100%;box-sizing:content-box}.markdown-body code,.markdown-body kbd,.markdown-body pre,.markdown-body samp{font-family:monospace;font-size:1em}.markdown-body figure{margin:1em 2.5rem}.markdown-body hr{box-sizing:content-box;overflow:hidden;background:0 0;border-bottom:1px solid #d1d9e0b3;height:.25em;padding:0;margin:1.5rem 0;background-color:#d1d9e0;border:0}.markdown-body input{font:inherit;margin:0;overflow:visible;font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body [type=button],.markdown-body [type=reset],.markdown-body [type=submit]{-webkit-appearance:button;appearance:button}.markdown-body [type=checkbox],.markdown-body [type=radio]{box-sizing:border-box;padding:0}.markdown-body [type=number]::-webkit-inner-spin-button,.markdown-body [type=number]::-webkit-outer-spin-button{height:auto}.markdown-body [type=search]::-webkit-search-cancel-button,.markdown-body [type=search]::-webkit-search-decoration{-webkit-appearance:none;appearance:none}.markdown-body ::-webkit-input-placeholder{color:inherit;opacity:.54}.markdown-body ::-webkit-file-upload-button{-webkit-appearance:button;appearance:button;font:inherit}.markdown-body a:hover{text-decoration:underline}.markdown-body ::placeholder{color:#59636e;opacity:1}.markdown-body hr::before{display:table;content:""}.markdown-body hr::after{display:table;clear:both;content:""}.markdown-body table{border-spacing:0;border-collapse:collapse;display:block;width:max-content;max-width:100%;overflow:auto;font-variant:tabular-nums}.markdown-body td,.markdown-body th{padding:0}.markdown-body details summary{cursor:pointer}.markdown-body a:focus,.markdown-body [role=button]:focus,.markdown-body input[type=radio]:focus,.markdown-body input[type=checkbox]:focus{outline:2px solid #0969da;outline-offset:-2px;box-shadow:none}.markdown-body a:focus:not(:focus-visible),.markdown-body [role=button]:focus:not(:focus-visible),.markdown-body input[type=radio]:focus:not(:focus-visible),.markdown-body input[type=checkbox]:focus:not(:focus-visible){outline:solid 1px transparent}.markdown-body a:focus-visible,.markdown-body [role=button]:focus-visible,.markdown-body input[type=radio]:focus-visible,.markdown-body input[type=checkbox]:focus-visible{outline:2px solid #0969da;outline-offset:-2px;box-shadow:none}.markdown-body a:not([class]):focus,.markdown-body a:not([class]):focus-visible,.markdown-body input[type=radio]:focus,.markdown-body input[type=radio]:focus-visible,.markdown-body input[type=checkbox]:focus,.markdown-body input[type=checkbox]:focus-visible{outline-offset:0}.markdown-body kbd{display:inline-block;padding:.25rem;font:11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;line-height:10px;color:#1f2328;vertical-align:middle;background-color:#f6f8fa;border:solid 1px #d1d9e0b3;border-bottom-color:#d1d9e0b3;border-radius:6px;box-shadow:inset 0 -1px #d1d9e0b3}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:1.5rem;margin-bottom:1rem;font-weight:600;line-height:1.25}.markdown-body h2{font-weight:600;padding-bottom:.3em;font-size:1.5em;border-bottom:1px solid #d1d9e0b3}.markdown-body h3{font-weight:600;font-size:1.25em}.markdown-body h4{font-weight:600;font-size:1em}.markdown-body h5{font-weight:600;font-size:.875em}.markdown-body h6{font-weight:600;font-size:.85em;color:#59636e}.markdown-body p{margin-top:0;margin-bottom:10px}.markdown-body blockquote{margin:0;padding:0 1em;color:#59636e;border-left:.25em solid #d1d9e0}.markdown-body ul,.markdown-body ol{margin-top:0;margin-bottom:0;padding-left:2em}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ul ul ol,.markdown-body ul ol ol,.markdown-body ol ul ol,.markdown-body ol ol ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body tt,.markdown-body code,.markdown-body samp{font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;font-size:12px}.markdown-body pre{margin-top:0;margin-bottom:0;font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;font-size:12px;word-wrap:normal}.markdown-body .octicon{display:inline-block;overflow:visible!important;vertical-align:text-bottom;fill:currentColor}.markdown-body input::-webkit-outer-spin-button,.markdown-body input::-webkit-inner-spin-button{margin:0;appearance:none}.markdown-body .mr-2{margin-right:.5rem!important}.markdown-body::before{display:table;content:""}.markdown-body::after{display:table;clear:both;content:""}.markdown-body>*:first-child{margin-top:0!important}.markdown-body>*:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .absent{color:#d1242f}.markdown-body .anchor{float:left;padding-right:.25rem;margin-left:-20px;line-height:1}.markdown-body .anchor:focus{outline:none}.markdown-body p,.markdown-body blockquote,.markdown-body ul,.markdown-body ol,.markdown-body dl,.markdown-body table,.markdown-body pre,.markdown-body details{margin-top:0;margin-bottom:1rem}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#1f2328;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h1 tt,.markdown-body h1 code,.markdown-body h2 tt,.markdown-body h2 code,.markdown-body h3 tt,.markdown-body h3 code,.markdown-body h4 tt,.markdown-body h4 code,.markdown-body h5 tt,.markdown-body h5 code,.markdown-body h6 tt,.markdown-body h6 code{padding:0 .2em;font-size:inherit}.markdown-body summary h1,.markdown-body summary h2,.markdown-body summary h3,.markdown-body summary h4,.markdown-body summary h5,.markdown-body summary h6{display:inline-block}.markdown-body summary h1 .anchor,.markdown-body summary h2 .anchor,.markdown-body summary h3 .anchor,.markdown-body summary h4 .anchor,.markdown-body summary h5 .anchor,.markdown-body summary h6 .anchor{margin-left:-40px}.markdown-body summary h1,.markdown-body summary h2{padding-bottom:0;border-bottom:0}.markdown-body ul.no-list,.markdown-body ol.no-list{padding:0;list-style-type:none}.markdown-body ol[type="a s"]{list-style-type:lower-alpha}.markdown-body ol[type="A s"]{list-style-type:upper-alpha}.markdown-body ol[type="i s"]{list-style-type:lower-roman}.markdown-body ol[type="I s"]{list-style-type:upper-roman}.markdown-body ol[type="1"]{list-style-type:decimal}.markdown-body div>ol:not([type]){list-style-type:decimal}.markdown-body ul ul,.markdown-body ul ol,.markdown-body ol ol,.markdown-body ol ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:1rem}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:1rem;font-size:1em;font-style:italic;font-weight:600}.markdown-body dl dd{padding:0 1rem;margin-bottom:1rem}.markdown-body table th{font-weight:600}.markdown-body table th,.markdown-body table td{padding:6px 13px;border:1px solid #d1d9e0}.markdown-body table td>:last-child{margin-bottom:0}.markdown-body table tr{background-color:#fff;border-top:1px solid #d1d9e0b3}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body table img{background-color:transparent}.markdown-body img[align=right]{padding-left:20px}.markdown-body img[align=left]{padding-right:20px}.markdown-body .emoji{max-width:none;vertical-align:text-top;background-color:transparent}.markdown-body span.frame{display:block;overflow:hidden}.markdown-body span.frame>span{display:block;float:left;width:auto;padding:7px;margin:13px 0 0;overflow:hidden;border:1px solid #d1d9e0}.markdown-body span.frame span img{display:block;float:left}.markdown-body span.frame span span{display:block;padding:5px 0 0;clear:both;color:#1f2328}.markdown-body span.align-center{display:block;overflow:hidden;clear:both}.markdown-body span.align-center>span{display:block;margin:13px auto 0;overflow:hidden;text-align:center}.markdown-body span.align-center span img{margin:0 auto;text-align:center}.markdown-body span.align-right{display:block;overflow:hidden;clear:both}.markdown-body span.align-right>span{display:block;margin:13px 0 0;overflow:hidden;text-align:right}.markdown-body span.align-right span img{margin:0;text-align:right}.markdown-body span.float-left{display:block;float:left;margin-right:13px;overflow:hidden}.markdown-body span.float-left span{margin:13px 0 0}.markdown-body span.float-right{display:block;float:right;margin-left:13px;overflow:hidden}.markdown-body span.float-right>span{display:block;margin:13px auto 0;overflow:hidden;text-align:right}.markdown-body code,.markdown-body tt{padding:.2em .4em;margin:0;font-size:85%;white-space:break-spaces;background-color:#818b981f;border-radius:6px}.markdown-body code br,.markdown-body tt br{display:none}.markdown-body del code{text-decoration:inherit}.markdown-body samp{font-size:85%}.markdown-body pre code{font-size:100%}.markdown-body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}.markdown-body .highlight{margin-bottom:1rem}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:1rem;overflow:auto;font-size:85%;line-height:1.45;color:#1f2328;background-color:#f6f8fa;border-radius:6px}.markdown-body pre code,.markdown-body pre tt{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body .csv-data td,.markdown-body .csv-data th{padding:5px;overflow:hidden;font-size:12px;line-height:1;text-align:left;white-space:nowrap}.markdown-body .csv-data .blob-num{padding:10px .5rem 9px;text-align:right;background:#fff;border:0}.markdown-body .csv-data tr{border-top:0}.markdown-body .csv-data th{font-weight:600;background:#f6f8fa;border-top:0}.markdown-body [data-footnote-ref]::before{content:"["}.markdown-body [data-footnote-ref]::after{content:"]"}.markdown-body .footnotes{font-size:12px;color:#59636e;border-top:1px solid #d1d9e0}.markdown-body .footnotes ol{padding-left:1rem}.markdown-body .footnotes ol ul{display:inline-block;padding-left:1rem;margin-top:1rem}.markdown-body .footnotes li{position:relative}.markdown-body .footnotes li:target::before{position:absolute;top:calc(.5rem*-1);right:calc(.5rem*-1);bottom:calc(.5rem*-1);left:calc(1.5rem*-1);pointer-events:none;content:"";border:2px solid #0969da;border-radius:6px}.markdown-body .footnotes li:target{color:#1f2328}.markdown-body .footnotes .data-footnote-backref g-emoji{font-family:monospace}.markdown-body body:has(:modal){padding-right:var(--dialog-scrollgutter)!important}.markdown-body .pl-c{color:#59636e}.markdown-body .pl-c1,.markdown-body .pl-s .pl-v{color:#0550ae}.markdown-body .pl-e,.markdown-body .pl-en{color:#6639ba}.markdown-body .pl-smi,.markdown-body .pl-s .pl-s1{color:#1f2328}.markdown-body .pl-ent{color:#0550ae}.markdown-body .pl-k{color:#cf222e}.markdown-body .pl-s,.markdown-body .pl-pds,.markdown-body .pl-s .pl-pse .pl-s1,.markdown-body .pl-sr,.markdown-body .pl-sr .pl-cce,.markdown-body .pl-sr .pl-sre,.markdown-body .pl-sr .pl-sra{color:#0a3069}.markdown-body .pl-v,.markdown-body .pl-smw{color:#953800}.markdown-body .pl-bu{color:#82071e}.markdown-body .pl-ii{color:#f6f8fa;background-color:#82071e}.markdown-body .pl-c2{color:#f6f8fa;background-color:#cf222e}.markdown-body .pl-sr .pl-cce{font-weight:700;color:#116329}.markdown-body .pl-ml{color:#3b2300}.markdown-body .pl-mh,.markdown-body .pl-mh .pl-en,.markdown-body .pl-ms{font-weight:700;color:#0550ae}.markdown-body .pl-mi{font-style:italic;color:#1f2328}.markdown-body .pl-mb{font-weight:700;color:#1f2328}.markdown-body .pl-md{color:#82071e;background-color:#ffebe9}.markdown-body .pl-mi1{color:#116329;background-color:#dafbe1}.markdown-body .pl-mc{color:#953800;background-color:#ffd8b5}.markdown-body .pl-mi2{color:#d1d9e0;background-color:#0550ae}.markdown-body .pl-mdr{font-weight:700;color:#8250df}.markdown-body .pl-ba{color:#59636e}.markdown-body .pl-sg{color:#818b98}.markdown-body .pl-corl{text-decoration:underline;color:#0a3069}.markdown-body [role=button]:focus:not(:focus-visible),.markdown-body [role=tabpanel][tabindex="0"]:focus:not(:focus-visible),.markdown-body button:focus:not(:focus-visible),.markdown-body summary:focus:not(:focus-visible),.markdown-body a:focus:not(:focus-visible){outline:none;box-shadow:none}.markdown-body [tabindex="0"]:focus:not(:focus-visible),.markdown-body details-dialog:focus:not(:focus-visible){outline:none}.markdown-body g-emoji{display:inline-block;min-width:1ch;font-family:apple color emoji,segoe ui emoji,segoe ui symbol;font-size:1em;font-style:normal!important;font-weight:400;line-height:1;vertical-align:-.075em}.markdown-body g-emoji img{width:1em;height:1em}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item label{font-weight:400}.markdown-body .task-list-item.enabled label{cursor:pointer}.markdown-body .task-list-item+.task-list-item{margin-top:.25rem}.markdown-body .task-list-item .handle{display:none}.markdown-body .task-list-item-checkbox{margin:0 .2em .25em -1.4em;vertical-align:middle}.markdown-body ul:dir(rtl) .task-list-item-checkbox{margin:0 -1.6em .25em .2em}.markdown-body ol:dir(rtl) .task-list-item-checkbox{margin:0 -1.6em .25em .2em}.markdown-body .contains-task-list:hover .task-list-item-convert-container,.markdown-body .contains-task-list:focus-within .task-list-item-convert-container{display:block;width:auto;height:24px;overflow:visible;clip:auto}.markdown-body ::-webkit-calendar-picker-indicator{filter:invert(50%)}.markdown-body .markdown-alert{padding:.5rem 1rem;margin-bottom:1rem;color:inherit;border-left:.25em solid #d1d9e0}.markdown-body .markdown-alert>:first-child{margin-top:0}.markdown-body .markdown-alert>:last-child{margin-bottom:0}.markdown-body .markdown-alert .markdown-alert-title{display:flex;font-weight:500;align-items:center;line-height:1}.markdown-body .markdown-alert.markdown-alert-note{border-left-color:#0969da}.markdown-body .markdown-alert.markdown-alert-note .markdown-alert-title{color:#0969da}.markdown-body .markdown-alert.markdown-alert-important{border-left-color:#8250df}.markdown-body .markdown-alert.markdown-alert-important .markdown-alert-title{color:#8250df}.markdown-body .markdown-alert.markdown-alert-warning{border-left-color:#9a6700}.markdown-body .markdown-alert.markdown-alert-warning .markdown-alert-title{color:#9a6700}.markdown-body .markdown-alert.markdown-alert-tip{border-left-color:#1a7f37}.markdown-body .markdown-alert.markdown-alert-tip .markdown-alert-title{color:#1a7f37}.markdown-body .markdown-alert.markdown-alert-caution{border-left-color:#cf222e}.markdown-body .markdown-alert.markdown-alert-caution .markdown-alert-title{color:#d1242f}.markdown-body>*:first-child>.heading-element:first-child{margin-top:0!important}.markdown-body .highlight pre:has(+.zeroclipboard-container){min-height:52px}.Chinese .markdown-body{line-height:150%}.site-date-catalog{font-size:1.8rem}.header-title{font-size:2rem;font-weight:700;margin-top:32px;font-family:bungee shade,sans-serif}.header-title a{text-decoration:none}.header-subtitle{color:#666}.header-items{margin:10px 0}.header-item{margin:0 5px}.header-line{width:100%;border-width:2px;border-color:#482936;border-style:solid none none none}.lang-switch{font-weight:600}#posts-list{min-height:600px}.posts-line{font-size:1rem;margin:8px 0;font-weight:500}.posts-categories{font-size:.8rem;margin:auto;text-align:center}.posts-category{padding:3px 0;border:#000 2px solid;border-radius:5px}.site-footer{margin-top:50px}.site-footer-item{margin-right:12px}.post-header{margin-bottom:50px}.post-title{font-size:2rem;font-weight:600;margin-bottom:.5em}.post-tags{display:inline;font-weight:400;padding:2px 5px;margin-right:6px;border:#000 2px solid;border-radius:5px}.post-date{font-weight:400;font-style:italic}.post-author{float:right;font-weight:400}.page-content{min-height:60%}.post-content{margin-bottom:50px;margin-left:auto;margin-right:auto;padding-left:15px;padding-right:15px}.post-content p{hyphens:auto;font-size:1rem;line-height:1.7;margin-top:0;margin-bottom:1.2em}.post-content img{max-width:100%;display:block;margin-right:auto;margin-top:6px}.post-content .post-gallery{display:flex;flex-wrap:wrap;gap:6px}.post-content .post-gallery img{margin-right:auto;margin-top:auto;width:calc(50% - 3px)}.post-content h1{font-size:1.8rem;font-weight:600;margin-top:1.5em;margin-bottom:.8em;line-height:1.3;padding-bottom:.3em;border-bottom:1px solid #eaecef}.post-content h2{font-size:1.5rem;font-weight:600;margin-top:1.8em;margin-bottom:.8em;line-height:1.3;padding-bottom:.3em;border-bottom:1px solid #eaecef}.post-content h3{font-size:1.25rem;font-weight:600;margin-top:1.6em;margin-bottom:.6em;line-height:1.4}.post-content h4{font-size:1.1rem;font-weight:500;margin-top:1.4em;margin-bottom:.5em;line-height:1.4}.post-content table{width:100%;border-collapse:collapse;margin:1.5em 0;font-size:.95em;box-shadow:0 1px 3px rgba(0,0,0,.1)}.post-content th,.post-content td{border:1px solid #ddd;padding:10px 12px;text-align:left}.post-content th{background-color:#f2f2f2;font-weight:700}.post-content tr:nth-child(even){background-color:#f9f9f9}.post-content tr:hover{background-color:#f1f1f1}.related-content{border-width:3px;border-style:solid;border-color:#000;padding:0 10px;margin-bottom:50px;margin-top:100px}.related-content li{margin:5px 0}.taxonomy-term{font-size:3rem}.gallery-img{text-align:center}.gallery-img span{text-align:center}.gallery-img-desc{font-size:.8em;font-weight:800}#disqus_thread{position:relative}#disqus_thread:after{content:"";display:block;height:55px;width:100%;position:absolute;bottom:0;background:#fff}@media screen and (max-width:600px){.header-title,.header-subtitle,.header-items{}.posts-line{font-size:16px}.markdown-body{font-size:.95rem;line-height:1.65}.post-title{font-size:1.7rem}.post-content p{letter-spacing:normal;line-height:1.65}.post-content .post-gallery img{width:100%}.post-content h1{font-size:1.7rem}.post-content h2{font-size:1.4rem}.post-content h3{font-size:1.2rem}.post-content h4{font-size:1.05rem}}@media screen and (max-width:48em){.posts-category{display:none}}</style><style>.container,.container-fluid{margin-right:auto;margin-left:auto}.container-fluid{padding-right:2rem;padding-left:2rem}.row{box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 1 auto;flex:initial;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-.5rem;margin-left:-.5rem}.row.reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}.col.reverse{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.col-xs,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-offset-0,.col-xs-offset-1,.col-xs-offset-10,.col-xs-offset-11,.col-xs-offset-12,.col-xs-offset-2,.col-xs-offset-3,.col-xs-offset-4,.col-xs-offset-5,.col-xs-offset-6,.col-xs-offset-7,.col-xs-offset-8,.col-xs-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-xs{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-xs-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-xs-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-xs-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-xs-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-xs-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-xs-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-xs-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-xs-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-xs-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-xs-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-xs-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-xs-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-xs-offset-0{margin-left:0}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-11{margin-left:91.66666667%}.start-xs{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-xs{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-xs{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-xs{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-xs{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-xs{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-xs{-ms-flex-pack:distribute;justify-content:space-around}.between-xs{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-xs{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-xs{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}@media only screen and (min-width:48em){.container{width:49rem}.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-offset-0,.col-sm-offset-1,.col-sm-offset-10,.col-sm-offset-11,.col-sm-offset-12,.col-sm-offset-2,.col-sm-offset-3,.col-sm-offset-4,.col-sm-offset-5,.col-sm-offset-6,.col-sm-offset-7,.col-sm-offset-8,.col-sm-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-sm{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-sm-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-sm-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-sm-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-sm-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-sm-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-sm-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-sm-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-sm-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-sm-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-sm-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-sm-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-sm-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-sm-offset-0{margin-left:0}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-11{margin-left:91.66666667%}.start-sm{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-sm{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-sm{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-sm{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-sm{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-sm{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-sm{-ms-flex-pack:distribute;justify-content:space-around}.between-sm{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-sm{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-sm{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:64em){.container{width:65rem}.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-offset-0,.col-md-offset-1,.col-md-offset-10,.col-md-offset-11,.col-md-offset-12,.col-md-offset-2,.col-md-offset-3,.col-md-offset-4,.col-md-offset-5,.col-md-offset-6,.col-md-offset-7,.col-md-offset-8,.col-md-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-md{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-md-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-md-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-md-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-md-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-md-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-md-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-md-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-md-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-md-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-md-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-md-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-md-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-md-offset-0{margin-left:0}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-3{margin-left:25%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-6{margin-left:50%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-9{margin-left:75%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-11{margin-left:91.66666667%}.start-md{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-md{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-md{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-md{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-md{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-md{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-md{-ms-flex-pack:distribute;justify-content:space-around}.between-md{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-md{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-md{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:75em){.container{width:76rem}.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-offset-0,.col-lg-offset-1,.col-lg-offset-10,.col-lg-offset-11,.col-lg-offset-12,.col-lg-offset-2,.col-lg-offset-3,.col-lg-offset-4,.col-lg-offset-5,.col-lg-offset-6,.col-lg-offset-7,.col-lg-offset-8,.col-lg-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-lg{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-lg-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-lg-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-lg-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-lg-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-lg-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-lg-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-lg-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-lg-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-lg-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-lg-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-lg-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-lg-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-lg-offset-0{margin-left:0}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-11{margin-left:91.66666667%}.start-lg{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-lg{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-lg{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-lg{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-lg{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-lg{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-lg{-ms-flex-pack:distribute;justify-content:space-around}.between-lg{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-lg{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-lg{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}</style><link href=/index.xml rel=alternate type=application/rss+xml title="Utop's Blog"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Bungee+Shade&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@500;600;700&family=Source+Code+Pro:wght@600&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-3RHY4L44ZL"></script> <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3RHY4L44ZL")</script></head><body><article class="post Chinese" id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class=header-title><a href=/>FFUTOP</a></div><div class=header-subtitle></div></header><div class="row end-md header-items"><div class=header-item><a href=/posts/ target=_blank>Posts</a></div><div class=header-item><a href=/index.xml target=_blank>RSS</a></div><div class=header-item><a href=https://github.com/ffutop target=_blank>Github</a></div><div class=header-item><a href=https://ffkit.ffutop.com/author target=_blank>About</a></div></div><div class=row></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>理解 Linux Kernel (6) - read & write</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2018-11-11 00:00:00 UTC">11 Nov 2018</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://www.ffutop.com/>@ffutop</a></div></div></div></header><div class="post-content markdown-body"><p><a href=https://dormouse-none.github.io/2018-10-14-understand-Kernel-5/>前一篇</a>已经描述对文件系统进行了宏观性的描述，这一篇，将以特定的文件读写操作为示例，串联对整个文件系统的基本操作。</p><p>首先先来看看平台相关的文件读写操作的 C 代码是怎样一个调用方式</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdio.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;stdlib.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;string.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;unistd.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;fcntl.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;errno.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/types.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020>#include</span> <span style=color:#007020>&lt;sys/stat.h&gt;</span><span style=color:#007020>
</span></span></span><span style=display:flex><span><span style=color:#007020></span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>panic</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#06287e>fprintf</span>(stderr, <span style=color:#4070a0>&#34;%s (errno=%d)</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, <span style=color:#06287e>strerror</span>(errno), errno);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>main</span>(<span style=color:#902000>int</span> argc, <span style=color:#902000>char</span> <span style=color:#666>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 打开文件 frw.txt (以可读写 | 若不存在则新建的形式) */</span>
</span></span><span style=display:flex><span>    <span style=color:#902000>int</span> fd <span style=color:#666>=</span> <span style=color:#06287e>open</span>(<span style=color:#4070a0>&#34;/root/frw.txt&#34;</span>, O_RDWR <span style=color:#666>|</span> O_CREAT);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (fd <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>panic</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 向文件写入 Hello World! 共计 12 个字符 */</span>
</span></span><span style=display:flex><span>    <span style=color:#902000>ssize_t</span> wsize <span style=color:#666>=</span> <span style=color:#06287e>write</span>(fd, <span style=color:#4070a0>&#34;Hello World!&#34;</span>, <span style=color:#40a070>12</span>);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (wsize <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>panic</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 重定位文件读写指针 */</span>
</span></span><span style=display:flex><span>    <span style=color:#902000>off_t</span> off <span style=color:#666>=</span> <span style=color:#06287e>lseek</span>(fd, <span style=color:#40a070>0</span>, SEEK_SET);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (off <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>panic</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#902000>char</span><span style=color:#666>*</span> buf <span style=color:#666>=</span> (<span style=color:#902000>char</span> <span style=color:#666>*</span>) <span style=color:#06287e>malloc</span>(wsize);
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 读取文件内容 */</span>
</span></span><span style=display:flex><span>    <span style=color:#902000>ssize_t</span> rsize <span style=color:#666>=</span> <span style=color:#06287e>read</span>(fd, buf, wsize);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (rsize <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>panic</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#06287e>printf</span>(<span style=color:#4070a0>&#34;%s</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>, buf);
</span></span><span style=display:flex><span>    <span style=color:#06287e>free</span>(buf);
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 关闭文件 */</span>
</span></span><span style=display:flex><span>    <span style=color:#902000>int</span> stat <span style=color:#666>=</span> <span style=color:#06287e>close</span>(fd);
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (stat <span style=color:#666>==</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>panic</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=高速缓冲区初始化>高速缓冲区初始化</h2><p>上一篇已经描述过了，文件系统的结构、包括数据，都是持久化地存储在存储设备中的。</p><p>但是，我们应该也隐约的了解另一个事实，文件读写操作并不会直接操作存储设备上的数据，而是先经过一个称之为高速缓冲的内存区域。</p><p>那么，高速缓冲是什么? 究竟承担什么工作? 先来看看它的初始化流程吧。</p><p>首先回到 <code>main.c</code> (内核代码的主函数)</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>main</span>(<span style=color:#902000>void</span>)	
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span> 	ROOT_DEV <span style=color:#666>=</span> ORIG_ROOT_DEV;
</span></span><span style=display:flex><span> 	drive_info <span style=color:#666>=</span> DRIVE_INFO;
</span></span><span style=display:flex><span>	memory_end <span style=color:#666>=</span> (<span style=color:#40a070>1</span><span style=color:#666>&lt;&lt;</span><span style=color:#40a070>20</span>) <span style=color:#666>+</span> (EXT_MEM_K<span style=color:#666>&lt;&lt;</span><span style=color:#40a070>10</span>);
</span></span><span style=display:flex><span>	memory_end <span style=color:#666>&amp;=</span> <span style=color:#40a070>0xfffff000</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (memory_end <span style=color:#666>&gt;</span> <span style=color:#40a070>16</span><span style=color:#666>*</span><span style=color:#40a070>1024</span><span style=color:#666>*</span><span style=color:#40a070>1024</span>)
</span></span><span style=display:flex><span>		memory_end <span style=color:#666>=</span> <span style=color:#40a070>16</span><span style=color:#666>*</span><span style=color:#40a070>1024</span><span style=color:#666>*</span><span style=color:#40a070>1024</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (memory_end <span style=color:#666>&gt;</span> <span style=color:#40a070>12</span><span style=color:#666>*</span><span style=color:#40a070>1024</span><span style=color:#666>*</span><span style=color:#40a070>1024</span>)
</span></span><span style=display:flex><span>		buffer_memory_end <span style=color:#666>=</span> <span style=color:#40a070>4</span><span style=color:#666>*</span><span style=color:#40a070>1024</span><span style=color:#666>*</span><span style=color:#40a070>1024</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>else</span> <span style=color:#007020;font-weight:700>if</span> (memory_end <span style=color:#666>&gt;</span> <span style=color:#40a070>6</span><span style=color:#666>*</span><span style=color:#40a070>1024</span><span style=color:#666>*</span><span style=color:#40a070>1024</span>)
</span></span><span style=display:flex><span>		buffer_memory_end <span style=color:#666>=</span> <span style=color:#40a070>2</span><span style=color:#666>*</span><span style=color:#40a070>1024</span><span style=color:#666>*</span><span style=color:#40a070>1024</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>		buffer_memory_end <span style=color:#666>=</span> <span style=color:#40a070>1</span><span style=color:#666>*</span><span style=color:#40a070>1024</span><span style=color:#666>*</span><span style=color:#40a070>1024</span>;
</span></span><span style=display:flex><span>	main_memory_start <span style=color:#666>=</span> buffer_memory_end;
</span></span><span style=display:flex><span><span style=color:#007020>#ifdef RAMDISK
</span></span></span><span style=display:flex><span><span style=color:#007020></span>	main_memory_start <span style=color:#666>+=</span> <span style=color:#06287e>rd_init</span>(main_memory_start, RAMDISK<span style=color:#666>*</span><span style=color:#40a070>1024</span>);
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>	<span style=color:#06287e>mem_init</span>(main_memory_start,memory_end);
</span></span><span style=display:flex><span>	<span style=color:#06287e>trap_init</span>();
</span></span><span style=display:flex><span>	<span style=color:#06287e>blk_dev_init</span>();
</span></span><span style=display:flex><span>	<span style=color:#06287e>chr_dev_init</span>();
</span></span><span style=display:flex><span>	<span style=color:#06287e>tty_init</span>();
</span></span><span style=display:flex><span>	<span style=color:#06287e>time_init</span>();
</span></span><span style=display:flex><span>	<span style=color:#06287e>sched_init</span>();                       <span style=color:#60a0b0;font-style:italic>// 第四篇已经讲过，负责任务调度模块的初始化
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#06287e>buffer_init</span>(buffer_memory_end);     <span style=color:#60a0b0;font-style:italic>// 本篇的起始，负责缓冲区的初始化
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>	<span style=color:#06287e>hd_init</span>();
</span></span><span style=display:flex><span>	<span style=color:#06287e>floppy_init</span>();
</span></span><span style=display:flex><span>	<span style=color:#06287e>sti</span>();
</span></span><span style=display:flex><span>	<span style=color:#06287e>move_to_user_mode</span>();
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span><span style=color:#06287e>fork</span>()) {		<span style=color:#60a0b0;font-style:italic>/* we count on this going ok */</span>
</span></span><span style=display:flex><span>		<span style=color:#06287e>init</span>();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span>(;;) <span style=color:#06287e>pause</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>buffer_init(buffer_memory_end);</code> 用来初始化缓冲区。此处有几个原因:</p><ol><li><p>CPU 读写操作如果直接操作外存，速度上是一个极大的考验。毕竟内存已经较之 CPU 速度慢，外存的读写速度就更慢了。</p></li><li><p>解耦，其实读写操作并不仅仅发生在外存(块存储设备)，同样的，字符设备等等也都会需要读写操作，增加中间层可以封装变化。</p></li><li><p>更多，个人了解有限&mldr;</p></li></ol><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>struct</span> buffer_head {
</span></span><span style=display:flex><span> <span style=color:#902000>char</span> <span style=color:#666>*</span> b_data;
</span></span><span style=display:flex><span> <span style=color:#902000>unsigned</span> <span style=color:#902000>long</span> b_blocknr;
</span></span><span style=display:flex><span> <span style=color:#902000>unsigned</span> <span style=color:#902000>short</span> b_dev;
</span></span><span style=display:flex><span> <span style=color:#902000>unsigned</span> <span style=color:#902000>char</span> b_uptodate;
</span></span><span style=display:flex><span> <span style=color:#902000>unsigned</span> <span style=color:#902000>char</span> b_dirt;
</span></span><span style=display:flex><span> <span style=color:#902000>unsigned</span> <span style=color:#902000>char</span> b_count;
</span></span><span style=display:flex><span> <span style=color:#902000>unsigned</span> <span style=color:#902000>char</span> b_lock;
</span></span><span style=display:flex><span> <span style=color:#007020;font-weight:700>struct</span> task_struct <span style=color:#666>*</span> b_wait;
</span></span><span style=display:flex><span> <span style=color:#007020;font-weight:700>struct</span> buffer_head <span style=color:#666>*</span> b_prev;
</span></span><span style=display:flex><span> <span style=color:#007020;font-weight:700>struct</span> buffer_head <span style=color:#666>*</span> b_next;
</span></span><span style=display:flex><span> <span style=color:#007020;font-weight:700>struct</span> buffer_head <span style=color:#666>*</span> b_prev_free;
</span></span><span style=display:flex><span> <span style=color:#007020;font-weight:700>struct</span> buffer_head <span style=color:#666>*</span> b_next_free;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* from fs/buffer.c */</span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>buffer_init</span>(<span style=color:#902000>long</span> buffer_end)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> buffer_head <span style=color:#666>*</span> h <span style=color:#666>=</span> start_buffer;
</span></span><span style=display:flex><span>	<span style=color:#902000>void</span> <span style=color:#666>*</span> b;
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (buffer_end <span style=color:#666>==</span> <span style=color:#40a070>1</span><span style=color:#666>&lt;&lt;</span><span style=color:#40a070>20</span>)
</span></span><span style=display:flex><span>		b <span style=color:#666>=</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>) (<span style=color:#40a070>640</span><span style=color:#666>*</span><span style=color:#40a070>1024</span>);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>		b <span style=color:#666>=</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>) buffer_end;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>while</span> ( (b <span style=color:#666>-=</span> BLOCK_SIZE) <span style=color:#666>&gt;=</span> ((<span style=color:#902000>void</span> <span style=color:#666>*</span>) (h<span style=color:#666>+</span><span style=color:#40a070>1</span>)) ) {
</span></span><span style=display:flex><span>		h<span style=color:#666>-&gt;</span>b_dev <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		h<span style=color:#666>-&gt;</span>b_dirt <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		h<span style=color:#666>-&gt;</span>b_count <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		h<span style=color:#666>-&gt;</span>b_lock <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		h<span style=color:#666>-&gt;</span>b_uptodate <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		h<span style=color:#666>-&gt;</span>b_wait <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>		h<span style=color:#666>-&gt;</span>b_next <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>		h<span style=color:#666>-&gt;</span>b_prev <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>		h<span style=color:#666>-&gt;</span>b_data <span style=color:#666>=</span> (<span style=color:#902000>char</span> <span style=color:#666>*</span>) b;
</span></span><span style=display:flex><span>		h<span style=color:#666>-&gt;</span>b_prev_free <span style=color:#666>=</span> h<span style=color:#666>-</span><span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>		h<span style=color:#666>-&gt;</span>b_next_free <span style=color:#666>=</span> h<span style=color:#666>+</span><span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>		h<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>		NR_BUFFERS<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 跳过 640K ~ 1M 的显存和 BIOS RAM 部分 */</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (b <span style=color:#666>==</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>) <span style=color:#40a070>0x100000</span>)
</span></span><span style=display:flex><span>			b <span style=color:#666>=</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>) <span style=color:#40a070>0xA0000</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	h<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>	free_list <span style=color:#666>=</span> start_buffer;
</span></span><span style=display:flex><span>	free_list<span style=color:#666>-&gt;</span>b_prev_free <span style=color:#666>=</span> h;
</span></span><span style=display:flex><span>	h<span style=color:#666>-&gt;</span>b_next_free <span style=color:#666>=</span> free_list;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span> (i<span style=color:#666>=</span><span style=color:#40a070>0</span>;i<span style=color:#666>&lt;</span>NR_HASH;i<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>		hash_table[i]<span style=color:#666>=</span><span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>缓冲块的所有关键信息都由 <code>buffer_head</code> 数据结构进行记录, 至于有多少个 <code>buffer_head</code>? 只能说能划分多少就划分多少。</p><p>比较直观的结构信息如下</p><p><img src=https://ws2.sinaimg.cn/large/006tNbRwly1fwy2iag1exj31kw0k1dgb.jpg alt></p><p>在 <code>main.c</code> 中已经提前确认了内核程序占用内存的大小，缓冲区大小以及主内存大小。</p><p>在高速缓冲区的开始位置，都用来存储 <code>buffer_head</code> 的信息，与每个缓冲块(从缓冲区结束位置开始分配)一一对应，直到中间某个位置不足以分配缓冲块为止。</p><p>另外的信息，就是可以看到一个 <code>hash_table</code> 数据结构了。</p><p>应该都能够想象，每个缓存块与外存中的数据块相对应，通过设备号 + 数据块号进行唯一定位。但是，如何快速查找需要操作的数据块是否已经存在与高速缓存中了呢? 显然直接遍历查找是不太可靠的办法。采用开放地址法的哈希表能够协助快速定位缓冲块。</p><h2 id=挂载文件系统>挂载文件系统</h2><p>既然高速缓冲区都准备就绪了，那么文件系统是否已经挂载了呢? 很遗憾，知道 <code>main()</code> 调用 <code>init()</code> 函数之前，文件系统依然没有挂载，也就是说，CPU 仍然只能通过基本输入输出对存储设备进行相当初级的 IO 操作。</p><p>那么，什么时候才能去挂载根目录呢?</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* from init/main.c */</span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* 由 main() 触发 */</span>
</span></span><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>init</span>(<span style=color:#902000>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> pid,i;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 这是比较重要的一环了，开始挂载的起始动作 */</span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>setup</span>((<span style=color:#902000>void</span> <span style=color:#666>*</span>) <span style=color:#666>&amp;</span>drive_info);
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>setup</code> 函数做了什么呢？这是一个内嵌汇编，主要做的就是触发系统调用 <code>int 0x80</code></p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#06287e>__inline__</span> <span style=color:#60add5>int</span> <span style=color:#60add5>setup</span>(<span style=color:#60add5>void</span> * <span style=color:#60add5>BIOS</span>) <span>{</span> 
</span></span><span style=display:flex><span>    <span style=color:#60add5>long</span> <span style=color:#60add5>__res</span><span style=color:#60a0b0;font-style:italic>; 
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>    <span style=color:#06287e>__asm__</span> <span style=color:#60add5>volatile</span> (
</span></span><span style=display:flex><span>            <span>&#34;</span><span style=color:#06287e>int</span> <span style=color:#60add5>$0x80</span><span>&#34;</span> 
</span></span><span style=display:flex><span>            : <span>&#34;=</span><span style=color:#60add5>a</span><span>&#34;</span> (<span style=color:#60add5>__res</span>) 
</span></span><span style=display:flex><span>            : <span>&#34;</span><span style=color:#40a070>0</span><span>&#34;</span> (<span style=color:#40a070>0</span>),<span>&#34;</span><span style=color:#60add5>b</span><span>&#34;</span> ((<span style=color:#60add5>long</span>)(<span style=color:#60add5>BIOS</span>))
</span></span><span style=display:flex><span>    <span>)</span><span style=color:#60a0b0;font-style:italic>; 
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>    <span style=color:#06287e>if</span> (<span style=color:#60add5>__res</span> <span>&gt;=</span> <span style=color:#40a070>0</span>) 
</span></span><span style=display:flex><span>        <span style=color:#60add5>return</span> (<span style=color:#60add5>int</span>) <span style=color:#60add5>__res</span><span style=color:#60a0b0;font-style:italic>; 
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>    <span style=color:#06287e>errno</span> <span>=</span> -<span style=color:#60add5>__res</span><span style=color:#60a0b0;font-style:italic>; 
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>    <span style=color:#06287e>return</span> -<span style=color:#40a070>1</span><span style=color:#60a0b0;font-style:italic>; 
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span><span>}</span>
</span></span></code></pre></div><p>其中看到给出的 <code>EAX = 0</code>, 查表(表在 <code>include/linux/sys.h</code> 里) 可以知道触发的是 <code>sys_setup</code> 函数(函数位于 <code>kernel/blk_drv/hd.c</code>)</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* This may be used only once, enforced by &#39;static int callable&#39; */</span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>sys_setup</span>(<span style=color:#902000>void</span> <span style=color:#666>*</span> BIOS)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>int</span> callable <span style=color:#666>=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> i,drive;
</span></span><span style=display:flex><span>	<span style=color:#902000>unsigned</span> <span style=color:#902000>char</span> cmos_disks;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> partition <span style=color:#666>*</span>p;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> buffer_head <span style=color:#666>*</span> bh;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* setup 只允许被调用一次 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>callable)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>	callable <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 可以强制在源码中指定硬盘参数, 所以加了宏定义作判断*/</span>
</span></span><span style=display:flex><span><span style=color:#007020>#ifndef HD_TYPE
</span></span></span><span style=display:flex><span><span style=color:#007020></span>	<span style=color:#007020;font-weight:700>for</span> (drive<span style=color:#666>=</span><span style=color:#40a070>0</span> ; drive<span style=color:#666>&lt;</span><span style=color:#40a070>2</span> ; drive<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>		hd_info[drive].cyl <span style=color:#666>=</span> <span style=color:#666>*</span>(<span style=color:#902000>unsigned</span> <span style=color:#902000>short</span> <span style=color:#666>*</span>) BIOS;
</span></span><span style=display:flex><span>		hd_info[drive].head <span style=color:#666>=</span> <span style=color:#666>*</span>(<span style=color:#902000>unsigned</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>) (<span style=color:#40a070>2</span><span style=color:#666>+</span>BIOS);
</span></span><span style=display:flex><span>		hd_info[drive].wpcom <span style=color:#666>=</span> <span style=color:#666>*</span>(<span style=color:#902000>unsigned</span> <span style=color:#902000>short</span> <span style=color:#666>*</span>) (<span style=color:#40a070>5</span><span style=color:#666>+</span>BIOS);
</span></span><span style=display:flex><span>		hd_info[drive].ctl <span style=color:#666>=</span> <span style=color:#666>*</span>(<span style=color:#902000>unsigned</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>) (<span style=color:#40a070>8</span><span style=color:#666>+</span>BIOS);
</span></span><span style=display:flex><span>		hd_info[drive].lzone <span style=color:#666>=</span> <span style=color:#666>*</span>(<span style=color:#902000>unsigned</span> <span style=color:#902000>short</span> <span style=color:#666>*</span>) (<span style=color:#40a070>12</span><span style=color:#666>+</span>BIOS);
</span></span><span style=display:flex><span>		hd_info[drive].sect <span style=color:#666>=</span> <span style=color:#666>*</span>(<span style=color:#902000>unsigned</span> <span style=color:#902000>char</span> <span style=color:#666>*</span>) (<span style=color:#40a070>14</span><span style=color:#666>+</span>BIOS);
</span></span><span style=display:flex><span>		BIOS <span style=color:#666>+=</span> <span style=color:#40a070>16</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (hd_info[<span style=color:#40a070>1</span>].cyl)
</span></span><span style=display:flex><span>		NR_HD<span style=color:#666>=</span><span style=color:#40a070>2</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>		NR_HD<span style=color:#666>=</span><span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span><span style=color:#007020>#endif
</span></span></span><span style=display:flex><span><span style=color:#007020></span>	<span style=color:#007020;font-weight:700>for</span> (i<span style=color:#666>=</span><span style=color:#40a070>0</span> ; i<span style=color:#666>&lt;</span>NR_HD ; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>		hd[i<span style=color:#666>*</span><span style=color:#40a070>5</span>].start_sect <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		hd[i<span style=color:#666>*</span><span style=color:#40a070>5</span>].nr_sects <span style=color:#666>=</span> hd_info[i].head<span style=color:#666>*</span>
</span></span><span style=display:flex><span>				hd_info[i].sect<span style=color:#666>*</span>hd_info[i].cyl;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		We querry CMOS about hard disks : it could be that
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		we have a SCSI/ESDI/etc controller that is BIOS
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		compatable with ST-506, and thus showing up in our
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		BIOS table, but not register compatable, and therefore
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		not present in CMOS.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		Furthurmore, we will assume that our ST-506 drives
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		&lt;if any&gt; are the primary drives in the system, and
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		the ones reflected as drive 1 or 2.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		The first drive is stored in the high nibble of CMOS
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		byte 0x12, the second in the low nibble.  This will be
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		either a 4 bit drive type or 0xf indicating use byte 0x19
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		for an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		Needless to say, a non-zero value means we have
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>		an AT controller hard disk for that drive.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> ((cmos_disks <span style=color:#666>=</span> <span style=color:#06287e>CMOS_READ</span>(<span style=color:#40a070>0x12</span>)) <span style=color:#666>&amp;</span> <span style=color:#40a070>0xf0</span>)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (cmos_disks <span style=color:#666>&amp;</span> <span style=color:#40a070>0x0f</span>)
</span></span><span style=display:flex><span>			NR_HD <span style=color:#666>=</span> <span style=color:#40a070>2</span>;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>			NR_HD <span style=color:#666>=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>		NR_HD <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span> (i <span style=color:#666>=</span> NR_HD ; i <span style=color:#666>&lt;</span> <span style=color:#40a070>2</span> ; i<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>		hd[i<span style=color:#666>*</span><span style=color:#40a070>5</span>].start_sect <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		hd[i<span style=color:#666>*</span><span style=color:#40a070>5</span>].nr_sects <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 更进一步设置每个盘的参数 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span> (drive<span style=color:#666>=</span><span style=color:#40a070>0</span> ; drive<span style=color:#666>&lt;</span>NR_HD ; drive<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 0x300 和 0x305 分别代表两个硬盘 */</span>
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 读取每个硬盘的第一块数据 (1024B) */</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(bh <span style=color:#666>=</span> <span style=color:#06287e>bread</span>(<span style=color:#40a070>0x300</span> <span style=color:#666>+</span> drive<span style=color:#666>*</span><span style=color:#40a070>5</span>,<span style=color:#40a070>0</span>))) {
</span></span><span style=display:flex><span>			<span style=color:#06287e>printk</span>(<span style=color:#4070a0>&#34;Unable to read partition table of drive %d</span><span style=color:#4070a0;font-weight:700>\n\r</span><span style=color:#4070a0>&#34;</span>,
</span></span><span style=display:flex><span>				drive);
</span></span><span style=display:flex><span>			<span style=color:#06287e>panic</span>(<span style=color:#4070a0>&#34;&#34;</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 判断硬盘有效性 */</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (bh<span style=color:#666>-&gt;</span>b_data[<span style=color:#40a070>510</span>] <span style=color:#666>!=</span> <span style=color:#40a070>0x55</span> <span style=color:#666>||</span> (<span style=color:#902000>unsigned</span> <span style=color:#902000>char</span>)
</span></span><span style=display:flex><span>		    bh<span style=color:#666>-&gt;</span>b_data[<span style=color:#40a070>511</span>] <span style=color:#666>!=</span> <span style=color:#40a070>0xAA</span>) {
</span></span><span style=display:flex><span>			<span style=color:#06287e>printk</span>(<span style=color:#4070a0>&#34;Bad partition table on drive %d</span><span style=color:#4070a0;font-weight:700>\n\r</span><span style=color:#4070a0>&#34;</span>,drive);
</span></span><span style=display:flex><span>			<span style=color:#06287e>panic</span>(<span style=color:#4070a0>&#34;&#34;</span>);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 读取分区表 (位于 引导扇区第 446 字节开始处 */</span>
</span></span><span style=display:flex><span>		p <span style=color:#666>=</span> <span style=color:#40a070>0x1BE</span> <span style=color:#666>+</span> (<span style=color:#902000>void</span> <span style=color:#666>*</span>)bh<span style=color:#666>-&gt;</span>b_data;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>for</span> (i<span style=color:#666>=</span><span style=color:#40a070>1</span>;i<span style=color:#666>&lt;</span><span style=color:#40a070>5</span>;i<span style=color:#666>++</span>,p<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>			hd[i<span style=color:#666>+</span><span style=color:#40a070>5</span><span style=color:#666>*</span>drive].start_sect <span style=color:#666>=</span> p<span style=color:#666>-&gt;</span>start_sect;
</span></span><span style=display:flex><span>			hd[i<span style=color:#666>+</span><span style=color:#40a070>5</span><span style=color:#666>*</span>drive].nr_sects <span style=color:#666>=</span> p<span style=color:#666>-&gt;</span>nr_sects;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#06287e>brelse</span>(bh);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (NR_HD)
</span></span><span style=display:flex><span>		<span style=color:#06287e>printk</span>(<span style=color:#4070a0>&#34;Partition table%s ok.</span><span style=color:#4070a0;font-weight:700>\n\r</span><span style=color:#4070a0>&#34;</span>,(NR_HD<span style=color:#666>&gt;</span><span style=color:#40a070>1</span>)<span style=color:#666>?</span><span style=color:#4070a0>&#34;s&#34;</span><span style=color:#666>:</span><span style=color:#4070a0>&#34;&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#06287e>rd_load</span>();              <span style=color:#60a0b0;font-style:italic>/* 尝试创建并加载虚拟盘 */</span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>mount_root</span>();           <span style=color:#60a0b0;font-style:italic>/* mount 根文件系统 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> (<span style=color:#40a070>0</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>终于到了挂载文件系统的时候了</p><p><code>mount_root</code> 用来做初级的初始化工作。同时，上一节已经描述过了，存储设备的超级块是用了记录整个文件系统最重要的结构。</p><p>那么通过将超级块的信息读取到内存，也就可以将内存与外存的文件系统相互联系起来了。</p><p>下面这段代码最重要的内容就是 <code>read_super()</code> 函数了 .</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>void</span> <span style=color:#06287e>mount_root</span>(<span style=color:#902000>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> i,free;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> super_block <span style=color:#666>*</span> p;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> m_inode <span style=color:#666>*</span> mi;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#40a070>32</span> <span style=color:#666>!=</span> <span style=color:#007020;font-weight:700>sizeof</span> (<span style=color:#007020;font-weight:700>struct</span> d_inode))
</span></span><span style=display:flex><span>		<span style=color:#06287e>panic</span>(<span style=color:#4070a0>&#34;bad i-node size&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 先初始化文件表，该版本操作系统限制最大同时打开 NR_FILE(64个) 文件 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span>(i<span style=color:#666>=</span><span style=color:#40a070>0</span>;i<span style=color:#666>&lt;</span>NR_FILE;i<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* f_count = 0 表明没有被引用 */</span>
</span></span><span style=display:flex><span>		file_table[i].f_count<span style=color:#666>=</span><span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 如果引导盘是软盘的话，提示插入根文件系统盘 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>MAJOR</span>(ROOT_DEV) <span style=color:#666>==</span> <span style=color:#40a070>2</span>) {
</span></span><span style=display:flex><span>		<span style=color:#06287e>printk</span>(<span style=color:#4070a0>&#34;Insert root floppy and press ENTER&#34;</span>);
</span></span><span style=display:flex><span>		<span style=color:#06287e>wait_for_keypress</span>();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 初始化内存超级块数据结构 (总共 8 个) */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span>(p <span style=color:#666>=</span> <span style=color:#666>&amp;</span>super_block[<span style=color:#40a070>0</span>] ; p <span style=color:#666>&lt;</span> <span style=color:#666>&amp;</span>super_block[NR_SUPER] ; p<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>		p<span style=color:#666>-&gt;</span>s_dev <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		p<span style=color:#666>-&gt;</span>s_lock <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		p<span style=color:#666>-&gt;</span>s_wait <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* Hint: 读取超级块的信息，挂载根文件系统重要的部分(代码请往下翻) */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(p<span style=color:#666>=</span><span style=color:#06287e>read_super</span>(ROOT_DEV)))
</span></span><span style=display:flex><span>		<span style=color:#06287e>panic</span>(<span style=color:#4070a0>&#34;Unable to mount root&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 读取文件系统的 1 号i节点 (即该设备上文件系统的根节点) */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(mi<span style=color:#666>=</span><span style=color:#06287e>iget</span>(ROOT_DEV,ROOT_INO)))
</span></span><span style=display:flex><span>		<span style=color:#06287e>panic</span>(<span style=color:#4070a0>&#34;Unable to read root i-node&#34;</span>);
</span></span><span style=display:flex><span>	mi<span style=color:#666>-&gt;</span>i_count <span style=color:#666>+=</span> <span style=color:#40a070>3</span> ;	<span style=color:#60a0b0;font-style:italic>/* NOTE! it is logically used 4 times, not 1 */</span>
</span></span><span style=display:flex><span>	p<span style=color:#666>-&gt;</span>s_isup <span style=color:#666>=</span> p<span style=color:#666>-&gt;</span>s_imount <span style=color:#666>=</span> mi;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 应该还记得吧，current 指的是当前的任务(任务1)，以后所有的任务都会由任务1或任务1的子任务进行派生，也就意味着 current-&gt;root 会一直复制过去
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 到这里为止，应该认为根文件系统以及被挂载了。是不是跟被耍了一样?
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     */</span>
</span></span><span style=display:flex><span>	current<span style=color:#666>-&gt;</span>pwd <span style=color:#666>=</span> mi;
</span></span><span style=display:flex><span>	current<span style=color:#666>-&gt;</span>root <span style=color:#666>=</span> mi;
</span></span><span style=display:flex><span>	free<span style=color:#666>=</span><span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	i<span style=color:#666>=</span>p<span style=color:#666>-&gt;</span>s_nzones;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 统计还有多少空闲数据块以及多少可用i节点 (附上一张启动过程中打印的信息) */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>while</span> (<span style=color:#666>--</span> i <span style=color:#666>&gt;=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span><span style=color:#06287e>set_bit</span>(i<span style=color:#666>&amp;</span><span style=color:#40a070>8191</span>,p<span style=color:#666>-&gt;</span>s_zmap[i<span style=color:#666>&gt;&gt;</span><span style=color:#40a070>13</span>]<span style=color:#666>-&gt;</span>b_data))
</span></span><span style=display:flex><span>			free<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>	<span style=color:#06287e>printk</span>(<span style=color:#4070a0>&#34;%d/%d free blocks</span><span style=color:#4070a0;font-weight:700>\n\r</span><span style=color:#4070a0>&#34;</span>,free,p<span style=color:#666>-&gt;</span>s_nzones);
</span></span><span style=display:flex><span>	free<span style=color:#666>=</span><span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	i<span style=color:#666>=</span>p<span style=color:#666>-&gt;</span>s_ninodes<span style=color:#666>+</span><span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>while</span> (<span style=color:#666>--</span> i <span style=color:#666>&gt;=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span><span style=color:#06287e>set_bit</span>(i<span style=color:#666>&amp;</span><span style=color:#40a070>8191</span>,p<span style=color:#666>-&gt;</span>s_imap[i<span style=color:#666>&gt;&gt;</span><span style=color:#40a070>13</span>]<span style=color:#666>-&gt;</span>b_data))
</span></span><span style=display:flex><span>			free<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>	<span style=color:#06287e>printk</span>(<span style=color:#4070a0>&#34;%d/%d free inodes</span><span style=color:#4070a0;font-weight:700>\n\r</span><span style=color:#4070a0>&#34;</span>,free,p<span style=color:#666>-&gt;</span>s_ninodes);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=https://ws4.sinaimg.cn/large/006tNbRwly1fwz8kvvgbpj30l006i3yb.jpg alt></p><p>重要要的部分，<code>read_super(int dev)</code>，用于读取超级块的数据</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>struct</span> super_block <span style=color:#666>*</span> <span style=color:#06287e>read_super</span>(<span style=color:#902000>int</span> dev)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> super_block <span style=color:#666>*</span> s;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> buffer_head <span style=color:#666>*</span> bh;
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> i,block;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>dev)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	<span style=color:#06287e>check_disk_change</span>(dev);
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 如果该超级块已经在内存中了，那么就直接使用 (和这里挂载根文件系统的流程无关) */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (s <span style=color:#666>=</span> <span style=color:#06287e>get_super</span>(dev))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> s;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 设备超级块不在内存中，就先找一个空闲的内存超级块 (总共维护 8 个超级块数据结构) */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span> (s <span style=color:#666>=</span> <span style=color:#40a070>0</span><span style=color:#666>+</span>super_block ;; s<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (s <span style=color:#666>&gt;=</span> NR_SUPER<span style=color:#666>+</span>super_block)
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>s<span style=color:#666>-&gt;</span>s_dev)
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	s<span style=color:#666>-&gt;</span>s_dev <span style=color:#666>=</span> dev;
</span></span><span style=display:flex><span>	s<span style=color:#666>-&gt;</span>s_isup <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	s<span style=color:#666>-&gt;</span>s_imount <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	s<span style=color:#666>-&gt;</span>s_time <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	s<span style=color:#666>-&gt;</span>s_rd_only <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	s<span style=color:#666>-&gt;</span>s_dirt <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#06287e>lock_super</span>(s);
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 通过 block read 读取设备第一个物理块 (每个物理块 1024 B) */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(bh <span style=color:#666>=</span> <span style=color:#06287e>bread</span>(dev,<span style=color:#40a070>1</span>))) {
</span></span><span style=display:flex><span>		s<span style=color:#666>-&gt;</span>s_dev<span style=color:#666>=</span><span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		<span style=color:#06287e>free_super</span>(s);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 复制一份超级块的数据 */</span>
</span></span><span style=display:flex><span>	<span style=color:#666>*</span>((<span style=color:#007020;font-weight:700>struct</span> d_super_block <span style=color:#666>*</span>) s) <span style=color:#666>=</span>
</span></span><span style=display:flex><span>		<span style=color:#666>*</span>((<span style=color:#007020;font-weight:700>struct</span> d_super_block <span style=color:#666>*</span>) bh<span style=color:#666>-&gt;</span>b_data);
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 释放缓冲区的数据 */</span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>brelse</span>(bh);
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 验证魔数, 该版本操作系统只支持 1.0 版 Minix 文件系统，魔数 0x137F */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (s<span style=color:#666>-&gt;</span>s_magic <span style=color:#666>!=</span> SUPER_MAGIC) {
</span></span><span style=display:flex><span>		s<span style=color:#666>-&gt;</span>s_dev <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		<span style=color:#06287e>free_super</span>(s);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 先清空内存中的数据 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span> (i<span style=color:#666>=</span><span style=color:#40a070>0</span>;i<span style=color:#666>&lt;</span>I_MAP_SLOTS;i<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>		s<span style=color:#666>-&gt;</span>s_imap[i] <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span> (i<span style=color:#666>=</span><span style=color:#40a070>0</span>;i<span style=color:#666>&lt;</span>Z_MAP_SLOTS;i<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>		s<span style=color:#666>-&gt;</span>s_zmap[i] <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	block<span style=color:#666>=</span><span style=color:#40a070>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 读取 i 节点位图块 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span> (i<span style=color:#666>=</span><span style=color:#40a070>0</span> ; i <span style=color:#666>&lt;</span> s<span style=color:#666>-&gt;</span>s_imap_blocks ; i<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (s<span style=color:#666>-&gt;</span>s_imap[i]<span style=color:#666>=</span><span style=color:#06287e>bread</span>(dev,block))
</span></span><span style=display:flex><span>			block<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 读取数据块位图 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span> (i<span style=color:#666>=</span><span style=color:#40a070>0</span> ; i <span style=color:#666>&lt;</span> s<span style=color:#666>-&gt;</span>s_zmap_blocks ; i<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (s<span style=color:#666>-&gt;</span>s_zmap[i]<span style=color:#666>=</span><span style=color:#06287e>bread</span>(dev,block))
</span></span><span style=display:flex><span>			block<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (block <span style=color:#666>!=</span> <span style=color:#40a070>2</span><span style=color:#666>+</span>s<span style=color:#666>-&gt;</span>s_imap_blocks<span style=color:#666>+</span>s<span style=color:#666>-&gt;</span>s_zmap_blocks) {
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>for</span>(i<span style=color:#666>=</span><span style=color:#40a070>0</span>;i<span style=color:#666>&lt;</span>I_MAP_SLOTS;i<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>			<span style=color:#06287e>brelse</span>(s<span style=color:#666>-&gt;</span>s_imap[i]);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>for</span>(i<span style=color:#666>=</span><span style=color:#40a070>0</span>;i<span style=color:#666>&lt;</span>Z_MAP_SLOTS;i<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>			<span style=color:#06287e>brelse</span>(s<span style=color:#666>-&gt;</span>s_zmap[i]);
</span></span><span style=display:flex><span>		s<span style=color:#666>-&gt;</span>s_dev<span style=color:#666>=</span><span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		<span style=color:#06287e>free_super</span>(s);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	s<span style=color:#666>-&gt;</span>s_imap[<span style=color:#40a070>0</span>]<span style=color:#666>-&gt;</span>b_data[<span style=color:#40a070>0</span>] <span style=color:#666>|=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>	s<span style=color:#666>-&gt;</span>s_zmap[<span style=color:#40a070>0</span>]<span style=color:#666>-&gt;</span>b_data[<span style=color:#40a070>0</span>] <span style=color:#666>|=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 与前面的 wait_on_super() 对应(解开lock标志) */</span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>free_super</span>(s);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> s;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>是不是觉得也没什么，就这样根文件系统已经挂载了? 毫无实感是吧。</p><h2 id=extra-普通挂载>Extra: 普通挂载</h2><p>既然讲过了根文件系统的挂载。那就顺带着讲讲普通文件系统的挂载吧。</p><p>相信从命令上来讲应该比较简单也比较熟悉吧。<code>mount disk.img /mnt</code> 也算是挂载到 /mnt 下了</p><p>但是，究竟是怎么实现的呢?</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>sys_mount</span>(<span style=color:#902000>char</span> <span style=color:#666>*</span> dev_name, <span style=color:#902000>char</span> <span style=color:#666>*</span> dir_name, <span style=color:#902000>int</span> rw_flag)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> m_inode <span style=color:#666>*</span> dev_i, <span style=color:#666>*</span> dir_i;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> super_block <span style=color:#666>*</span> sb;
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> dev;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/** 
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 省略大部分判断逻辑, 主要就是:
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 1. 判断 dev_name 所属的设备号，读取该设备上的超级块
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 2. 读取 dir_name (需要挂载到的位置)，判定是否允许被挂载(比如根节点不允许挂其它设备)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 设置超级块的 mount 标志 */</span>
</span></span><span style=display:flex><span>	sb<span style=color:#666>-&gt;</span>s_imount<span style=color:#666>=</span>dir_i;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 设置该 i 节点的 mount 标志 */</span>
</span></span><span style=display:flex><span>	dir_i<span style=color:#666>-&gt;</span>i_mount<span style=color:#666>=</span><span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>	dir_i<span style=color:#666>-&gt;</span>i_dirt<span style=color:#666>=</span><span style=color:#40a070>1</span>;		<span style=color:#60a0b0;font-style:italic>/* NOTE! we don&#39;t iput(dir_i) */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;			<span style=color:#60a0b0;font-style:italic>/* we do that in umount */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=文件读写>文件读写</h2><p>前面讲了这么多，终于到了最关心的部分了。当然，也并不是说前面的内容不重要，事实上，相当重要，只是都隐藏在了内核引导的过程中，且调用频度低，才导致了没有存在感。但是这恰恰才是支持文件读写的基石。</p><p>不多说废话，下面就要开始文件读写的内容。</p><h3 id=打开文件>打开文件</h3><p>打开文件的函数原型是 <code>int open(const char * filename, int flag, ...);</code></p><p>当然，此类系统调用最终的实现都是 <code>int 0x80</code> , 明确一个调用号，然后就陷入内核态了。</p><p>内核态下调用的函数是: <code>int sys_open(const char * filename,int flag,int mode)</code></p><p>来看看细节:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>sys_open</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span> filename,<span style=color:#902000>int</span> flag,<span style=color:#902000>int</span> mode)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> m_inode <span style=color:#666>*</span> inode;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> file <span style=color:#666>*</span> f;
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> i,fd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * current 是由内核数据段维护的当前任务的指针
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * umask 是指当前任务在新建文件时的默认掩码
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     *   例如 Linux 默认是 022, 即新建文件被禁止了组用户与其它用户的写权限
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 这里是先确定新建文件的权限
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     */</span>
</span></span><span style=display:flex><span>	mode <span style=color:#666>&amp;=</span> <span style=color:#40a070>0777</span> <span style=color:#666>&amp;</span> <span style=color:#666>~</span>current<span style=color:#666>-&gt;</span>umask;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 文件描述符，每个文件单独维护一套，以数字标记
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 找一个空闲的文件描述符项
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span>(fd<span style=color:#666>=</span><span style=color:#40a070>0</span> ; fd<span style=color:#666>&lt;</span>NR_OPEN ; fd<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>current<span style=color:#666>-&gt;</span>filp[fd])
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (fd<span style=color:#666>&gt;=</span>NR_OPEN)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 顾名思义，设置在调用 exec() 函数时主动关闭的文件
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * exec() 通常与 fork() 联用，fork() 负责复制一个任务，而 exec 负责替换新任务的代码和数据段(从而产生一个新的任务)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 这里的声明即是复位 fd 位置的标志，允许子任务也持有相同的文件描述符项
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     */</span>
</span></span><span style=display:flex><span>	current<span style=color:#666>-&gt;</span>close_on_exec <span style=color:#666>&amp;=</span> <span style=color:#666>~</span>(<span style=color:#40a070>1</span><span style=color:#666>&lt;&lt;</span>fd);
</span></span><span style=display:flex><span>	f<span style=color:#666>=</span><span style=color:#40a070>0</span><span style=color:#666>+</span>file_table;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 在文件表中找一项空闲的 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span> (i<span style=color:#666>=</span><span style=color:#40a070>0</span> ; i<span style=color:#666>&lt;</span>NR_FILE ; i<span style=color:#666>++</span>,f<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>f<span style=color:#666>-&gt;</span>f_count) <span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (i<span style=color:#666>&gt;=</span>NR_FILE)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 当前任务的文件描述符项指向文件表项, 同时文件表项的引用计数+1*/</span>
</span></span><span style=display:flex><span>	(current<span style=color:#666>-&gt;</span>filp[fd]<span style=color:#666>=</span>f)<span style=color:#666>-&gt;</span>f_count<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 调用 open_namei 打开文件，如果失败则释放刚才占用的文件结构，并返回错误码 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> ((i<span style=color:#666>=</span><span style=color:#06287e>open_namei</span>(filename,flag,mode,<span style=color:#666>&amp;</span>inode))<span style=color:#666>&lt;</span><span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>		current<span style=color:#666>-&gt;</span>filp[fd]<span style=color:#666>=</span><span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>		f<span style=color:#666>-&gt;</span>f_count<span style=color:#666>=</span><span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> i;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 对不同的文件进行不同的特殊处理, 毕竟有 &#34;一切皆文件&#34; 的口号嘛
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 诸如字符设备等也都是文件
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     */</span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* ttys are somewhat special (ttyxx major==4, tty major==5) */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>S_ISCHR</span>(inode<span style=color:#666>-&gt;</span>i_mode))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>MAJOR</span>(inode<span style=color:#666>-&gt;</span>i_zone[<span style=color:#40a070>0</span>])<span style=color:#666>==</span><span style=color:#40a070>4</span>) {
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>if</span> (current<span style=color:#666>-&gt;</span>leader <span style=color:#666>&amp;&amp;</span> current<span style=color:#666>-&gt;</span>tty<span style=color:#666>&lt;</span><span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>				current<span style=color:#666>-&gt;</span>tty <span style=color:#666>=</span> <span style=color:#06287e>MINOR</span>(inode<span style=color:#666>-&gt;</span>i_zone[<span style=color:#40a070>0</span>]);
</span></span><span style=display:flex><span>				tty_table[current<span style=color:#666>-&gt;</span>tty].pgrp <span style=color:#666>=</span> current<span style=color:#666>-&gt;</span>pgrp;
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		} <span style=color:#007020;font-weight:700>else</span> <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>MAJOR</span>(inode<span style=color:#666>-&gt;</span>i_zone[<span style=color:#40a070>0</span>])<span style=color:#666>==</span><span style=color:#40a070>5</span>)
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>if</span> (current<span style=color:#666>-&gt;</span>tty<span style=color:#666>&lt;</span><span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>				<span style=color:#06287e>iput</span>(inode);
</span></span><span style=display:flex><span>				current<span style=color:#666>-&gt;</span>filp[fd]<span style=color:#666>=</span><span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>				f<span style=color:#666>-&gt;</span>f_count<span style=color:#666>=</span><span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>				<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EPERM;
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* Likewise with block-devices: check for floppy_change */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>S_ISBLK</span>(inode<span style=color:#666>-&gt;</span>i_mode))
</span></span><span style=display:flex><span>		<span style=color:#06287e>check_disk_change</span>(inode<span style=color:#666>-&gt;</span>i_zone[<span style=color:#40a070>0</span>]);
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 初始化内存文件结构的各个参数 */</span>
</span></span><span style=display:flex><span>	f<span style=color:#666>-&gt;</span>f_mode <span style=color:#666>=</span> inode<span style=color:#666>-&gt;</span>i_mode;
</span></span><span style=display:flex><span>	f<span style=color:#666>-&gt;</span>f_flags <span style=color:#666>=</span> flag;
</span></span><span style=display:flex><span>	f<span style=color:#666>-&gt;</span>f_count <span style=color:#666>=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>	f<span style=color:#666>-&gt;</span>f_inode <span style=color:#666>=</span> inode;
</span></span><span style=display:flex><span>	f<span style=color:#666>-&gt;</span>f_pos <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> (fd);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在整个打开文件的过程中，除了真正去文件系统查找文件的时候用到了文件名，其它时候，都将是以文件描述符进行交互的。</p><p>再看看更细节的方面，毕竟就目前来说，我们跳过了最重要的一环 <code>open_namei</code> ，从而看似整个流程都简单了很多很多。</p><p>通常我们在编码过程中都是通过绝对地址/相对地址来唯一定位一个文件。因此，就必然存在逐级寻找文件的过程</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>struct</span> m_inode <span style=color:#666>*</span> <span style=color:#06287e>get_dir</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span> pathname)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>char</span> c;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span> thisname;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> m_inode <span style=color:#666>*</span> inode;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> buffer_head <span style=color:#666>*</span> bh;
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> namelen,inr,idev;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> dir_entry <span style=color:#666>*</span> de;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 判定当前任务设定的根节点是否有效 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>current<span style=color:#666>-&gt;</span>root <span style=color:#666>||</span> <span style=color:#666>!</span>current<span style=color:#666>-&gt;</span>root<span style=color:#666>-&gt;</span>i_count)
</span></span><span style=display:flex><span>		<span style=color:#06287e>panic</span>(<span style=color:#4070a0>&#34;No root inode&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 判定当前路径i节点是否有效 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>current<span style=color:#666>-&gt;</span>pwd <span style=color:#666>||</span> <span style=color:#666>!</span>current<span style=color:#666>-&gt;</span>pwd<span style=color:#666>-&gt;</span>i_count)
</span></span><span style=display:flex><span>		<span style=color:#06287e>panic</span>(<span style=color:#4070a0>&#34;No cwd inode&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 这里的 get_fs_byte(..) 是宏定义，fs 指的是 FS 段寄存器
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * Linux 内核将 DS, ES 用于内核数据段, 用 FS 指向局部描述符表的当前任务数据段
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 这里可以简单理解成取字符数组的第一个字节
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> ((c<span style=color:#666>=</span><span style=color:#06287e>get_fs_byte</span>(pathname))<span style=color:#666>==</span><span style=color:#4070a0>&#39;/&#39;</span>) {
</span></span><span style=display:flex><span>		inode <span style=color:#666>=</span> current<span style=color:#666>-&gt;</span>root;
</span></span><span style=display:flex><span>		pathname<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>	} <span style=color:#007020;font-weight:700>else</span> <span style=color:#007020;font-weight:700>if</span> (c)
</span></span><span style=display:flex><span>		inode <span style=color:#666>=</span> current<span style=color:#666>-&gt;</span>pwd;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;	<span style=color:#60a0b0;font-style:italic>/* empty name is bad */</span>
</span></span><span style=display:flex><span>	inode<span style=color:#666>-&gt;</span>i_count<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>while</span> (<span style=color:#40a070>1</span>) {
</span></span><span style=display:flex><span>		thisname <span style=color:#666>=</span> pathname;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span><span style=color:#06287e>S_ISDIR</span>(inode<span style=color:#666>-&gt;</span>i_mode) <span style=color:#666>||</span> <span style=color:#666>!</span><span style=color:#06287e>permission</span>(inode,MAY_EXEC)) {
</span></span><span style=display:flex><span>			<span style=color:#06287e>iput</span>(inode);
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>for</span>(namelen<span style=color:#666>=</span><span style=color:#40a070>0</span>;(c<span style=color:#666>=</span><span style=color:#06287e>get_fs_byte</span>(pathname<span style=color:#666>++</span>))<span style=color:#666>&amp;&amp;</span>(c<span style=color:#666>!=</span><span style=color:#4070a0>&#39;/&#39;</span>);namelen<span style=color:#666>++</span>)
</span></span><span style=display:flex><span>			<span style=color:#60a0b0;font-style:italic>/* nothing */</span> ;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>c)
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> inode;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(bh <span style=color:#666>=</span> <span style=color:#06287e>find_entry</span>(<span style=color:#666>&amp;</span>inode,thisname,namelen,<span style=color:#666>&amp;</span>de))) {
</span></span><span style=display:flex><span>			<span style=color:#06287e>iput</span>(inode);
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		inr <span style=color:#666>=</span> de<span style=color:#666>-&gt;</span>inode;
</span></span><span style=display:flex><span>		idev <span style=color:#666>=</span> inode<span style=color:#666>-&gt;</span>i_dev;
</span></span><span style=display:flex><span>		<span style=color:#06287e>brelse</span>(bh);
</span></span><span style=display:flex><span>		<span style=color:#06287e>iput</span>(inode);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(inode <span style=color:#666>=</span> <span style=color:#06287e>iget</span>(idev,inr)))
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	dir_namei()
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 处理路径 pathname, 处理成i节点表示的最终一级目录+目录下文件名(也可能pathname表示的就是目录)
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>struct</span> m_inode <span style=color:#666>*</span> <span style=color:#06287e>dir_namei</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span> pathname, <span style=color:#902000>int</span> <span style=color:#666>*</span> namelen, <span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>**</span> name)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>char</span> c;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span> basename;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> m_inode <span style=color:#666>*</span> dir;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(dir <span style=color:#666>=</span> <span style=color:#06287e>get_dir</span>(pathname)))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	basename <span style=color:#666>=</span> pathname;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>while</span> (c<span style=color:#666>=</span><span style=color:#06287e>get_fs_byte</span>(pathname<span style=color:#666>++</span>))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (c<span style=color:#666>==</span><span style=color:#4070a0>&#39;/&#39;</span>)
</span></span><span style=display:flex><span>			basename<span style=color:#666>=</span>pathname;
</span></span><span style=display:flex><span>	<span style=color:#666>*</span>namelen <span style=color:#666>=</span> pathname<span style=color:#666>-</span>basename<span style=color:#666>-</span><span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#666>*</span>name <span style=color:#666>=</span> basename;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> dir;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *	open_namei()
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> *
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * namei for open - this is in fact almost the whole open-routine.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>open_namei</span>(<span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span> pathname, <span style=color:#902000>int</span> flag, <span style=color:#902000>int</span> mode,
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> m_inode <span style=color:#666>**</span> res_inode)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>const</span> <span style=color:#902000>char</span> <span style=color:#666>*</span> basename;
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> inr,dev,namelen;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> m_inode <span style=color:#666>*</span> dir, <span style=color:#666>*</span>inode;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> buffer_head <span style=color:#666>*</span> bh;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> dir_entry <span style=color:#666>*</span> de;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> ((flag <span style=color:#666>&amp;</span> O_TRUNC) <span style=color:#666>&amp;&amp;</span> <span style=color:#666>!</span>(flag <span style=color:#666>&amp;</span> O_ACCMODE))
</span></span><span style=display:flex><span>		flag <span style=color:#666>|=</span> O_WRONLY;
</span></span><span style=display:flex><span>	mode <span style=color:#666>&amp;=</span> <span style=color:#40a070>0777</span> <span style=color:#666>&amp;</span> <span style=color:#666>~</span>current<span style=color:#666>-&gt;</span>umask;
</span></span><span style=display:flex><span>	mode <span style=color:#666>|=</span> I_REGULAR;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(dir <span style=color:#666>=</span> <span style=color:#06287e>dir_namei</span>(pathname,<span style=color:#666>&amp;</span>namelen,<span style=color:#666>&amp;</span>basename)))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>ENOENT;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 如果给的 pathname 是一个目录 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>namelen) {			<span style=color:#60a0b0;font-style:italic>/* special case: &#39;/usr/&#39; etc */</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(flag <span style=color:#666>&amp;</span> (O_ACCMODE<span style=color:#666>|</span>O_CREAT<span style=color:#666>|</span>O_TRUNC))) {
</span></span><span style=display:flex><span>			<span style=color:#666>*</span>res_inode<span style=color:#666>=</span>dir;
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#06287e>iput</span>(dir);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EISDIR;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 找到目录对应的i节点的数据块 */</span>
</span></span><span style=display:flex><span>	bh <span style=color:#666>=</span> <span style=color:#06287e>find_entry</span>(<span style=color:#666>&amp;</span>dir,basename,namelen,<span style=color:#666>&amp;</span>de);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>bh) {
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(flag <span style=color:#666>&amp;</span> O_CREAT)) {
</span></span><span style=display:flex><span>			<span style=color:#06287e>iput</span>(dir);
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>ENOENT;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span><span style=color:#06287e>permission</span>(dir,MAY_WRITE)) {
</span></span><span style=display:flex><span>			<span style=color:#06287e>iput</span>(dir);
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EACCES;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		inode <span style=color:#666>=</span> <span style=color:#06287e>new_inode</span>(dir<span style=color:#666>-&gt;</span>i_dev);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>inode) {
</span></span><span style=display:flex><span>			<span style=color:#06287e>iput</span>(dir);
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>ENOSPC;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		inode<span style=color:#666>-&gt;</span>i_uid <span style=color:#666>=</span> current<span style=color:#666>-&gt;</span>euid;
</span></span><span style=display:flex><span>		inode<span style=color:#666>-&gt;</span>i_mode <span style=color:#666>=</span> mode;
</span></span><span style=display:flex><span>		inode<span style=color:#666>-&gt;</span>i_dirt <span style=color:#666>=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>		bh <span style=color:#666>=</span> <span style=color:#06287e>add_entry</span>(dir,basename,namelen,<span style=color:#666>&amp;</span>de);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>bh) {
</span></span><span style=display:flex><span>			inode<span style=color:#666>-&gt;</span>i_nlinks<span style=color:#666>--</span>;
</span></span><span style=display:flex><span>			<span style=color:#06287e>iput</span>(inode);
</span></span><span style=display:flex><span>			<span style=color:#06287e>iput</span>(dir);
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>ENOSPC;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		de<span style=color:#666>-&gt;</span>inode <span style=color:#666>=</span> inode<span style=color:#666>-&gt;</span>i_num;
</span></span><span style=display:flex><span>		bh<span style=color:#666>-&gt;</span>b_dirt <span style=color:#666>=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>		<span style=color:#06287e>brelse</span>(bh);
</span></span><span style=display:flex><span>		<span style=color:#06287e>iput</span>(dir);
</span></span><span style=display:flex><span>		<span style=color:#666>*</span>res_inode <span style=color:#666>=</span> inode;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	inr <span style=color:#666>=</span> de<span style=color:#666>-&gt;</span>inode;
</span></span><span style=display:flex><span>	dev <span style=color:#666>=</span> dir<span style=color:#666>-&gt;</span>i_dev;
</span></span><span style=display:flex><span>	<span style=color:#06287e>brelse</span>(bh);
</span></span><span style=display:flex><span>	<span style=color:#06287e>iput</span>(dir);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (flag <span style=color:#666>&amp;</span> O_EXCL)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EEXIST;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(inode<span style=color:#666>=</span><span style=color:#06287e>iget</span>(dev,inr)))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EACCES;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> ((<span style=color:#06287e>S_ISDIR</span>(inode<span style=color:#666>-&gt;</span>i_mode) <span style=color:#666>&amp;&amp;</span> (flag <span style=color:#666>&amp;</span> O_ACCMODE)) <span style=color:#666>||</span>
</span></span><span style=display:flex><span>	    <span style=color:#666>!</span><span style=color:#06287e>permission</span>(inode,<span style=color:#06287e>ACC_MODE</span>(flag))) {
</span></span><span style=display:flex><span>		<span style=color:#06287e>iput</span>(inode);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EPERM;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	inode<span style=color:#666>-&gt;</span>i_atime <span style=color:#666>=</span> CURRENT_TIME;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (flag <span style=color:#666>&amp;</span> O_TRUNC)
</span></span><span style=display:flex><span>		<span style=color:#06287e>truncate</span>(inode);
</span></span><span style=display:flex><span>	<span style=color:#666>*</span>res_inode <span style=color:#666>=</span> inode;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=文件写入>文件写入</h3><p>接下来就要进行文件写入的流程了</p><p>如何陷入内核态函数就不再细说了，相信看过这么多系统调用之后，也能知道基本上系统调用在内核态对应的函数都是以 sys_<method> 形式出现的</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>sys_write</span>(<span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> fd,<span style=color:#902000>char</span> <span style=color:#666>*</span> buf,<span style=color:#902000>int</span> count)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> file <span style=color:#666>*</span> file;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> m_inode <span style=color:#666>*</span> inode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 非法 fd , 抛异常 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (fd<span style=color:#666>&gt;=</span>NR_OPEN <span style=color:#666>||</span> count <span style=color:#666>&lt;</span><span style=color:#40a070>0</span> <span style=color:#666>||</span> <span style=color:#666>!</span>(file<span style=color:#666>=</span>current<span style=color:#666>-&gt;</span>filp[fd]))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* count = 0，无需写入数据 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>count)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	inode<span style=color:#666>=</span>file<span style=color:#666>-&gt;</span>f_inode;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 针对不同的i节点类型，有不同的写入函数 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (inode<span style=color:#666>-&gt;</span>i_pipe)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> (file<span style=color:#666>-&gt;</span>f_mode<span style=color:#666>&amp;</span><span style=color:#40a070>2</span>)<span style=color:#666>?</span><span style=color:#06287e>write_pipe</span>(inode,buf,count)<span style=color:#666>:-</span>EIO;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>S_ISCHR</span>(inode<span style=color:#666>-&gt;</span>i_mode))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>rw_char</span>(WRITE,inode<span style=color:#666>-&gt;</span>i_zone[<span style=color:#40a070>0</span>],buf,count,<span style=color:#666>&amp;</span>file<span style=color:#666>-&gt;</span>f_pos);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>S_ISBLK</span>(inode<span style=color:#666>-&gt;</span>i_mode))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>block_write</span>(inode<span style=color:#666>-&gt;</span>i_zone[<span style=color:#40a070>0</span>],<span style=color:#666>&amp;</span>file<span style=color:#666>-&gt;</span>f_pos,buf,count);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>S_ISREG</span>(inode<span style=color:#666>-&gt;</span>i_mode))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>file_write</span>(inode,file,buf,count);
</span></span><span style=display:flex><span>	<span style=color:#06287e>printk</span>(<span style=color:#4070a0>&#34;(Write)inode-&gt;i_mode=%06o</span><span style=color:#4070a0;font-weight:700>\n\r</span><span style=color:#4070a0>&#34;</span>,inode<span style=color:#666>-&gt;</span>i_mode);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>看看对于常规文件是怎么操作的吧。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>file_write</span>(<span style=color:#007020;font-weight:700>struct</span> m_inode <span style=color:#666>*</span> inode, <span style=color:#007020;font-weight:700>struct</span> file <span style=color:#666>*</span> filp, <span style=color:#902000>char</span> <span style=color:#666>*</span> buf, <span style=color:#902000>int</span> count)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>off_t</span> pos;      <span style=color:#60a0b0;font-style:italic>/* 偏移量 */</span>
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> block,c;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> buffer_head <span style=color:#666>*</span> bh;
</span></span><span style=display:flex><span>	<span style=color:#902000>char</span> <span style=color:#666>*</span> p;
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> i<span style=color:#666>=</span><span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 如果是 Append 模式，把偏移量重置到文件末尾 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (filp<span style=color:#666>-&gt;</span>f_flags <span style=color:#666>&amp;</span> O_APPEND) 
</span></span><span style=display:flex><span>		pos <span style=color:#666>=</span> inode<span style=color:#666>-&gt;</span>i_size;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 否则就使用当前文件数据结构持有的偏移量 */</span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>        附上数据结构  file 的内容 
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>        struct file {
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>        	unsigned short f_mode;
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>        	unsigned short f_flags;
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>        	unsigned short f_count;
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>        	struct m_inode * f_inode;
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>        	off_t f_pos;    每个打开的文件都将持有当前的偏移值
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>        };
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>		pos <span style=color:#666>=</span> filp<span style=color:#666>-&gt;</span>f_pos;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 逐字符向缓冲区写入数据 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>while</span> (i<span style=color:#666>&lt;</span>count) {
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 最开始当然是创建在磁盘上占用一个数据块了 (如果文件对应的块不存在的话) */</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(block <span style=color:#666>=</span> <span style=color:#06287e>create_block</span>(inode,pos<span style=color:#666>/</span>BLOCK_SIZE)))
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 根据数据块获得相应的缓冲块 */</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(bh<span style=color:#666>=</span><span style=color:#06287e>bread</span>(inode<span style=color:#666>-&gt;</span>i_dev,block)))
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 在缓冲块中的偏移量 */</span>
</span></span><span style=display:flex><span>		c <span style=color:#666>=</span> pos <span style=color:#666>%</span> BLOCK_SIZE;
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 定位到具体的缓冲区的内存地址 */</span>
</span></span><span style=display:flex><span>		p <span style=color:#666>=</span> c <span style=color:#666>+</span> bh<span style=color:#666>-&gt;</span>b_data;
</span></span><span style=display:flex><span>		bh<span style=color:#666>-&gt;</span>b_dirt <span style=color:#666>=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 当前这个缓冲块还有多少字节可写 */</span>
</span></span><span style=display:flex><span>		c <span style=color:#666>=</span> BLOCK_SIZE<span style=color:#666>-</span>c;
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 如果需要写入的数据量少于 c */</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (c <span style=color:#666>&gt;</span> count<span style=color:#666>-</span>i) c <span style=color:#666>=</span> count<span style=color:#666>-</span>i;
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 添加偏移量计数, 更新数据结构中维护的值 */</span>
</span></span><span style=display:flex><span>		pos <span style=color:#666>+=</span> c;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (pos <span style=color:#666>&gt;</span> inode<span style=color:#666>-&gt;</span>i_size) {
</span></span><span style=display:flex><span>			inode<span style=color:#666>-&gt;</span>i_size <span style=color:#666>=</span> pos;
</span></span><span style=display:flex><span>			inode<span style=color:#666>-&gt;</span>i_dirt <span style=color:#666>=</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		i <span style=color:#666>+=</span> c;
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 向缓冲块逐字节写入数据 */</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>while</span> (c<span style=color:#666>--&gt;</span><span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>			<span style=color:#666>*</span>(p<span style=color:#666>++</span>) <span style=color:#666>=</span> <span style=color:#06287e>get_fs_byte</span>(buf<span style=color:#666>++</span>);
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 释放对缓冲块的占用，当然，在释放前会完成缓冲块&lt;-&gt;外存数据块的同步 */</span>
</span></span><span style=display:flex><span>		<span style=color:#06287e>brelse</span>(bh);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	inode<span style=color:#666>-&gt;</span>i_mtime <span style=color:#666>=</span> CURRENT_TIME;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(filp<span style=color:#666>-&gt;</span>f_flags <span style=color:#666>&amp;</span> O_APPEND)) {
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 非 APPEND 模式，更新文件读写指针(偏移量); APPEND 模式是使用 inode-&gt;i_size ，所有就不需要在这里更新了 */</span>
</span></span><span style=display:flex><span>		filp<span style=color:#666>-&gt;</span>f_pos <span style=color:#666>=</span> pos;
</span></span><span style=display:flex><span>		inode<span style=color:#666>-&gt;</span>i_ctime <span style=color:#666>=</span> CURRENT_TIME;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> (i<span style=color:#666>?</span><span style=color:#002070;font-weight:700>i</span>:<span style=color:#666>-</span><span style=color:#40a070>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>是不是觉得也没有什么太高大上的操作。确实如此，更多关于缓存块与文件系统数据块的同步都已经被包装到 bread(), brelse() 中了。</p><p>不过，暂时无需细究。总之到此为止，先要有一个基础的观念: 所有与外存储器(这里也包括控制台等)进行数据交互都必须经过缓冲区</p><p>缓冲区封装了对外存储器的全部操作，而提供给 CPU 更高效的 I/O 操作，当然，也更为简单快捷</p><h3 id=文件读取>文件读取</h3><p>至于文件读取，也基本类似了，所以也就不再深入描述。</p><p>当然，要注意的就是，在本篇开始的部分提供的例程中，write & read 中插入了 <code>off_t off = lseek(fd, 0, SEEK_SET);</code> 这样的代码。</p><p>原因应该也能够想到，学习 <code>sys_write(..)</code> 的时候我们已经看到，任务对同一个文件在内存中维护了一个文件读写偏移量。因此，要读取刚才写入的内容，就不得不先改动这个读写偏移量了</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>sys_read</span>(<span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> fd,<span style=color:#902000>char</span> <span style=color:#666>*</span> buf,<span style=color:#902000>int</span> count)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> file <span style=color:#666>*</span> file;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> m_inode <span style=color:#666>*</span> inode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (fd<span style=color:#666>&gt;=</span>NR_OPEN <span style=color:#666>||</span> count<span style=color:#666>&lt;</span><span style=color:#40a070>0</span> <span style=color:#666>||</span> <span style=color:#666>!</span>(file<span style=color:#666>=</span>current<span style=color:#666>-&gt;</span>filp[fd]))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>count)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#06287e>verify_area</span>(buf,count);
</span></span><span style=display:flex><span>	inode <span style=color:#666>=</span> file<span style=color:#666>-&gt;</span>f_inode;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (inode<span style=color:#666>-&gt;</span>i_pipe)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> (file<span style=color:#666>-&gt;</span>f_mode<span style=color:#666>&amp;</span><span style=color:#40a070>1</span>)<span style=color:#666>?</span><span style=color:#06287e>read_pipe</span>(inode,buf,count)<span style=color:#666>:-</span>EIO;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>S_ISCHR</span>(inode<span style=color:#666>-&gt;</span>i_mode))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>rw_char</span>(READ,inode<span style=color:#666>-&gt;</span>i_zone[<span style=color:#40a070>0</span>],buf,count,<span style=color:#666>&amp;</span>file<span style=color:#666>-&gt;</span>f_pos);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>S_ISBLK</span>(inode<span style=color:#666>-&gt;</span>i_mode))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>block_read</span>(inode<span style=color:#666>-&gt;</span>i_zone[<span style=color:#40a070>0</span>],<span style=color:#666>&amp;</span>file<span style=color:#666>-&gt;</span>f_pos,buf,count);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>S_ISDIR</span>(inode<span style=color:#666>-&gt;</span>i_mode) <span style=color:#666>||</span> <span style=color:#06287e>S_ISREG</span>(inode<span style=color:#666>-&gt;</span>i_mode)) {
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (count<span style=color:#666>+</span>file<span style=color:#666>-&gt;</span>f_pos <span style=color:#666>&gt;</span> inode<span style=color:#666>-&gt;</span>i_size)
</span></span><span style=display:flex><span>			count <span style=color:#666>=</span> inode<span style=color:#666>-&gt;</span>i_size <span style=color:#666>-</span> file<span style=color:#666>-&gt;</span>f_pos;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (count<span style=color:#666>&lt;=</span><span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>file_read</span>(inode,file,buf,count);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#06287e>printk</span>(<span style=color:#4070a0>&#34;(Read)inode-&gt;i_mode=%06o</span><span style=color:#4070a0;font-weight:700>\n\r</span><span style=color:#4070a0>&#34;</span>,inode<span style=color:#666>-&gt;</span>i_mode);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=小结>小结</h2><p>这篇对文件系统的代码层面的描述，仅仅只是捡了一个相当有限的片面 (常规文件读写)。从文件系统的挂载开始提供了一个读写的完整流程介绍(当然，很多细节是缺失的，不过不要着急)。</p><p>虽然平常都能够了解到一个比较模糊的前提，文件读写需要利用缓冲区，但是究竟什么是缓存区，如何使用都不会有太多的概念。本篇最大的重点，就是首先请读者们建立起一个基础性的对缓冲区的了解。事实上，这个中介在 I/O 中扮演了相当重要的角色。而且内存也为其提供了相当大的一份空间，差不多有 1/4 了。</p><p>跨了差不多半个多月来写，上下文的承接可能有些生硬了，甚至不一致了&mldr; 尴尬&mldr;</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>  __                    __                  
</span></span><span style=display:flex><span> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ 
</span></span><span style=display:flex><span>| |_ / _` | &#39;_ \ / _` | |_ / _ \ &#39;_ \ / _` |
</span></span><span style=display:flex><span>|  _| (_| | | | | (_| |  _|  __/ | | | (_| |
</span></span><span style=display:flex><span>|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |
</span></span><span style=display:flex><span>                 |___/                |___/ 
</span></span></code></pre></div></div><div class="row middle-xs"><div class=col-xs-12><div class=post-tags><a href=/tags/linux/>Linux</a></div><div class=post-tags><a href=/tags/kernel/>Kernel</a></div><div class=post-tags><a href=/tags/file-system/>File System</a></div><div class=post-tags><a href=/tags/read-write/>read & write</a></div></div></div><div class=row><div class=col-xs-12><script type=module> import mermaid from "https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs"; mermaid.initialize({ startOnLoad: true }); </script></div></div><div class=related-content><h3>Related Posts</h3><ul><li><a href=/posts/2018-10-14-understand-kernel-5/>理解 Linux Kernel (5) - 文件系统(宏观描述)</a></li><li><a href=/posts/2018-10-12-understand-kernel-4/>理解 Linux Kernel (4) - 任务调度</a></li><li><a href=/posts/2018-10-06-understand-kernel-3/>理解 Linux Kernel (3) - 操作系统启动</a></li></ul></div><div style=height:50px></div><div class=post-comments><div id=disqus_thread></div><script>window.addEventListener("load",()=>{(function(){var e=document,t=e.createElement("script");t.src="https://ffutop.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()})</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=site-footer></div></div></div></article><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("disqus_thread"),t=new MutationObserver(function(n){n.forEach(function(){const s=e.getElementsByTagName("iframe");if(s.length>1){const n=s[1];for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(n),t.disconnect()}})});t.observe(e,{childList:!0,subtree:!0})})</script></body></html>