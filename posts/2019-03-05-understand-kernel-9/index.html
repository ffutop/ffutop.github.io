<!doctype html><html lang=en><head><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="ffutop"><meta property="og:url" content="https://www.ffutop.com/posts/2019-03-05-understand-kernel-9/"><link rel=canonical href=https://www.ffutop.com/posts/2019-03-05-understand-kernel-9/><link rel=apple-touch-icon href=favicon.ico><link rel=icon href=favicon.ico><link rel=shortcut href=favicon.ico><link rel=alternate type=application/atom+xml href=https://www.ffutop.com/index.xml title="Utop's Blog"><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.ffutop.com\/"},"articleSection":"posts","name":"理解 Linux Kernel (9) - IO Multiplexing","headline":"理解 Linux Kernel (9) - IO Multiplexing","description":"前一篇已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程\/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 struct sock 对象，将其逐级从网络接口层逐级提升到网络层、传输层\u0026hellip;最终添加到接收队列 sk_receive_queue 中；用户进程通过 read、recv、recvfrom 等命令检查并获取 sk_receive_queue 中的数据。\n整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。\n那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（select, poll, epoll）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 select 和 epoll 两类系统调用的实现进行探究。\n","inLanguage":"en-US","author":"ffutop","creator":"ffutop","publisher":"ffutop","accountablePerson":"ffutop","copyrightHolder":"ffutop","copyrightYear":"2019","datePublished":"2019-03-05 00:00:00 \u002b0000 UTC","dateModified":"2019-03-05 00:00:00 \u002b0000 UTC","url":"https:\/\/www.ffutop.com\/posts\/2019-03-05-understand-kernel-9\/","keywords":["Linux","Kernel","IO Model"]}</script><title>理解 Linux Kernel (9) - IO Multiplexing</title><meta property="og:title" content="理解 Linux Kernel (9) - IO Multiplexing"><meta property="og:type" content="article"><meta property="og:description" content="前一篇已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 struct sock 对象，将其逐级从网络接口层逐级提升到网络层、传输层&amp;hellip;最终添加到接收队列 sk_receive_queue 中；用户进程通过 read、recv、recvfrom 等命令检查并获取 sk_receive_queue 中的数据。
整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。
那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（select, poll, epoll）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 select 和 epoll 两类系统调用的实现进行探究。
"><meta name=description content="前一篇已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 struct sock 对象，将其逐级从网络接口层逐级提升到网络层、传输层&amp;hellip;最终添加到接收队列 sk_receive_queue 中；用户进程通过 read、recv、recvfrom 等命令检查并获取 sk_receive_queue 中的数据。
整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。
那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（select, poll, epoll）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 select 和 epoll 两类系统调用的实现进行探究。
"><meta property="og:locale" content="zh-cmn-Hans-CN"><meta property="og:image" content="favicon.ico"><style>body{font-family:-apple-system,BlinkMacSystemFont,segoe ui,noto sans,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji;font-weight:400;margin:0 20px}article{max-width:800px;margin-left:auto;margin-right:auto}a{color:#333;text-decoration:none}a:hover{font-weight:600;text-decoration:underline}.post-ads{margin:50px 0}.markdown-body{color-scheme:light;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;margin:0;color:#1f2328;background-color:#fff;font-family:-apple-system,BlinkMacSystemFont,segoe ui,noto sans,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji;font-size:16px;line-height:1.5;word-wrap:break-word}.markdown-body .octicon{display:inline-block;fill:currentColor;vertical-align:text-bottom}.markdown-body h1:hover .anchor .octicon-link:before,.markdown-body h2:hover .anchor .octicon-link:before,.markdown-body h3:hover .anchor .octicon-link:before,.markdown-body h4:hover .anchor .octicon-link:before,.markdown-body h5:hover .anchor .octicon-link:before,.markdown-body h6:hover .anchor .octicon-link:before{width:16px;height:16px;content:' ';display:inline-block;background-color:currentColor;-webkit-mask-image:url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>");mask-image:url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' version='1.1' aria-hidden='true'><path fill-rule='evenodd' d='M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z'></path></svg>")}.markdown-body details,.markdown-body figcaption,.markdown-body figure{display:block}.markdown-body summary{display:list-item}.markdown-body [hidden]{display:none!important}.markdown-body a{background-color:transparent;color:#0969da;text-decoration:none}.markdown-body abbr[title]{border-bottom:none;-webkit-text-decoration:underline dotted;text-decoration:underline dotted}.markdown-body b,.markdown-body strong{font-weight:600}.markdown-body dfn{font-style:italic}.markdown-body h1{margin:.67em 0;font-weight:600;padding-bottom:.3em;font-size:2em;border-bottom:1px solid #d1d9e0b3}.markdown-body mark{background-color:#fff8c5;color:#1f2328}.markdown-body small{font-size:90%}.markdown-body sub,.markdown-body sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}.markdown-body sub{bottom:-.25em}.markdown-body sup{top:-.5em}.markdown-body img{border-style:none;max-width:100%;box-sizing:content-box}.markdown-body code,.markdown-body kbd,.markdown-body pre,.markdown-body samp{font-family:monospace;font-size:1em}.markdown-body figure{margin:1em 2.5rem}.markdown-body hr{box-sizing:content-box;overflow:hidden;background:0 0;border-bottom:1px solid #d1d9e0b3;height:.25em;padding:0;margin:1.5rem 0;background-color:#d1d9e0;border:0}.markdown-body input{font:inherit;margin:0;overflow:visible;font-family:inherit;font-size:inherit;line-height:inherit}.markdown-body [type=button],.markdown-body [type=reset],.markdown-body [type=submit]{-webkit-appearance:button;appearance:button}.markdown-body [type=checkbox],.markdown-body [type=radio]{box-sizing:border-box;padding:0}.markdown-body [type=number]::-webkit-inner-spin-button,.markdown-body [type=number]::-webkit-outer-spin-button{height:auto}.markdown-body [type=search]::-webkit-search-cancel-button,.markdown-body [type=search]::-webkit-search-decoration{-webkit-appearance:none;appearance:none}.markdown-body ::-webkit-input-placeholder{color:inherit;opacity:.54}.markdown-body ::-webkit-file-upload-button{-webkit-appearance:button;appearance:button;font:inherit}.markdown-body a:hover{text-decoration:underline}.markdown-body ::placeholder{color:#59636e;opacity:1}.markdown-body hr::before{display:table;content:""}.markdown-body hr::after{display:table;clear:both;content:""}.markdown-body table{border-spacing:0;border-collapse:collapse;display:block;width:max-content;max-width:100%;overflow:auto;font-variant:tabular-nums}.markdown-body td,.markdown-body th{padding:0}.markdown-body details summary{cursor:pointer}.markdown-body a:focus,.markdown-body [role=button]:focus,.markdown-body input[type=radio]:focus,.markdown-body input[type=checkbox]:focus{outline:2px solid #0969da;outline-offset:-2px;box-shadow:none}.markdown-body a:focus:not(:focus-visible),.markdown-body [role=button]:focus:not(:focus-visible),.markdown-body input[type=radio]:focus:not(:focus-visible),.markdown-body input[type=checkbox]:focus:not(:focus-visible){outline:solid 1px transparent}.markdown-body a:focus-visible,.markdown-body [role=button]:focus-visible,.markdown-body input[type=radio]:focus-visible,.markdown-body input[type=checkbox]:focus-visible{outline:2px solid #0969da;outline-offset:-2px;box-shadow:none}.markdown-body a:not([class]):focus,.markdown-body a:not([class]):focus-visible,.markdown-body input[type=radio]:focus,.markdown-body input[type=radio]:focus-visible,.markdown-body input[type=checkbox]:focus,.markdown-body input[type=checkbox]:focus-visible{outline-offset:0}.markdown-body kbd{display:inline-block;padding:.25rem;font:11px ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;line-height:10px;color:#1f2328;vertical-align:middle;background-color:#f6f8fa;border:solid 1px #d1d9e0b3;border-bottom-color:#d1d9e0b3;border-radius:6px;box-shadow:inset 0 -1px #d1d9e0b3}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{margin-top:1.5rem;margin-bottom:1rem;font-weight:600;line-height:1.25}.markdown-body h2{font-weight:600;padding-bottom:.3em;font-size:1.5em;border-bottom:1px solid #d1d9e0b3}.markdown-body h3{font-weight:600;font-size:1.25em}.markdown-body h4{font-weight:600;font-size:1em}.markdown-body h5{font-weight:600;font-size:.875em}.markdown-body h6{font-weight:600;font-size:.85em;color:#59636e}.markdown-body p{margin-top:0;margin-bottom:10px}.markdown-body blockquote{margin:0;padding:0 1em;color:#59636e;border-left:.25em solid #d1d9e0}.markdown-body ul,.markdown-body ol{margin-top:0;margin-bottom:0;padding-left:2em}.markdown-body ol ol,.markdown-body ul ol{list-style-type:lower-roman}.markdown-body ul ul ol,.markdown-body ul ol ol,.markdown-body ol ul ol,.markdown-body ol ol ol{list-style-type:lower-alpha}.markdown-body dd{margin-left:0}.markdown-body tt,.markdown-body code,.markdown-body samp{font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;font-size:12px}.markdown-body pre{margin-top:0;margin-bottom:0;font-family:ui-monospace,SFMono-Regular,SF Mono,Menlo,Consolas,Liberation Mono,monospace;font-size:12px;word-wrap:normal}.markdown-body .octicon{display:inline-block;overflow:visible!important;vertical-align:text-bottom;fill:currentColor}.markdown-body input::-webkit-outer-spin-button,.markdown-body input::-webkit-inner-spin-button{margin:0;appearance:none}.markdown-body .mr-2{margin-right:.5rem!important}.markdown-body::before{display:table;content:""}.markdown-body::after{display:table;clear:both;content:""}.markdown-body>*:first-child{margin-top:0!important}.markdown-body>*:last-child{margin-bottom:0!important}.markdown-body a:not([href]){color:inherit;text-decoration:none}.markdown-body .absent{color:#d1242f}.markdown-body .anchor{float:left;padding-right:.25rem;margin-left:-20px;line-height:1}.markdown-body .anchor:focus{outline:none}.markdown-body p,.markdown-body blockquote,.markdown-body ul,.markdown-body ol,.markdown-body dl,.markdown-body table,.markdown-body pre,.markdown-body details{margin-top:0;margin-bottom:1rem}.markdown-body blockquote>:first-child{margin-top:0}.markdown-body blockquote>:last-child{margin-bottom:0}.markdown-body h1 .octicon-link,.markdown-body h2 .octicon-link,.markdown-body h3 .octicon-link,.markdown-body h4 .octicon-link,.markdown-body h5 .octicon-link,.markdown-body h6 .octicon-link{color:#1f2328;vertical-align:middle;visibility:hidden}.markdown-body h1:hover .anchor,.markdown-body h2:hover .anchor,.markdown-body h3:hover .anchor,.markdown-body h4:hover .anchor,.markdown-body h5:hover .anchor,.markdown-body h6:hover .anchor{text-decoration:none}.markdown-body h1:hover .anchor .octicon-link,.markdown-body h2:hover .anchor .octicon-link,.markdown-body h3:hover .anchor .octicon-link,.markdown-body h4:hover .anchor .octicon-link,.markdown-body h5:hover .anchor .octicon-link,.markdown-body h6:hover .anchor .octicon-link{visibility:visible}.markdown-body h1 tt,.markdown-body h1 code,.markdown-body h2 tt,.markdown-body h2 code,.markdown-body h3 tt,.markdown-body h3 code,.markdown-body h4 tt,.markdown-body h4 code,.markdown-body h5 tt,.markdown-body h5 code,.markdown-body h6 tt,.markdown-body h6 code{padding:0 .2em;font-size:inherit}.markdown-body summary h1,.markdown-body summary h2,.markdown-body summary h3,.markdown-body summary h4,.markdown-body summary h5,.markdown-body summary h6{display:inline-block}.markdown-body summary h1 .anchor,.markdown-body summary h2 .anchor,.markdown-body summary h3 .anchor,.markdown-body summary h4 .anchor,.markdown-body summary h5 .anchor,.markdown-body summary h6 .anchor{margin-left:-40px}.markdown-body summary h1,.markdown-body summary h2{padding-bottom:0;border-bottom:0}.markdown-body ul.no-list,.markdown-body ol.no-list{padding:0;list-style-type:none}.markdown-body ol[type="a s"]{list-style-type:lower-alpha}.markdown-body ol[type="A s"]{list-style-type:upper-alpha}.markdown-body ol[type="i s"]{list-style-type:lower-roman}.markdown-body ol[type="I s"]{list-style-type:upper-roman}.markdown-body ol[type="1"]{list-style-type:decimal}.markdown-body div>ol:not([type]){list-style-type:decimal}.markdown-body ul ul,.markdown-body ul ol,.markdown-body ol ol,.markdown-body ol ul{margin-top:0;margin-bottom:0}.markdown-body li>p{margin-top:1rem}.markdown-body li+li{margin-top:.25em}.markdown-body dl{padding:0}.markdown-body dl dt{padding:0;margin-top:1rem;font-size:1em;font-style:italic;font-weight:600}.markdown-body dl dd{padding:0 1rem;margin-bottom:1rem}.markdown-body table th{font-weight:600}.markdown-body table th,.markdown-body table td{padding:6px 13px;border:1px solid #d1d9e0}.markdown-body table td>:last-child{margin-bottom:0}.markdown-body table tr{background-color:#fff;border-top:1px solid #d1d9e0b3}.markdown-body table tr:nth-child(2n){background-color:#f6f8fa}.markdown-body table img{background-color:transparent}.markdown-body img[align=right]{padding-left:20px}.markdown-body img[align=left]{padding-right:20px}.markdown-body .emoji{max-width:none;vertical-align:text-top;background-color:transparent}.markdown-body span.frame{display:block;overflow:hidden}.markdown-body span.frame>span{display:block;float:left;width:auto;padding:7px;margin:13px 0 0;overflow:hidden;border:1px solid #d1d9e0}.markdown-body span.frame span img{display:block;float:left}.markdown-body span.frame span span{display:block;padding:5px 0 0;clear:both;color:#1f2328}.markdown-body span.align-center{display:block;overflow:hidden;clear:both}.markdown-body span.align-center>span{display:block;margin:13px auto 0;overflow:hidden;text-align:center}.markdown-body span.align-center span img{margin:0 auto;text-align:center}.markdown-body span.align-right{display:block;overflow:hidden;clear:both}.markdown-body span.align-right>span{display:block;margin:13px 0 0;overflow:hidden;text-align:right}.markdown-body span.align-right span img{margin:0;text-align:right}.markdown-body span.float-left{display:block;float:left;margin-right:13px;overflow:hidden}.markdown-body span.float-left span{margin:13px 0 0}.markdown-body span.float-right{display:block;float:right;margin-left:13px;overflow:hidden}.markdown-body span.float-right>span{display:block;margin:13px auto 0;overflow:hidden;text-align:right}.markdown-body code,.markdown-body tt{padding:.2em .4em;margin:0;font-size:85%;white-space:break-spaces;background-color:#818b981f;border-radius:6px}.markdown-body code br,.markdown-body tt br{display:none}.markdown-body del code{text-decoration:inherit}.markdown-body samp{font-size:85%}.markdown-body pre code{font-size:100%}.markdown-body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}.markdown-body .highlight{margin-bottom:1rem}.markdown-body .highlight pre{margin-bottom:0;word-break:normal}.markdown-body .highlight pre,.markdown-body pre{padding:1rem;overflow:auto;font-size:85%;line-height:1.45;color:#1f2328;background-color:#f6f8fa;border-radius:6px}.markdown-body pre code,.markdown-body pre tt{display:inline;max-width:auto;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}.markdown-body .csv-data td,.markdown-body .csv-data th{padding:5px;overflow:hidden;font-size:12px;line-height:1;text-align:left;white-space:nowrap}.markdown-body .csv-data .blob-num{padding:10px .5rem 9px;text-align:right;background:#fff;border:0}.markdown-body .csv-data tr{border-top:0}.markdown-body .csv-data th{font-weight:600;background:#f6f8fa;border-top:0}.markdown-body [data-footnote-ref]::before{content:"["}.markdown-body [data-footnote-ref]::after{content:"]"}.markdown-body .footnotes{font-size:12px;color:#59636e;border-top:1px solid #d1d9e0}.markdown-body .footnotes ol{padding-left:1rem}.markdown-body .footnotes ol ul{display:inline-block;padding-left:1rem;margin-top:1rem}.markdown-body .footnotes li{position:relative}.markdown-body .footnotes li:target::before{position:absolute;top:calc(.5rem*-1);right:calc(.5rem*-1);bottom:calc(.5rem*-1);left:calc(1.5rem*-1);pointer-events:none;content:"";border:2px solid #0969da;border-radius:6px}.markdown-body .footnotes li:target{color:#1f2328}.markdown-body .footnotes .data-footnote-backref g-emoji{font-family:monospace}.markdown-body body:has(:modal){padding-right:var(--dialog-scrollgutter)!important}.markdown-body .pl-c{color:#59636e}.markdown-body .pl-c1,.markdown-body .pl-s .pl-v{color:#0550ae}.markdown-body .pl-e,.markdown-body .pl-en{color:#6639ba}.markdown-body .pl-smi,.markdown-body .pl-s .pl-s1{color:#1f2328}.markdown-body .pl-ent{color:#0550ae}.markdown-body .pl-k{color:#cf222e}.markdown-body .pl-s,.markdown-body .pl-pds,.markdown-body .pl-s .pl-pse .pl-s1,.markdown-body .pl-sr,.markdown-body .pl-sr .pl-cce,.markdown-body .pl-sr .pl-sre,.markdown-body .pl-sr .pl-sra{color:#0a3069}.markdown-body .pl-v,.markdown-body .pl-smw{color:#953800}.markdown-body .pl-bu{color:#82071e}.markdown-body .pl-ii{color:#f6f8fa;background-color:#82071e}.markdown-body .pl-c2{color:#f6f8fa;background-color:#cf222e}.markdown-body .pl-sr .pl-cce{font-weight:700;color:#116329}.markdown-body .pl-ml{color:#3b2300}.markdown-body .pl-mh,.markdown-body .pl-mh .pl-en,.markdown-body .pl-ms{font-weight:700;color:#0550ae}.markdown-body .pl-mi{font-style:italic;color:#1f2328}.markdown-body .pl-mb{font-weight:700;color:#1f2328}.markdown-body .pl-md{color:#82071e;background-color:#ffebe9}.markdown-body .pl-mi1{color:#116329;background-color:#dafbe1}.markdown-body .pl-mc{color:#953800;background-color:#ffd8b5}.markdown-body .pl-mi2{color:#d1d9e0;background-color:#0550ae}.markdown-body .pl-mdr{font-weight:700;color:#8250df}.markdown-body .pl-ba{color:#59636e}.markdown-body .pl-sg{color:#818b98}.markdown-body .pl-corl{text-decoration:underline;color:#0a3069}.markdown-body [role=button]:focus:not(:focus-visible),.markdown-body [role=tabpanel][tabindex="0"]:focus:not(:focus-visible),.markdown-body button:focus:not(:focus-visible),.markdown-body summary:focus:not(:focus-visible),.markdown-body a:focus:not(:focus-visible){outline:none;box-shadow:none}.markdown-body [tabindex="0"]:focus:not(:focus-visible),.markdown-body details-dialog:focus:not(:focus-visible){outline:none}.markdown-body g-emoji{display:inline-block;min-width:1ch;font-family:apple color emoji,segoe ui emoji,segoe ui symbol;font-size:1em;font-style:normal!important;font-weight:400;line-height:1;vertical-align:-.075em}.markdown-body g-emoji img{width:1em;height:1em}.markdown-body .task-list-item{list-style-type:none}.markdown-body .task-list-item label{font-weight:400}.markdown-body .task-list-item.enabled label{cursor:pointer}.markdown-body .task-list-item+.task-list-item{margin-top:.25rem}.markdown-body .task-list-item .handle{display:none}.markdown-body .task-list-item-checkbox{margin:0 .2em .25em -1.4em;vertical-align:middle}.markdown-body ul:dir(rtl) .task-list-item-checkbox{margin:0 -1.6em .25em .2em}.markdown-body ol:dir(rtl) .task-list-item-checkbox{margin:0 -1.6em .25em .2em}.markdown-body .contains-task-list:hover .task-list-item-convert-container,.markdown-body .contains-task-list:focus-within .task-list-item-convert-container{display:block;width:auto;height:24px;overflow:visible;clip:auto}.markdown-body ::-webkit-calendar-picker-indicator{filter:invert(50%)}.markdown-body .markdown-alert{padding:.5rem 1rem;margin-bottom:1rem;color:inherit;border-left:.25em solid #d1d9e0}.markdown-body .markdown-alert>:first-child{margin-top:0}.markdown-body .markdown-alert>:last-child{margin-bottom:0}.markdown-body .markdown-alert .markdown-alert-title{display:flex;font-weight:500;align-items:center;line-height:1}.markdown-body .markdown-alert.markdown-alert-note{border-left-color:#0969da}.markdown-body .markdown-alert.markdown-alert-note .markdown-alert-title{color:#0969da}.markdown-body .markdown-alert.markdown-alert-important{border-left-color:#8250df}.markdown-body .markdown-alert.markdown-alert-important .markdown-alert-title{color:#8250df}.markdown-body .markdown-alert.markdown-alert-warning{border-left-color:#9a6700}.markdown-body .markdown-alert.markdown-alert-warning .markdown-alert-title{color:#9a6700}.markdown-body .markdown-alert.markdown-alert-tip{border-left-color:#1a7f37}.markdown-body .markdown-alert.markdown-alert-tip .markdown-alert-title{color:#1a7f37}.markdown-body .markdown-alert.markdown-alert-caution{border-left-color:#cf222e}.markdown-body .markdown-alert.markdown-alert-caution .markdown-alert-title{color:#d1242f}.markdown-body>*:first-child>.heading-element:first-child{margin-top:0!important}.markdown-body .highlight pre:has(+.zeroclipboard-container){min-height:52px}.Chinese .markdown-body{line-height:150%}.site-date-catalog{font-size:1.8rem}.header-title{font-size:2rem;font-weight:700;margin-top:32px;font-family:bungee shade,sans-serif}.header-title a{text-decoration:none}.header-subtitle{color:#666}.header-items{margin:10px 0}.header-item{margin:0 5px}.header-line{width:100%;border-width:2px;border-color:#482936;border-style:solid none none none}.lang-switch{font-weight:600}#posts-list{min-height:600px}.posts-line{font-size:1rem;margin:8px 0;font-weight:500}.posts-categories{font-size:.8rem;margin:auto;text-align:center}.posts-category{padding:3px 0;border:#000 2px solid;border-radius:5px}.site-footer{margin-top:50px}.site-footer-item{margin-right:12px}.post-header{margin-bottom:50px}.post-title{font-size:2rem;font-weight:600;margin-bottom:.5em}.post-tags{display:inline;font-weight:400;padding:2px 5px;margin-right:6px;border:#000 2px solid;border-radius:5px}.post-date{font-weight:400;font-style:italic}.post-author{float:right;font-weight:400}.page-content{min-height:60%}.post-content{margin-bottom:50px;margin-left:auto;margin-right:auto;padding-left:15px;padding-right:15px}.post-content p{hyphens:auto;font-size:1rem;line-height:1.7;margin-top:0;margin-bottom:1.2em}.post-content img{max-width:100%;display:block;margin-right:auto;margin-top:6px}.post-content .post-gallery{display:flex;flex-wrap:wrap;gap:6px}.post-content .post-gallery img{margin-right:auto;margin-top:auto;width:calc(50% - 3px)}.post-content h1{font-size:1.8rem;font-weight:600;margin-top:1.5em;margin-bottom:.8em;line-height:1.3;padding-bottom:.3em;border-bottom:1px solid #eaecef}.post-content h2{font-size:1.5rem;font-weight:600;margin-top:1.8em;margin-bottom:.8em;line-height:1.3;padding-bottom:.3em;border-bottom:1px solid #eaecef}.post-content h3{font-size:1.25rem;font-weight:600;margin-top:1.6em;margin-bottom:.6em;line-height:1.4}.post-content h4{font-size:1.1rem;font-weight:500;margin-top:1.4em;margin-bottom:.5em;line-height:1.4}.post-content table{width:100%;border-collapse:collapse;margin:1.5em 0;font-size:.95em;box-shadow:0 1px 3px rgba(0,0,0,.1)}.post-content th,.post-content td{border:1px solid #ddd;padding:10px 12px;text-align:left}.post-content th{background-color:#f2f2f2;font-weight:700}.post-content tr:nth-child(even){background-color:#f9f9f9}.post-content tr:hover{background-color:#f1f1f1}.related-content{border-width:3px;border-style:solid;border-color:#000;padding:0 10px;margin-bottom:50px;margin-top:100px}.related-content li{margin:5px 0}.taxonomy-term{font-size:3rem}.gallery-img{text-align:center}.gallery-img span{text-align:center}.gallery-img-desc{font-size:.8em;font-weight:800}#disqus_thread{position:relative}#disqus_thread:after{content:"";display:block;height:55px;width:100%;position:absolute;bottom:0;background:#fff}@media screen and (max-width:600px){.header-title,.header-subtitle,.header-items{}.posts-line{font-size:16px}.markdown-body{font-size:.95rem;line-height:1.65}.post-title{font-size:1.7rem}.post-content p{letter-spacing:normal;line-height:1.65}.post-content .post-gallery img{width:100%}.post-content h1{font-size:1.7rem}.post-content h2{font-size:1.4rem}.post-content h3{font-size:1.2rem}.post-content h4{font-size:1.05rem}}@media screen and (max-width:48em){.posts-category{display:none}}</style><style>.container,.container-fluid{margin-right:auto;margin-left:auto}.container-fluid{padding-right:2rem;padding-left:2rem}.row{box-sizing:border-box;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-flex:0;-ms-flex:0 1 auto;flex:initial;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;margin-right:-.5rem;margin-left:-.5rem}.row.reverse{-webkit-box-orient:horizontal;-webkit-box-direction:reverse;-ms-flex-direction:row-reverse;flex-direction:row-reverse}.col.reverse{-webkit-box-orient:vertical;-webkit-box-direction:reverse;-ms-flex-direction:column-reverse;flex-direction:column-reverse}.col-xs,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-offset-0,.col-xs-offset-1,.col-xs-offset-10,.col-xs-offset-11,.col-xs-offset-12,.col-xs-offset-2,.col-xs-offset-3,.col-xs-offset-4,.col-xs-offset-5,.col-xs-offset-6,.col-xs-offset-7,.col-xs-offset-8,.col-xs-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-xs{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-xs-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-xs-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-xs-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-xs-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-xs-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-xs-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-xs-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-xs-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-xs-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-xs-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-xs-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-xs-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-xs-offset-0{margin-left:0}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-11{margin-left:91.66666667%}.start-xs{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-xs{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-xs{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-xs{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-xs{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-xs{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-xs{-ms-flex-pack:distribute;justify-content:space-around}.between-xs{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-xs{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-xs{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}@media only screen and (min-width:48em){.container{width:49rem}.col-sm,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-offset-0,.col-sm-offset-1,.col-sm-offset-10,.col-sm-offset-11,.col-sm-offset-12,.col-sm-offset-2,.col-sm-offset-3,.col-sm-offset-4,.col-sm-offset-5,.col-sm-offset-6,.col-sm-offset-7,.col-sm-offset-8,.col-sm-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-sm{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-sm-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-sm-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-sm-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-sm-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-sm-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-sm-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-sm-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-sm-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-sm-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-sm-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-sm-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-sm-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-sm-offset-0{margin-left:0}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-11{margin-left:91.66666667%}.start-sm{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-sm{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-sm{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-sm{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-sm{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-sm{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-sm{-ms-flex-pack:distribute;justify-content:space-around}.between-sm{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-sm{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-sm{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:64em){.container{width:65rem}.col-md,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-offset-0,.col-md-offset-1,.col-md-offset-10,.col-md-offset-11,.col-md-offset-12,.col-md-offset-2,.col-md-offset-3,.col-md-offset-4,.col-md-offset-5,.col-md-offset-6,.col-md-offset-7,.col-md-offset-8,.col-md-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-md{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-md-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-md-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-md-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-md-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-md-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-md-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-md-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-md-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-md-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-md-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-md-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-md-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-md-offset-0{margin-left:0}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-3{margin-left:25%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-6{margin-left:50%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-9{margin-left:75%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-11{margin-left:91.66666667%}.start-md{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-md{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-md{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-md{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-md{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-md{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-md{-ms-flex-pack:distribute;justify-content:space-around}.between-md{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-md{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-md{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}@media only screen and (min-width:75em){.container{width:76rem}.col-lg,.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-offset-0,.col-lg-offset-1,.col-lg-offset-10,.col-lg-offset-11,.col-lg-offset-12,.col-lg-offset-2,.col-lg-offset-3,.col-lg-offset-4,.col-lg-offset-5,.col-lg-offset-6,.col-lg-offset-7,.col-lg-offset-8,.col-lg-offset-9{box-sizing:border-box;-webkit-box-flex:0;-ms-flex:0 0 auto;flex:none;padding-right:.5rem;padding-left:.5rem}.col-lg{-webkit-box-flex:1;-ms-flex-positive:1;flex-grow:1;-ms-flex-preferred-size:0;flex-basis:0;max-width:100%}.col-lg-1{-ms-flex-preferred-size:8.33333333%;flex-basis:8.33333333%;max-width:8.33333333%}.col-lg-2{-ms-flex-preferred-size:16.66666667%;flex-basis:16.66666667%;max-width:16.66666667%}.col-lg-3{-ms-flex-preferred-size:25%;flex-basis:25%;max-width:25%}.col-lg-4{-ms-flex-preferred-size:33.33333333%;flex-basis:33.33333333%;max-width:33.33333333%}.col-lg-5{-ms-flex-preferred-size:41.66666667%;flex-basis:41.66666667%;max-width:41.66666667%}.col-lg-6{-ms-flex-preferred-size:50%;flex-basis:50%;max-width:50%}.col-lg-7{-ms-flex-preferred-size:58.33333333%;flex-basis:58.33333333%;max-width:58.33333333%}.col-lg-8{-ms-flex-preferred-size:66.66666667%;flex-basis:66.66666667%;max-width:66.66666667%}.col-lg-9{-ms-flex-preferred-size:75%;flex-basis:75%;max-width:75%}.col-lg-10{-ms-flex-preferred-size:83.33333333%;flex-basis:83.33333333%;max-width:83.33333333%}.col-lg-11{-ms-flex-preferred-size:91.66666667%;flex-basis:91.66666667%;max-width:91.66666667%}.col-lg-12{-ms-flex-preferred-size:100%;flex-basis:100%;max-width:100%}.col-lg-offset-0{margin-left:0}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-11{margin-left:91.66666667%}.start-lg{-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;text-align:start}.center-lg{-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;text-align:center}.end-lg{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;text-align:end}.top-lg{-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start}.middle-lg{-webkit-box-align:center;-ms-flex-align:center;align-items:center}.bottom-lg{-webkit-box-align:end;-ms-flex-align:end;align-items:flex-end}.around-lg{-ms-flex-pack:distribute;justify-content:space-around}.between-lg{-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between}.first-lg{-webkit-box-ordinal-group:0;-ms-flex-order:-1;order:-1}.last-lg{-webkit-box-ordinal-group:2;-ms-flex-order:1;order:1}}</style><link href=/index.xml rel=alternate type=application/rss+xml title="Utop's Blog"><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Bungee+Shade&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@500;600;700&family=Source+Code+Pro:wght@600&display=swap" rel=stylesheet><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-3RHY4L44ZL"></script> <script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3RHY4L44ZL")</script></head><body><article class="post Chinese" id=article><div class=row><div class=col-xs-12><div class=site-header><header><div class=header-title><a href=/>FFUTOP</a></div><div class=header-subtitle></div></header><div class="row end-md header-items"><div class=header-item><a href=/posts/ target=_blank>Posts</a></div><div class=header-item><a href=/index.xml target=_blank>RSS</a></div><div class=header-item><a href=https://github.com/ffutop target=_blank>Github</a></div><div class=header-item><a href=https://ffkit.ffutop.com/author target=_blank>About</a></div></div><div class=row></div><div class=header-line></div></div><header class=post-header><h1 class=post-title>理解 Linux Kernel (9) - IO Multiplexing</h1><div class="row post-desc"><div class=col-xs-6><time class=post-date datetime="2019-03-05 00:00:00 UTC">05 Mar 2019</time></div><div class=col-xs-6><div class=post-author><a target=_blank href=https://www.ffutop.com/>@ffutop</a></div></div></div></header><div class="post-content markdown-body"><p><a href=./2019-01-15-understand-Kernel-8/>前一篇</a>已经对 Linux 内核网络相关的内容进行了基础性的介绍。数据从到达网卡，到最终被用户进程获取，最少经过了三个进程/硬中断的配合：网络中断负责将网络接收到的数据读取到内存并添加到 softnet_data 队列，并设置软中断通知内核进程 ksoftirqd；内核进程 ksoftirqd 被调度并处于运行状态，处理位于 softnet_data 中的 <code>struct sock</code> 对象，将其逐级从网络接口层逐级提升到网络层、传输层&mldr;最终添加到接收队列 <code>sk_receive_queue</code> 中；用户进程通过 <code>read</code>、<code>recv</code>、<code>recvfrom</code> 等命令检查并获取 <code>sk_receive_queue</code> 中的数据。</p><p>整个流程从概述上可以很轻松地配合进行网络数据交互，但如果要监控多个网络套接字呢？处理流程将变得复杂。我们无法预知哪个套接字能优先接收到数据。因此，最直接的办法就是轮询，在用户程序硬编码，通过设置超时时间的方式尝试获取数据。当然，这个效率就相当低下了。每次试探都需要触发系统调用（要知道这代价可是相当大的），另外超时时间的设置也是一个硬性的阻塞式消耗。</p><p>那么，有没有解决方案呢？当然有。通过用户程序硬编码式的轮询显然是陷入性能瓶颈的根源。因此内核主动提供了轮询式的系统调用（<code>select</code>, <code>poll</code>, <code>epoll</code>）。通过将轮询逻辑下沉到内核态，系统调用就只会有一次，而且超时时间的设置也显得统一。本篇就要就 <code>select</code> 和 <code>epoll</code> 两类系统调用的实现进行探究。</p><h2 id=select>SELECT</h2><p><code>select</code> 是一种比较古老的系统调用方式，存在着许多的调用限制。当然，相对的也就比较容易理解。</p><p><code>select</code> 系统调用最初的逻辑就是对超时时间的相关操作，完成从用户数据段到内核数据段的数据拷贝工作，而使用 <code>copy_from_user</code> 的目的，虽然看似比较晦涩，不如大家在用户程序中普通调用的memcpy，但究其原因，是为了处理MMU相关的问题。将内核复制的数据timeval做一定的取整操作（因为硬件中断的精度可能达不到timeval所描述的粒度，故根据HZ做取整，恰好为时钟中断周期的整数倍）。调用 <code>core_sys_select</code> 进行真正的轮询操作（当然，好像也算不上真正的逻辑，还有一层核心的调用呢）。结束后的操作当然是准备更新timeval。因为进行轮询的结果有两种，一种是因为超时而结束 <code>core_sys_select</code> 函数调用；另一种是得到了一个或多个准备就绪的数据，才结束调用并返回。显然，因为第二种结果而更新timeval有着一定的实际意义——到底等待了多久。不过这里需要注意的是，不是所有的Linux系统都支持对timeval做更新。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>asmlinkage <span style=color:#902000>long</span> <span style=color:#06287e>sys_select</span>(<span style=color:#902000>int</span> n, fd_set __user <span style=color:#666>*</span>inp, fd_set __user <span style=color:#666>*</span>outp,
</span></span><span style=display:flex><span>			fd_set __user <span style=color:#666>*</span>exp, <span style=color:#007020;font-weight:700>struct</span> timeval __user <span style=color:#666>*</span>tvp)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	s64 timeout <span style=color:#666>=</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> timeval tv;
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> ret;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 如果设置了超时时间 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (tvp) {
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>copy_from_user</span>(<span style=color:#666>&amp;</span>tv, tvp, <span style=color:#007020;font-weight:700>sizeof</span>(tv)))
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EFAULT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 计时器不能设置为负数 */</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (tv.tv_sec <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span> <span style=color:#666>||</span> tv.tv_usec <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>return</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#60a0b0;font-style:italic>/* Cast to u64 to make GCC stop complaining */</span>
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 对 timeout 做一定的处理，根据时钟周期对 usec 进行取整 */</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> ((u64)tv.tv_sec <span style=color:#666>&gt;=</span> (u64)MAX_INT64_SECONDS)
</span></span><span style=display:flex><span>			timeout <span style=color:#666>=</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>;	<span style=color:#60a0b0;font-style:italic>/* 无限等待 */</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>else</span> {
</span></span><span style=display:flex><span>			timeout <span style=color:#666>=</span> <span style=color:#06287e>DIV_ROUND_UP</span>(tv.tv_usec, USEC_PER_SEC<span style=color:#666>/</span>HZ);
</span></span><span style=display:flex><span>			timeout <span style=color:#666>+=</span> tv.tv_sec <span style=color:#666>*</span> HZ;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 核心的 select 实现逻辑 */</span>
</span></span><span style=display:flex><span>	ret <span style=color:#666>=</span> <span style=color:#06287e>core_sys_select</span>(n, inp, outp, exp, <span style=color:#666>&amp;</span>timeout);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 如果设置了超时时间 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (tvp) {
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>struct</span> timeval rtv;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (current<span style=color:#666>-&gt;</span>personality <span style=color:#666>&amp;</span> STICKY_TIMEOUTS)
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>goto</span> sticky;
</span></span><span style=display:flex><span>		rtv.tv_usec <span style=color:#666>=</span> <span style=color:#06287e>jiffies_to_usecs</span>(<span style=color:#06287e>do_div</span>((<span style=color:#666>*</span>(u64<span style=color:#666>*</span>)<span style=color:#666>&amp;</span>timeout), HZ));
</span></span><span style=display:flex><span>		rtv.tv_sec <span style=color:#666>=</span> timeout;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>timeval_compare</span>(<span style=color:#666>&amp;</span>rtv, <span style=color:#666>&amp;</span>tv) <span style=color:#666>&gt;=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>			rtv <span style=color:#666>=</span> tv;
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 内核数据-&gt;用户数据的拷贝，更新距离超时剩余的时间间隔 */</span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>copy_to_user</span>(tvp, <span style=color:#666>&amp;</span>rtv, <span style=color:#007020;font-weight:700>sizeof</span>(rtv))) {
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>sticky</span>:
</span></span><span style=display:flex><span>			<span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>             * 如果应用程序把timeval放在只读内存中，内核就无需特别的更新它
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>			 * If an application puts its timeval in read-only
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>			 * memory, we don&#39;t want the Linux-specific update to
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>			 * the timeval to cause a fault after the select has
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>			 * completed successfully. However, because we&#39;re not
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>			 * updating the timeval, we can&#39;t restart the system
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>			 * call.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>			 */</span>
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>if</span> (ret <span style=color:#666>==</span> <span style=color:#666>-</span>ERESTARTNOHAND)
</span></span><span style=display:flex><span>				ret <span style=color:#666>=</span> <span style=color:#666>-</span>EINTR;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>core_sys_select</code> 也没有太多核心操作，完全是在为三个位图——输入、输出、错误从用户数据段到内核数据段的拷贝工作，以及在结束 <code>do_select</code> 调用后的反向拷贝操作。不过，无论是 <code>sys_select</code> 还是 <code>core_sys_select</code> 都将各自需要完成的工作分割得非常清晰，一个完成timeval的处理工作，另一个完成位图的处理。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> * 内核数据-位图的准备，调用do_select完成核心的逻辑
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>int</span> <span style=color:#06287e>core_sys_select</span>(<span style=color:#902000>int</span> n, fd_set __user <span style=color:#666>*</span>inp, fd_set __user <span style=color:#666>*</span>outp,
</span></span><span style=display:flex><span>			   fd_set __user <span style=color:#666>*</span>exp, s64 <span style=color:#666>*</span>timeout)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	fd_set_bits fds;
</span></span><span style=display:flex><span>	<span style=color:#902000>void</span> <span style=color:#666>*</span>bits;
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> ret, max_fds;
</span></span><span style=display:flex><span>	<span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> size;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> fdtable <span style=color:#666>*</span>fdt;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 在栈中定义较小的数组，减少堆内存的占用，同时可以更快；
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * SELECT_STACK_ALLOC = 256
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     */</span>
</span></span><span style=display:flex><span>	<span style=color:#902000>long</span> stack_fds[SELECT_STACK_ALLOC<span style=color:#666>/</span><span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#902000>long</span>)];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	ret <span style=color:#666>=</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (n <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>goto</span> out_nofds;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* max_fds can increase, so grab it once to avoid race */</span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* max_fds 可能同时在增加，所以提前获取一份固定的拷贝避免竞争 */</span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>rcu_read_lock</span>();
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 获取当前任务的文件描述符表 */</span>
</span></span><span style=display:flex><span>	fdt <span style=color:#666>=</span> <span style=color:#06287e>files_fdtable</span>(current<span style=color:#666>-&gt;</span>files);
</span></span><span style=display:flex><span>	max_fds <span style=color:#666>=</span> fdt<span style=color:#666>-&gt;</span>max_fds;
</span></span><span style=display:flex><span>	<span style=color:#06287e>rcu_read_unlock</span>();
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (n <span style=color:#666>&gt;</span> max_fds)
</span></span><span style=display:flex><span>		n <span style=color:#666>=</span> max_fds;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * We need 6 bitmaps (in/out/ex for both incoming and outgoing),
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * since we used fdset we need to allocate memory in units of
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * long-words.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	size <span style=color:#666>=</span> <span style=color:#06287e>FDS_BYTES</span>(n);
</span></span><span style=display:flex><span>	bits <span style=color:#666>=</span> stack_fds;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (size <span style=color:#666>&gt;</span> <span style=color:#007020;font-weight:700>sizeof</span>(stack_fds) <span style=color:#666>/</span> <span style=color:#40a070>6</span>) {
</span></span><span style=display:flex><span>		<span style=color:#60a0b0;font-style:italic>/* Not enough space in on-stack array; must use kmalloc */</span>
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 栈数组大小不足；使用 kmalloc 获取新的空间 */</span>
</span></span><span style=display:flex><span>		ret <span style=color:#666>=</span> <span style=color:#666>-</span>ENOMEM;
</span></span><span style=display:flex><span>		bits <span style=color:#666>=</span> <span style=color:#06287e>kmalloc</span>(<span style=color:#40a070>6</span> <span style=color:#666>*</span> size, GFP_KERNEL);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>bits)
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>goto</span> out_nofds;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	fds.in      <span style=color:#666>=</span> bits;
</span></span><span style=display:flex><span>	fds.out     <span style=color:#666>=</span> bits <span style=color:#666>+</span>   size;
</span></span><span style=display:flex><span>	fds.ex      <span style=color:#666>=</span> bits <span style=color:#666>+</span> <span style=color:#40a070>2</span><span style=color:#666>*</span>size;
</span></span><span style=display:flex><span>	fds.res_in  <span style=color:#666>=</span> bits <span style=color:#666>+</span> <span style=color:#40a070>3</span><span style=color:#666>*</span>size;
</span></span><span style=display:flex><span>	fds.res_out <span style=color:#666>=</span> bits <span style=color:#666>+</span> <span style=color:#40a070>4</span><span style=color:#666>*</span>size;
</span></span><span style=display:flex><span>	fds.res_ex  <span style=color:#666>=</span> bits <span style=color:#666>+</span> <span style=color:#40a070>5</span><span style=color:#666>*</span>size;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 用户数据段的数据 inp、outp、exp 往内核数据段 fds.xxx 拷贝 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> ((ret <span style=color:#666>=</span> <span style=color:#06287e>get_fd_set</span>(n, inp, fds.in)) <span style=color:#666>||</span>
</span></span><span style=display:flex><span>	    (ret <span style=color:#666>=</span> <span style=color:#06287e>get_fd_set</span>(n, outp, fds.out)) <span style=color:#666>||</span>
</span></span><span style=display:flex><span>	    (ret <span style=color:#666>=</span> <span style=color:#06287e>get_fd_set</span>(n, exp, fds.ex)))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>goto</span> out;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* fds.res_xxx 作为 do_select 的执行结果，预置为0，表示每一位相应的fd都未准备就绪 */</span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>zero_fd_set</span>(n, fds.res_in);
</span></span><span style=display:flex><span>	<span style=color:#06287e>zero_fd_set</span>(n, fds.res_out);
</span></span><span style=display:flex><span>	<span style=color:#06287e>zero_fd_set</span>(n, fds.res_ex);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 交由 do_select 完成真正核心的操作 */</span>
</span></span><span style=display:flex><span>	ret <span style=color:#666>=</span> <span style=color:#06287e>do_select</span>(n, <span style=color:#666>&amp;</span>fds, timeout);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (ret <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>goto</span> out;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>ret) {
</span></span><span style=display:flex><span>		ret <span style=color:#666>=</span> <span style=color:#666>-</span>ERESTARTNOHAND;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>signal_pending</span>(current))
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>goto</span> out;
</span></span><span style=display:flex><span>		ret <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 将结果集拷贝回用户数据段的 inp、outp、exp 中 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>set_fd_set</span>(n, inp, fds.res_in) <span style=color:#666>||</span>
</span></span><span style=display:flex><span>	    <span style=color:#06287e>set_fd_set</span>(n, outp, fds.res_out) <span style=color:#666>||</span>
</span></span><span style=display:flex><span>	    <span style=color:#06287e>set_fd_set</span>(n, exp, fds.res_ex))
</span></span><span style=display:flex><span>		ret <span style=color:#666>=</span> <span style=color:#666>-</span>EFAULT;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>out</span>:
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (bits <span style=color:#666>!=</span> stack_fds)
</span></span><span style=display:flex><span>		<span style=color:#06287e>kfree</span>(bits);
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>out_nofds</span>:
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>终于是核心的逻辑了，逐一地将当前任务挂到相应文件的等待队列上，并等待调用 <code>poll</code> 函数被唤醒</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#902000>int</span> <span style=color:#06287e>do_select</span>(<span style=color:#902000>int</span> n, fd_set_bits <span style=color:#666>*</span>fds, s64 <span style=color:#666>*</span>timeout)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> poll_wqueues table;
</span></span><span style=display:flex><span>	poll_table <span style=color:#666>*</span>wait;
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> retval, i;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>rcu_read_lock</span>();
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 确认fds.xxx所需轮询的fd全部全部处于打开状态，同时返回最大的fd */</span>
</span></span><span style=display:flex><span>	retval <span style=color:#666>=</span> <span style=color:#06287e>max_select_fd</span>(n, fds);
</span></span><span style=display:flex><span>	<span style=color:#06287e>rcu_read_unlock</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (retval <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> retval;
</span></span><span style=display:flex><span>	n <span style=color:#666>=</span> retval;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 把当前任务放入自己的等待队列中 */</span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>poll_initwait</span>(<span style=color:#666>&amp;</span>table);
</span></span><span style=display:flex><span>	wait <span style=color:#666>=</span> <span style=color:#666>&amp;</span>table.pt;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 如果超时时间为0，即无需等待 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!*</span>timeout)
</span></span><span style=display:flex><span>		wait <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>	retval <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 无限循环 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>for</span> (;;) {
</span></span><span style=display:flex><span>		<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span> <span style=color:#666>*</span>rinp, <span style=color:#666>*</span>routp, <span style=color:#666>*</span>rexp, <span style=color:#666>*</span>inp, <span style=color:#666>*</span>outp, <span style=color:#666>*</span>exp;
</span></span><span style=display:flex><span>		<span style=color:#902000>long</span> __timeout;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#06287e>set_current_state</span>(TASK_INTERRUPTIBLE);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		inp <span style=color:#666>=</span> fds<span style=color:#666>-&gt;</span>in; outp <span style=color:#666>=</span> fds<span style=color:#666>-&gt;</span>out; exp <span style=color:#666>=</span> fds<span style=color:#666>-&gt;</span>ex;
</span></span><span style=display:flex><span>		rinp <span style=color:#666>=</span> fds<span style=color:#666>-&gt;</span>res_in; routp <span style=color:#666>=</span> fds<span style=color:#666>-&gt;</span>res_out; rexp <span style=color:#666>=</span> fds<span style=color:#666>-&gt;</span>res_ex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>for</span> (i <span style=color:#666>=</span> <span style=color:#40a070>0</span>; i <span style=color:#666>&lt;</span> n; <span style=color:#666>++</span>rinp, <span style=color:#666>++</span>routp, <span style=color:#666>++</span>rexp) {
</span></span><span style=display:flex><span>			<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span> in, out, ex, all_bits, bit <span style=color:#666>=</span> <span style=color:#40a070>1</span>, mask, j;
</span></span><span style=display:flex><span>			<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span> res_in <span style=color:#666>=</span> <span style=color:#40a070>0</span>, res_out <span style=color:#666>=</span> <span style=color:#40a070>0</span>, res_ex <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>const</span> <span style=color:#007020;font-weight:700>struct</span> file_operations <span style=color:#666>*</span>f_op <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>struct</span> file <span style=color:#666>*</span>file <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			in <span style=color:#666>=</span> <span style=color:#666>*</span>inp<span style=color:#666>++</span>; out <span style=color:#666>=</span> <span style=color:#666>*</span>outp<span style=color:#666>++</span>; ex <span style=color:#666>=</span> <span style=color:#666>*</span>exp<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>			all_bits <span style=color:#666>=</span> in <span style=color:#666>|</span> out <span style=color:#666>|</span> ex;
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>if</span> (all_bits <span style=color:#666>==</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>				i <span style=color:#666>+=</span> __NFDBITS;
</span></span><span style=display:flex><span>				<span style=color:#007020;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#60a0b0;font-style:italic>/* 对 unsigned long 的每一位进行确认 */</span>
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>for</span> (j <span style=color:#666>=</span> <span style=color:#40a070>0</span>; j <span style=color:#666>&lt;</span> __NFDBITS; <span style=color:#666>++</span>j, <span style=color:#666>++</span>i, bit <span style=color:#666>&lt;&lt;=</span> <span style=color:#40a070>1</span>) {
</span></span><span style=display:flex><span>				<span style=color:#902000>int</span> fput_needed;
</span></span><span style=display:flex><span>                <span style=color:#60a0b0;font-style:italic>/* 超过需检测的最大的文件描述符 */</span>
</span></span><span style=display:flex><span>				<span style=color:#007020;font-weight:700>if</span> (i <span style=color:#666>&gt;=</span> n)
</span></span><span style=display:flex><span>					<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>                <span style=color:#60a0b0;font-style:italic>/* 该 fd 无需检测，直接下一个 */</span>
</span></span><span style=display:flex><span>				<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(bit <span style=color:#666>&amp;</span> all_bits))
</span></span><span style=display:flex><span>					<span style=color:#007020;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>                <span style=color:#60a0b0;font-style:italic>/* 获取相应的文件实例 */</span>
</span></span><span style=display:flex><span>				file <span style=color:#666>=</span> <span style=color:#06287e>fget_light</span>(i, <span style=color:#666>&amp;</span>fput_needed);
</span></span><span style=display:flex><span>				<span style=color:#007020;font-weight:700>if</span> (file) {
</span></span><span style=display:flex><span>					f_op <span style=color:#666>=</span> file<span style=color:#666>-&gt;</span>f_op;
</span></span><span style=display:flex><span>					mask <span style=color:#666>=</span> DEFAULT_POLLMASK;
</span></span><span style=display:flex><span>                    <span style=color:#60a0b0;font-style:italic>/* 对于套接字，调用的是sock_poll，在poll成功时将唤醒wait队列的任务（即把当前任务唤醒）*/</span>
</span></span><span style=display:flex><span>					<span style=color:#007020;font-weight:700>if</span> (f_op <span style=color:#666>&amp;&amp;</span> f_op<span style=color:#666>-&gt;</span>poll)
</span></span><span style=display:flex><span>						mask <span style=color:#666>=</span> (<span style=color:#666>*</span>f_op<span style=color:#666>-&gt;</span>poll)(file, retval <span style=color:#666>?</span> <span style=color:#007020>NULL</span> <span style=color:#666>:</span> wait);
</span></span><span style=display:flex><span>					<span style=color:#06287e>fput_light</span>(file, fput_needed);
</span></span><span style=display:flex><span>					<span style=color:#007020;font-weight:700>if</span> ((mask <span style=color:#666>&amp;</span> POLLIN_SET) <span style=color:#666>&amp;&amp;</span> (in <span style=color:#666>&amp;</span> bit)) {
</span></span><span style=display:flex><span>						res_in <span style=color:#666>|=</span> bit;
</span></span><span style=display:flex><span>						retval<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>					<span style=color:#007020;font-weight:700>if</span> ((mask <span style=color:#666>&amp;</span> POLLOUT_SET) <span style=color:#666>&amp;&amp;</span> (out <span style=color:#666>&amp;</span> bit)) {
</span></span><span style=display:flex><span>						res_out <span style=color:#666>|=</span> bit;
</span></span><span style=display:flex><span>						retval<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>					<span style=color:#007020;font-weight:700>if</span> ((mask <span style=color:#666>&amp;</span> POLLEX_SET) <span style=color:#666>&amp;&amp;</span> (ex <span style=color:#666>&amp;</span> bit)) {
</span></span><span style=display:flex><span>						res_ex <span style=color:#666>|=</span> bit;
</span></span><span style=display:flex><span>						retval<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>					}
</span></span><span style=display:flex><span>				}
</span></span><span style=display:flex><span>                <span style=color:#60a0b0;font-style:italic>/* 主动让出CPU片，等待重新调度（提前设置了最高优先级PREEMPT_ACTIVE）*/</span>
</span></span><span style=display:flex><span>				<span style=color:#06287e>cond_resched</span>();
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>if</span> (res_in)
</span></span><span style=display:flex><span>				<span style=color:#666>*</span>rinp <span style=color:#666>=</span> res_in;
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>if</span> (res_out)
</span></span><span style=display:flex><span>				<span style=color:#666>*</span>routp <span style=color:#666>=</span> res_out;
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>if</span> (res_ex)
</span></span><span style=display:flex><span>				<span style=color:#666>*</span>rexp <span style=color:#666>=</span> res_ex;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		wait <span style=color:#666>=</span> <span style=color:#007020>NULL</span>;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (retval <span style=color:#666>||</span> <span style=color:#666>!*</span>timeout <span style=color:#666>||</span> <span style=color:#06287e>signal_pending</span>(current))
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span>(table.error) {
</span></span><span style=display:flex><span>			retval <span style=color:#666>=</span> table.error;
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>*</span>timeout <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span>) {
</span></span><span style=display:flex><span>			<span style=color:#60a0b0;font-style:italic>/* Wait indefinitely */</span>
</span></span><span style=display:flex><span>			__timeout <span style=color:#666>=</span> MAX_SCHEDULE_TIMEOUT;
</span></span><span style=display:flex><span>		} <span style=color:#007020;font-weight:700>else</span> <span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>unlikely</span>(<span style=color:#666>*</span>timeout <span style=color:#666>&gt;=</span> (s64)MAX_SCHEDULE_TIMEOUT <span style=color:#666>-</span> <span style=color:#40a070>1</span>)) {
</span></span><span style=display:flex><span>			<span style=color:#60a0b0;font-style:italic>/* Wait for longer than MAX_SCHEDULE_TIMEOUT. Do it in a loop */</span>
</span></span><span style=display:flex><span>			__timeout <span style=color:#666>=</span> MAX_SCHEDULE_TIMEOUT <span style=color:#666>-</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>			<span style=color:#666>*</span>timeout <span style=color:#666>-=</span> __timeout;
</span></span><span style=display:flex><span>		} <span style=color:#007020;font-weight:700>else</span> {
</span></span><span style=display:flex><span>			__timeout <span style=color:#666>=</span> <span style=color:#666>*</span>timeout;
</span></span><span style=display:flex><span>			<span style=color:#666>*</span>timeout <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 进入延时唤醒状态，待定预定的超时时间 */</span>
</span></span><span style=display:flex><span>		__timeout <span style=color:#666>=</span> <span style=color:#06287e>schedule_timeout</span>(__timeout);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>*</span>timeout <span style=color:#666>&gt;=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>			<span style=color:#666>*</span>timeout <span style=color:#666>+=</span> __timeout;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#06287e>__set_current_state</span>(TASK_RUNNING);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>poll_freewait</span>(<span style=color:#666>&amp;</span>table);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> retval;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>总结来看，<code>select</code> 完全能够支持IO多路复用。至少比用户程序自行实现轮询优秀得多。但是，也存在着一些明显的缺陷：</p><ol><li>支持的文件描述符存在上限，默认是1024。</li><li>每次陷入内核态 <code>select</code> 函数之后，都需要按位遍历所有的文件描述符（无论该fd是否存在），max(fd)越大，开销越大。</li><li>每次调用 <code>select</code> 都需要将fd集合从用户态复制到内核态，max(fd)越大，开销越大。</li></ol><h2 id=epoll>EPOLL</h2><p>简单地描述过 <code>select</code> 系统调用之后，我们着重来聊一聊 <code>epoll</code> 的实现。毕竟 <code>select</code> 和 <code>poll</code> 的复杂度是 $O(N)$，而 <code>epoll</code> 只是 $O(\log{N})$ （当然，这里对时间复杂度的比较维度不同，稍候细讲）。<code>epoll</code> 区别于传统I/O复用模型的最大特色在于：它将创建并维护一个 <code>eventpoll</code> 实例，并通过注册请 <code>epoll</code> 对新的文件描述符进行监听，这意味着数据从用户数据区到内核数据区的拷贝只有一次；相对的，传统方式在每次轮询时，都需要全量地将数据从用户数据区拷贝到内核数据区。</p><h3 id=epoll_create><code>epoll_create</code></h3><p><code>epoll_create</code> 负责创建一个新的 <code>eventpoll</code> 实例。这里的size并没有实际意义（由于历史原因而存在），传入的参数将被忽略。看源码总是件有意思的事，这个size被描述成了检查精神健全的标志&mldr;</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>asmlinkage <span style=color:#902000>long</span> <span style=color:#06287e>sys_epoll_create</span>(<span style=color:#902000>int</span> size)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> error, fd <span style=color:#666>=</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> eventpoll <span style=color:#666>*</span>ep;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> inode <span style=color:#666>*</span>inode;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> file <span style=color:#666>*</span>file;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>DNPRINTK</span>(<span style=color:#40a070>3</span>, (KERN_INFO <span style=color:#4070a0>&#34;[%p] eventpoll: sys_epoll_create(%d)</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>,
</span></span><span style=display:flex><span>		     current, size));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 精神健全检测(size)；同时建立内部数据结构 struct eventpoll
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	error <span style=color:#666>=</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (size <span style=color:#666>&lt;=</span> <span style=color:#40a070>0</span> <span style=color:#666>||</span> (error <span style=color:#666>=</span> <span style=color:#06287e>ep_alloc</span>(<span style=color:#666>&amp;</span>ep)) <span style=color:#666>!=</span> <span style=color:#40a070>0</span>)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>goto</span> error_return;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 创建一个新的文件描述符，文件数据结构和i节点
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	error <span style=color:#666>=</span> <span style=color:#06287e>anon_inode_getfd</span>(<span style=color:#666>&amp;</span>fd, <span style=color:#666>&amp;</span>inode, <span style=color:#666>&amp;</span>file, <span style=color:#4070a0>&#34;[eventpoll]&#34;</span>,
</span></span><span style=display:flex><span>				 <span style=color:#666>&amp;</span>eventpoll_fops, ep);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (error)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>goto</span> error_free;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>DNPRINTK</span>(<span style=color:#40a070>3</span>, (KERN_INFO <span style=color:#4070a0>&#34;[%p] eventpoll: sys_epoll_create(%d) = %d</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>,
</span></span><span style=display:flex><span>		     current, size, fd));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> fd;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>error_free</span>:
</span></span><span style=display:flex><span>	<span style=color:#06287e>ep_free</span>(ep);
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>error_return</span>:
</span></span><span style=display:flex><span>	<span style=color:#06287e>DNPRINTK</span>(<span style=color:#40a070>3</span>, (KERN_INFO <span style=color:#4070a0>&#34;[%p] eventpoll: sys_epoll_create(%d) = %d</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>,
</span></span><span style=display:flex><span>		     current, size, error));
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> error;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=https://img.ffutop.com/223EAB4E-D126-4CC1-A9B4-254873DA4676.jpg alt="Epoll Create Mode"></p><h3 id=epoll_ctl><code>epoll_ctl</code></h3><p><code>epoll_ctl</code> 顾名思义——<code>epoll</code>控制器，用于增加、修改、删除监听的事件。这里 <code>epfd</code> 用于找到 <code>eventpoll</code> 实例，<code>fd</code> 表示需要监听的文件描述符，<code>op</code> 区分增删改，<code>event</code> 表示监听的具体事件描述。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>asmlinkage <span style=color:#902000>long</span> <span style=color:#06287e>sys_epoll_ctl</span>(<span style=color:#902000>int</span> epfd, <span style=color:#902000>int</span> op, <span style=color:#902000>int</span> fd,
</span></span><span style=display:flex><span>			      <span style=color:#007020;font-weight:700>struct</span> epoll_event __user <span style=color:#666>*</span>event)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> error;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> file <span style=color:#666>*</span>file, <span style=color:#666>*</span>tfile;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> eventpoll <span style=color:#666>*</span>ep;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> epitem <span style=color:#666>*</span>epi;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> epoll_event epds;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>DNPRINTK</span>(<span style=color:#40a070>3</span>, (KERN_INFO <span style=color:#4070a0>&#34;[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p)</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>,
</span></span><span style=display:flex><span>		     current, epfd, op, fd, event));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	error <span style=color:#666>=</span> <span style=color:#666>-</span>EFAULT;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 如果是增改操作，需要把事件描述拷贝到内核数据区; 删除操作不需要 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>ep_op_has_event</span>(op) <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>	    <span style=color:#06287e>copy_from_user</span>(<span style=color:#666>&amp;</span>epds, event, <span style=color:#007020;font-weight:700>sizeof</span>(<span style=color:#007020;font-weight:700>struct</span> epoll_event)))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>goto</span> error_return;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* Get the &#34;struct file *&#34; for the eventpoll file */</span>
</span></span><span style=display:flex><span>	error <span style=color:#666>=</span> <span style=color:#666>-</span>EBADF;
</span></span><span style=display:flex><span>	file <span style=color:#666>=</span> <span style=color:#06287e>fget</span>(epfd);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>file)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>goto</span> error_return;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* Get the &#34;struct file *&#34; for the target file */</span>
</span></span><span style=display:flex><span>	tfile <span style=color:#666>=</span> <span style=color:#06287e>fget</span>(fd);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>tfile)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>goto</span> error_fput;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 需要监听的文件描述符必须支持文件操作 poll */</span>
</span></span><span style=display:flex><span>	error <span style=color:#666>=</span> <span style=color:#666>-</span>EPERM;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>tfile<span style=color:#666>-&gt;</span>f_op <span style=color:#666>||</span> <span style=color:#666>!</span>tfile<span style=color:#666>-&gt;</span>f_op<span style=color:#666>-&gt;</span>poll)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>goto</span> error_tgt_fput;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 需要确保不能把epfd作为被监听的fd加入 */</span>
</span></span><span style=display:flex><span>	error <span style=color:#666>=</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (file <span style=color:#666>==</span> tfile <span style=color:#666>||</span> <span style=color:#666>!</span><span style=color:#06287e>is_file_epoll</span>(file))
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>goto</span> error_tgt_fput;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 这里的文件描述符一定是指eventpoll实例对应的文件描述符
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 因此直接从中拿私有数据--预定义的*eventpoll
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     */</span>
</span></span><span style=display:flex><span>	ep <span style=color:#666>=</span> file<span style=color:#666>-&gt;</span>private_data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>mutex_lock</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>mtx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 从RB树中查找已经维护起来的监听事件
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 当然，必须先把这个RB树结构锁定，防止查找时结构改变
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	epi <span style=color:#666>=</span> <span style=color:#06287e>ep_find</span>(ep, tfile, fd);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	error <span style=color:#666>=</span> <span style=color:#666>-</span>EINVAL;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>switch</span> (op) {
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>EPOLL_CTL_ADD</span>:     <span style=color:#60a0b0;font-style:italic>// 新增监听
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>epi) {
</span></span><span style=display:flex><span>			epds.events <span style=color:#666>|=</span> POLLERR <span style=color:#666>|</span> POLLHUP;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			error <span style=color:#666>=</span> <span style=color:#06287e>ep_insert</span>(ep, <span style=color:#666>&amp;</span>epds, tfile, fd);
</span></span><span style=display:flex><span>		} <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>			error <span style=color:#666>=</span> <span style=color:#666>-</span>EEXIST;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>EPOLL_CTL_DEL</span>:     <span style=color:#60a0b0;font-style:italic>// 删除监听
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#007020;font-weight:700>if</span> (epi)
</span></span><span style=display:flex><span>			error <span style=color:#666>=</span> <span style=color:#06287e>ep_remove</span>(ep, epi);
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>			error <span style=color:#666>=</span> <span style=color:#666>-</span>ENOENT;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>case</span> <span style=color:#002070;font-weight:700>EPOLL_CTL_MOD</span>:     <span style=color:#60a0b0;font-style:italic>// 修改监听
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>		<span style=color:#007020;font-weight:700>if</span> (epi) {
</span></span><span style=display:flex><span>			epds.events <span style=color:#666>|=</span> POLLERR <span style=color:#666>|</span> POLLHUP;
</span></span><span style=display:flex><span>			error <span style=color:#666>=</span> <span style=color:#06287e>ep_modify</span>(ep, epi, <span style=color:#666>&amp;</span>epds);
</span></span><span style=display:flex><span>		} <span style=color:#007020;font-weight:700>else</span>
</span></span><span style=display:flex><span>			error <span style=color:#666>=</span> <span style=color:#666>-</span>ENOENT;
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#06287e>mutex_unlock</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>mtx);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>error_tgt_fput</span>:
</span></span><span style=display:flex><span>	<span style=color:#06287e>fput</span>(tfile);
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>error_fput</span>:
</span></span><span style=display:flex><span>	<span style=color:#06287e>fput</span>(file);
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>error_return</span>:
</span></span><span style=display:flex><span>	<span style=color:#06287e>DNPRINTK</span>(<span style=color:#40a070>3</span>, (KERN_INFO <span style=color:#4070a0>&#34;[%p] eventpoll: sys_epoll_ctl(%d, %d, %d, %p) = %d</span><span style=color:#4070a0;font-weight:700>\n</span><span style=color:#4070a0>&#34;</span>,
</span></span><span style=display:flex><span>		     current, epfd, op, fd, event, error));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> error;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里的核心操作，就是往 <code>eventpoll</code> 实例中增删改监听的事件。以 <code>ep_insert</code> 为例，先看看怎么新增监听。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* 实例化 epitem */</span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>(epi <span style=color:#666>=</span> <span style=color:#06287e>kmem_cache_alloc</span>(epi_cache, GFP_KERNEL)))
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>goto</span> error_return;
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* 对 epitem 实例进行初始化数据 */</span>
</span></span><span style=display:flex><span><span style=color:#06287e>ep_rb_initnode</span>(<span style=color:#666>&amp;</span>epi<span style=color:#666>-&gt;</span>rbn);
</span></span><span style=display:flex><span><span style=color:#06287e>INIT_LIST_HEAD</span>(<span style=color:#666>&amp;</span>epi<span style=color:#666>-&gt;</span>rdllink);
</span></span><span style=display:flex><span><span style=color:#06287e>INIT_LIST_HEAD</span>(<span style=color:#666>&amp;</span>epi<span style=color:#666>-&gt;</span>fllink);
</span></span><span style=display:flex><span><span style=color:#06287e>INIT_LIST_HEAD</span>(<span style=color:#666>&amp;</span>epi<span style=color:#666>-&gt;</span>pwqlist);
</span></span><span style=display:flex><span>epi<span style=color:#666>-&gt;</span>ep <span style=color:#666>=</span> ep;
</span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* 构建struct epoll_filefd，作为rb_tree比较不同的key */</span>
</span></span><span style=display:flex><span><span style=color:#06287e>ep_set_ffd</span>(<span style=color:#666>&amp;</span>epi<span style=color:#666>-&gt;</span>ffd, tfile, fd);
</span></span><span style=display:flex><span>epi<span style=color:#666>-&gt;</span>event <span style=color:#666>=</span> <span style=color:#666>*</span>event;
</span></span><span style=display:flex><span>epi<span style=color:#666>-&gt;</span>nwait <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>epi<span style=color:#666>-&gt;</span>next <span style=color:#666>=</span> EP_UNACTIVE_PTR;
</span></span></code></pre></div><p>接下来要接触的就是一段比较烧脑的逻辑。</p><p><code>poll_table</code> 是在 VFS 实现中相当重要的一个数据结构，用来与<code>poll</code>配合（这里的<code>poll</code>是指文件操作中的，而不是<code>poll()</code>系统调用）</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#007020;font-weight:700>struct</span> poll_table_struct {
</span></span><span style=display:flex><span>	poll_queue_proc _qproc;
</span></span><span style=display:flex><span>} poll_table;
</span></span></code></pre></div><p>其中<code>poll_queue_proc</code>是一个函数指针</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>typedef</span> <span style=color:#06287e>void</span> (<span style=color:#666>*</span>poll_queue_proc)(<span style=color:#007020;font-weight:700>struct</span> file <span style=color:#666>*</span>, <span style=color:#902000>wait_queue_head_t</span> <span style=color:#666>*</span>, <span style=color:#007020;font-weight:700>struct</span> poll_table_struct <span style=color:#666>*</span>);
</span></span></code></pre></div><p>为了让 <code>epitem</code> 更方便地追踪 <code>poll_queue_proc</code>，<code>epoll_ctl</code> 中使用了一个 <code>ep_pqueue</code> 的数据结构来包装 <code>poll_table</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>/* 使用 queue 回调函数初始化 poll table */</span>
</span></span><span style=display:flex><span>epq.epi <span style=color:#666>=</span> epi;
</span></span><span style=display:flex><span><span style=color:#06287e>init_poll_funcptr</span>(<span style=color:#666>&amp;</span>epq.pt, ep_ptable_queue_proc);
</span></span></code></pre></div><p><img src=https://img.ffutop.com/9EFE10FC-31F9-4CC1-8E03-6255DA94EF26.jpg alt></p><p>之后就是把这个 <code>poll_table</code> 作为钩子方法挂载到被监控的文件上</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>revents <span style=color:#666>=</span> tfile<span style=color:#666>-&gt;</span>f_op<span style=color:#666>-&gt;</span><span style=color:#06287e>poll</span>(tfile, <span style=color:#666>&amp;</span>epq.pt);
</span></span></code></pre></div><p>这里以 <code>tcp_poll</code> 为例，先看看这段逻辑怎么实现的。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> <span style=color:#06287e>sock_poll</span>(<span style=color:#007020;font-weight:700>struct</span> file <span style=color:#666>*</span>file, poll_table <span style=color:#666>*</span>wait)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>struct</span> socket <span style=color:#666>*</span>sock;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 获取 struct sock 内核套接字数据结构 */</span>
</span></span><span style=display:flex><span>    sock <span style=color:#666>=</span> file<span style=color:#666>-&gt;</span>private_data;
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> sock<span style=color:#666>-&gt;</span>ops<span style=color:#666>-&gt;</span><span style=color:#06287e>poll</span>(file, sock, wait);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> <span style=color:#06287e>tcp_poll</span>(<span style=color:#007020;font-weight:700>struct</span> file <span style=color:#666>*</span>file, <span style=color:#007020;font-weight:700>struct</span> socket <span style=color:#666>*</span>sock, poll_table <span style=color:#666>*</span>wait)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>unsigned</span> <span style=color:#902000>int</span> mask;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> sock <span style=color:#666>*</span>sk <span style=color:#666>=</span> sock<span style=color:#666>-&gt;</span>sk;
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> tcp_sock <span style=color:#666>*</span>tp <span style=color:#666>=</span> <span style=color:#06287e>tcp_sk</span>(sk);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 这里将调用 poll_table *wait 维护的回调函数
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 将持有 eventpoll 实例的进程注册到 sk 的等待队列中
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     */</span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>poll_wait</span>(file, sk<span style=color:#666>-&gt;</span>sk_sleep, wait);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (sk<span style=color:#666>-&gt;</span>sk_state <span style=color:#666>==</span> TCP_LISTEN)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>return</span> <span style=color:#06287e>inet_csk_listen_poll</span>(sk);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 这里省略了部分逻辑，主要是负责处理 struct sock 接收到的事件
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 处理成 mask 并返回
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     */</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>return</span> mask;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#007020;font-weight:700>inline</span> <span style=color:#902000>void</span> <span style=color:#06287e>poll_wait</span>(<span style=color:#007020;font-weight:700>struct</span> file <span style=color:#666>*</span> filp, <span style=color:#902000>wait_queue_head_t</span> <span style=color:#666>*</span> wait_address, poll_table <span style=color:#666>*</span>p)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#007020;font-weight:700>if</span> (p <span style=color:#666>&amp;&amp;</span> wait_address)
</span></span><span style=display:flex><span>        p<span style=color:#666>-&gt;</span><span style=color:#06287e>qproc</span>(filp, wait_address, p);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>再来看看epoll定义的回调函数的实现。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>void</span> <span style=color:#06287e>ep_ptable_queue_proc</span>(<span style=color:#007020;font-weight:700>struct</span> file <span style=color:#666>*</span>file, <span style=color:#902000>wait_queue_head_t</span> <span style=color:#666>*</span>whead,
</span></span><span style=display:flex><span>				 poll_table <span style=color:#666>*</span>pt)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> epitem <span style=color:#666>*</span>epi <span style=color:#666>=</span> <span style=color:#06287e>ep_item_from_epqueue</span>(pt);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> eppoll_entry <span style=color:#666>*</span>pwq;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (epi<span style=color:#666>-&gt;</span>nwait <span style=color:#666>&gt;=</span> <span style=color:#40a070>0</span> <span style=color:#666>&amp;&amp;</span> (pwq <span style=color:#666>=</span> <span style=color:#06287e>kmem_cache_alloc</span>(pwq_cache, GFP_KERNEL))) {
</span></span><span style=display:flex><span>		<span style=color:#06287e>init_waitqueue_func_entry</span>(<span style=color:#666>&amp;</span>pwq<span style=color:#666>-&gt;</span>wait, ep_poll_callback);
</span></span><span style=display:flex><span>		pwq<span style=color:#666>-&gt;</span>whead <span style=color:#666>=</span> whead;
</span></span><span style=display:flex><span>		pwq<span style=color:#666>-&gt;</span>base <span style=color:#666>=</span> epi;
</span></span><span style=display:flex><span>        <span style=color:#60a0b0;font-style:italic>/* 添加到 struct sock 等待队列队首 */</span>
</span></span><span style=display:flex><span>		<span style=color:#06287e>add_wait_queue</span>(whead, <span style=color:#666>&amp;</span>pwq<span style=color:#666>-&gt;</span>wait);
</span></span><span style=display:flex><span>		<span style=color:#06287e>list_add_tail</span>(<span style=color:#666>&amp;</span>pwq<span style=color:#666>-&gt;</span>llink, <span style=color:#666>&amp;</span>epi<span style=color:#666>-&gt;</span>pwqlist);
</span></span><span style=display:flex><span>		epi<span style=color:#666>-&gt;</span>nwait<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>	} <span style=color:#007020;font-weight:700>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#60a0b0;font-style:italic>/* We have to signal that an error occurred */</span>
</span></span><span style=display:flex><span>		epi<span style=color:#666>-&gt;</span>nwait <span style=color:#666>=</span> <span style=color:#666>-</span><span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>到此为止，<code>ep_insert</code> 核心的逻辑已经介绍完毕。主要就是将当前的 <code>eventpoll</code> 实例注册到监听目标（文件描述符）的等待队列上，并注册<code>ep_poll_callback</code>作为回调函数。回调函数实现是怎样呢？</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>int</span> <span style=color:#06287e>ep_poll_callback</span>(<span style=color:#902000>wait_queue_t</span> <span style=color:#666>*</span>wait, <span style=color:#902000>unsigned</span> mode, <span style=color:#902000>int</span> sync, <span style=color:#902000>void</span> <span style=color:#666>*</span>key)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> pwake <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span> flags;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 获取 wait 结构维护的 epitem 实例 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> epitem <span style=color:#666>*</span>epi <span style=color:#666>=</span> <span style=color:#06287e>ep_item_from_wait</span>(wait);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>struct</span> eventpoll <span style=color:#666>*</span>ep <span style=color:#666>=</span> epi<span style=color:#666>-&gt;</span>ep;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>// ... code omitted...
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic></span>    <span style=color:#60a0b0;font-style:italic>/* 
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 把当前的 epitem 实例添加到 eventpoll 实例的就绪队列中 
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 这是显然的，毕竟此回调函数只有在fd准备就绪后被回调
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     */</span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>list_add_tail</span>(<span style=color:#666>&amp;</span>epi<span style=color:#666>-&gt;</span>rdllink, <span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>rdllist);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>is_linked</span>:
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 如果 wait 结构维护的进程处于Sleeping状态，则将其唤醒并加入任务就绪队列 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>waitqueue_active</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>wq))
</span></span><span style=display:flex><span>		<span style=color:#06287e>__wake_up_locked</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>wq, TASK_UNINTERRUPTIBLE <span style=color:#666>|</span>
</span></span><span style=display:flex><span>				 TASK_INTERRUPTIBLE);
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>waitqueue_active</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>poll_wait))
</span></span><span style=display:flex><span>		pwake<span style=color:#666>++</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>out_unlock</span>:
</span></span><span style=display:flex><span>	<span style=color:#06287e>spin_unlock_irqrestore</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>lock, flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* We have to call this outside the lock */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (pwake)
</span></span><span style=display:flex><span>		<span style=color:#06287e>ep_poll_safewake</span>(<span style=color:#666>&amp;</span>psw, <span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>poll_wait);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> <span style=color:#40a070>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=epoll_wait><code>epoll_wait</code></h3><p>处理完所有的监听事件的维护，用户程序需要通过 <code>epoll_wait</code> 与 <code>eventpoll</code> 实例进行交互，并被告知所有正在监听中的事件是否发生。由于 <code>epoll_wait</code> 的整个逻辑基本上都是在进行错误检测，此处不表。我们只关注其中的核心逻辑，即调用的 <code>ep_poll</code> 函数。</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#007020;font-weight:700>static</span> <span style=color:#902000>int</span> <span style=color:#06287e>ep_poll</span>(<span style=color:#007020;font-weight:700>struct</span> eventpoll <span style=color:#666>*</span>ep, <span style=color:#007020;font-weight:700>struct</span> epoll_event __user <span style=color:#666>*</span>events,
</span></span><span style=display:flex><span>		   <span style=color:#902000>int</span> maxevents, <span style=color:#902000>long</span> timeout)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#902000>int</span> res, eavail;
</span></span><span style=display:flex><span>	<span style=color:#902000>unsigned</span> <span style=color:#902000>long</span> flags;
</span></span><span style=display:flex><span>	<span style=color:#902000>long</span> jtimeout;
</span></span><span style=display:flex><span>	<span style=color:#902000>wait_queue_t</span> wait;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * Calculate the timeout by checking for the &#34;infinite&#34; value ( -1 )
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * and the overflow condition. The passed timeout is in milliseconds,
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 * that why (t * HZ) / 1000.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	jtimeout <span style=color:#666>=</span> (timeout <span style=color:#666>&lt;</span> <span style=color:#40a070>0</span> <span style=color:#666>||</span> timeout <span style=color:#666>&gt;=</span> EP_MAX_MSTIMEO) <span style=color:#666>?</span>
</span></span><span style=display:flex><span>		<span style=color:#002070;font-weight:700>MAX_SCHEDULE_TIMEOUT</span> : (timeout <span style=color:#666>*</span> HZ <span style=color:#666>+</span> <span style=color:#40a070>999</span>) <span style=color:#666>/</span> <span style=color:#40a070>1000</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#002070;font-weight:700>retry</span>:
</span></span><span style=display:flex><span>	<span style=color:#06287e>spin_lock_irqsave</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>lock, flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	res <span style=color:#666>=</span> <span style=color:#40a070>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#60a0b0;font-style:italic>/* 
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 如果 eventpoll 实例的就绪队列为空，表明有没任何监听的事件发生。
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 主动让进程陷入Sleeping状态，知道被 ep_poll_callback() 唤醒
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>list_empty</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>rdllist)) {
</span></span><span style=display:flex><span>		<span style=color:#06287e>init_waitqueue_entry</span>(<span style=color:#666>&amp;</span>wait, current);
</span></span><span style=display:flex><span>		wait.flags <span style=color:#666>|=</span> WQ_FLAG_EXCLUSIVE;
</span></span><span style=display:flex><span>		<span style=color:#06287e>__add_wait_queue</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>wq, <span style=color:#666>&amp;</span>wait);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>for</span> (;;) {
</span></span><span style=display:flex><span>			<span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>			 * We don&#39;t want to sleep if the ep_poll_callback() sends us
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>			 * a wakeup in between. That&#39;s why we set the task state
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>			 * to TASK_INTERRUPTIBLE before doing the checks.
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>			 */</span>
</span></span><span style=display:flex><span>			<span style=color:#06287e>set_current_state</span>(TASK_INTERRUPTIBLE);
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span><span style=color:#06287e>list_empty</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>rdllist) <span style=color:#666>||</span> <span style=color:#666>!</span>jtimeout)
</span></span><span style=display:flex><span>				<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>			<span style=color:#007020;font-weight:700>if</span> (<span style=color:#06287e>signal_pending</span>(current)) {
</span></span><span style=display:flex><span>				res <span style=color:#666>=</span> <span style=color:#666>-</span>EINTR;
</span></span><span style=display:flex><span>				<span style=color:#007020;font-weight:700>break</span>;
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>			<span style=color:#06287e>spin_unlock_irqrestore</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>lock, flags);
</span></span><span style=display:flex><span>            <span style=color:#60a0b0;font-style:italic>/* 主动陷入Sleeping状态 */</span>
</span></span><span style=display:flex><span>			jtimeout <span style=color:#666>=</span> <span style=color:#06287e>schedule_timeout</span>(jtimeout);
</span></span><span style=display:flex><span>			<span style=color:#06287e>spin_lock_irqsave</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>lock, flags);
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#06287e>__remove_wait_queue</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>wq, <span style=color:#666>&amp;</span>wait);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#06287e>set_current_state</span>(TASK_RUNNING);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/* Is it worth to try to dig for events ? */</span>
</span></span><span style=display:flex><span>	eavail <span style=color:#666>=</span> <span style=color:#666>!</span><span style=color:#06287e>list_empty</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>rdllist);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#06287e>spin_unlock_irqrestore</span>(<span style=color:#666>&amp;</span>ep<span style=color:#666>-&gt;</span>lock, flags);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#60a0b0;font-style:italic>/*
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 将监听到的事件拷贝到用户空间。如果没有事件就绪且还没超时，就再抱着
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>     * 希望试一次。
</span></span></span><span style=display:flex><span><span style=color:#60a0b0;font-style:italic>	 */</span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>if</span> (<span style=color:#666>!</span>res <span style=color:#666>&amp;&amp;</span> eavail <span style=color:#666>&amp;&amp;</span>
</span></span><span style=display:flex><span>	    <span style=color:#666>!</span>(res <span style=color:#666>=</span> <span style=color:#06287e>ep_send_events</span>(ep, events, maxevents)) <span style=color:#666>&amp;&amp;</span> jtimeout)
</span></span><span style=display:flex><span>		<span style=color:#007020;font-weight:700>goto</span> retry;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#007020;font-weight:700>return</span> res;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=extra>Extra</h3><p>这部分的数据结构配合着一些胶水代码比较难以理解，最好配合着类图看看（个人使用，不一定适合各位）</p><p><img src=https://img.ffutop.com/E98BEF4A-FECC-4160-84F2-67D1B74CD029.jpg alt></p><h2 id=参考>参考</h2><ol><li>Linux Kernel 2.6.24</li><li><a href=https://idndx.com/2014/09/01/the-implementation-of-epoll-1/>The Implementation of epoll(1)</a></li><li><a href=https://idndx.com/2014/09/02/the-implementation-of-epoll-2/>The Implementation of epoll(2)</a></li><li><a href=https://idndx.com/2014/09/22/the-implementation-of-epoll-3/>The Implementation of epoll(3)</a></li><li><a href=https://idndx.com/2015/07/08/the-implementation-of-epoll-4/>The Implementation of epoll(4)</a></li></ol><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-plain data-lang=plain><span style=display:flex><span>  __                    __                  
</span></span><span style=display:flex><span> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ 
</span></span><span style=display:flex><span>| |_ / _` | &#39;_ \ / _` | |_ / _ \ &#39;_ \ / _` |
</span></span><span style=display:flex><span>|  _| (_| | | | | (_| |  _|  __/ | | | (_| |
</span></span><span style=display:flex><span>|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |
</span></span><span style=display:flex><span>                 |___/                |___/ 
</span></span></code></pre></div></div><div class="row middle-xs"><div class=col-xs-12><div class=post-tags><a href=/tags/linux/>Linux</a></div><div class=post-tags><a href=/tags/kernel/>Kernel</a></div><div class=post-tags><a href=/tags/io-model/>IO Model</a></div></div></div><div class=row><div class=col-xs-12><script type=module> import mermaid from "https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs"; mermaid.initialize({ startOnLoad: true }); </script></div></div><div class=related-content><h3>Related Posts</h3><ul><li><a href=/posts/2019-01-15-understand-kernel-8/>理解 Linux Kernel (8) - 网络</a></li><li><a href=/posts/2018-12-28-understand-kernel-7/>理解 Linux Kernel (7) - 字符设备</a></li><li><a href=/posts/2018-11-11-understand-kernel-6/>理解 Linux Kernel (6) - read & write</a></li></ul></div><div style=height:50px></div><div class=post-comments><div id=disqus_thread></div><script>window.addEventListener("load",()=>{(function(){var e=document,t=e.createElement("script");t.src="https://ffutop.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()})</script><noscript>Please enable JavaScript to view the
<a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></div><div class=site-footer></div></div></div></article><script>document.addEventListener("DOMContentLoaded",function(){const e=document.getElementById("disqus_thread"),t=new MutationObserver(function(n){n.forEach(function(){const s=e.getElementsByTagName("iframe");if(s.length>1){const n=s[1];for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(n),t.disconnect()}})});t.observe(e,{childList:!0,subtree:!0})})</script></body></html>