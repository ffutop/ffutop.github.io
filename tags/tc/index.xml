<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TC on Utop&#39;s Blog</title>
    <link>https://www.ffutop.com/tags/tc/</link>
    <description>Recent content in TC on Utop&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cmn-Hans-CN</language>
    <lastBuildDate>Fri, 23 Aug 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://www.ffutop.com/tags/tc/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Linux Traffic Control</title>
      <link>https://www.ffutop.com/posts/2019-08-23-linux-traffic-control/</link>
      <pubDate>Fri, 23 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.ffutop.com/posts/2019-08-23-linux-traffic-control/</guid>
      <description>&lt;p&gt;最近在处理 Kubernetes 工作的时候，被问及这样一个命题：Pod 能对 CPU 和内存施加限制，那同样属于资源范畴的网络带宽是否能限制呢？使用 Kubernetes 的一个核心优势在于每个 Pod 都等同于一个轻量级的“操作系统”。建立在 Linux 命名空间(namespace)和控制组(cgroups)基础上的容器技术将每个 Pod 的资源进行了隔离和限制。但是，限流只针对 CPU 和内存，对网络、磁盘 IO 的解决方案仅仅局限在隔离，难道技术上实现不了吗？自然不是，Kubernetes 有意识地将网络模块拆解，只定义插件规范，而将实现的可能性交由下游开发自由决策。当然，本篇并不在意 Kubernetes 网络限流的解决方案，只是以此作为引子。&lt;/p&gt;

&lt;p&gt;流量控制(Traffic Control, TC) 是 Linux 内核提供的流量限速、整形、策略控制机制。近乎完美地支持网络限流的命题，除了，这是比 Netfilter 更难理解的模块。Netfilter 作用在内核网络协议栈上，通过在各个枢纽设立关卡对网络包(&lt;code&gt;sk_buff&lt;/code&gt; 数据结构, skb)进行检查，并实施 ACCEPT、DROP、MASQUERADE 等策略。相比之下，TC 是绑定在网络设备上实施的。提供 &lt;code&gt;enqueue&lt;/code&gt;, &lt;code&gt;dequeue&lt;/code&gt; 两个核心函数，也是作为关卡对到达网络设备的网络包实施策略。要说核心的不同之处，Netfilter 是流式地处理网络包，先到的网络包一定先出（也可能是被丢弃）；TC 的处理方式就依照策略，类比块设备的随机读/随机写了。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>