<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>见解 on Utop's Blog</title><link>https://www.ffutop.com/categories/%E8%A7%81%E8%A7%A3/</link><description>Recent content in 见解 on Utop's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cmn-Hans-CN</language><lastBuildDate>Fri, 22 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://www.ffutop.com/categories/%E8%A7%81%E8%A7%A3/index.xml" rel="self" type="application/rss+xml"/><item><title>内网环境 HTTPS 实施方案深度解析</title><link>https://www.ffutop.com/posts/2025-08-22-intranet-https-practice/</link><pubDate>Fri, 22 Aug 2025 00:00:00 +0000</pubDate><guid>https://www.ffutop.com/posts/2025-08-22-intranet-https-practice/</guid><description>在现代 IT 架构中，使用 HTTPS (HTTP over TLS) 对网络通信进行加密已成为事实标准。浏览器侧对新一代协议的实现也强化了这一趋势：HTTP/2 在浏览器中仅实现 TLS 形态</description></item><item><title>URI 与资源定义</title><link>https://www.ffutop.com/posts/2020-05-23-uri/</link><pubDate>Sat, 23 May 2020 00:00:00 +0000</pubDate><guid>https://www.ffutop.com/posts/2020-05-23-uri/</guid><description>&lt;blockquote>
&lt;p>URI syntax:
&lt;code>&amp;lt;scheme&amp;gt;:&amp;lt;scheme-specific-part&amp;gt;&lt;/code>&lt;/p>
&lt;p>generic URI syntax:
&lt;code>&amp;lt;scheme&amp;gt;://&amp;lt;authority&amp;gt;&amp;lt;path&amp;gt;?&amp;lt;query&amp;gt;&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>此前对 URI、URL 的定义一知半解，网上充斥着大量文档试图描述 URI、URL、URN 的区别。其中一种经典的观点是：URI 是 URN、URL 的超集。其中 URN 被用来描述资源的名称(身份ID)，而 URL 被用来描述查找该资源的方法。这个表述确实没有问题，但对于理解 URx 无法提供切实的帮助。最近阅读了 &lt;a href="https://tools.ietf.org/html/rfc3305">RFC 3305&lt;/a>、&lt;a href="https://tools.ietf.org/html/rfc3986">RFC 3986&lt;/a>、&lt;a href="https://tools.ietf.org/html/rfc7595">RFC 7595&lt;/a> 等资料，本文将聊聊个人对 URI 的见解，以及借此回顾此前参与的公司权限系统的设计。&lt;/p></description></item><item><title>Idempotent Pattern</title><link>https://www.ffutop.com/posts/2020-03-26-idempotent/</link><pubDate>Thu, 26 Mar 2020 00:00:00 +0000</pubDate><guid>https://www.ffutop.com/posts/2020-03-26-idempotent/</guid><description>&lt;p>&lt;a name="initProblem" />“同样是 KV-Server ，为什么基于 Raft Algorithm 的 KV-Server 需要对客户端操作实现幂等，而 Redis 却不需要？” 此前在实现基于 Raft 的容错 Key/Value Service 时，为了能够实现幂等的 &lt;code>Put(key, value)&lt;/code>、&lt;code>Append(key, arg)&lt;/code> 操作，可谓是费尽心思。但同为提供键值服务的 Redis ，怎么从来没见被要求幂等呢？&lt;/p>
&lt;p>基于这个问题，本篇将整理并总结个人的结论。&lt;/p></description></item></channel></rss>