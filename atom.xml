<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Utop&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://DorMOUSE-None.github.io/"/>
  <updated>2018-07-05T01:23:29.533Z</updated>
  <id>https://DorMOUSE-None.github.io/</id>
  
  <author>
    <name>Utop</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeanCloud Test Page</title>
    <link href="https://DorMOUSE-None.github.io/2018-07-05-LeanCloudTest/"/>
    <id>https://DorMOUSE-None.github.io/2018-07-05-LeanCloudTest/</id>
    <published>2018-07-04T16:00:00.000Z</published>
    <updated>2018-07-05T01:23:29.533Z</updated>
    
    <content type="html"><![CDATA[<p>OK, It’s Just a Test;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OK, It’s Just a Test;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java 安全访问与权限控制</title>
    <link href="https://DorMOUSE-None.github.io/2018-07-04-JDK-Permission/"/>
    <id>https://DorMOUSE-None.github.io/2018-07-04-JDK-Permission/</id>
    <published>2018-07-03T16:00:00.000Z</published>
    <updated>2018-07-04T12:12:25.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><p><em>本文只是对 Java 安全访问与权限控制的基础性探究。</em></p><p><strong>本节与全文内容无关，如无兴趣阅读，可以跳过</strong></p><p>了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行”自动发现”和加载。<br>这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要</p><ol><li>在 <code>META-INF.services</code> 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容</li><li>由项目的注册管理器触发下列 Java 代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ServiceLoader&lt;XxxPolicy&gt; xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;XxxPolicy&gt; it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">        XxxPolicy xxxPolicy = it.next();</span><br><span class="line">        <span class="comment">// ... more code ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以完成一个新的 SPI 策略的注册工作。</p><p>但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-<version>.jar 在注册 Driver 相关的代码。<br>发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:</version></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">            driversIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">                <span class="comment">// Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。</p><p>为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。</p><a id="more"></a><h2 id="从现象开始…"><a href="#从现象开始…" class="headerlink" title="从现象开始…"></a>从现象开始…</h2><p>在通过 <code>java</code> 命令执行本地代码时，偶尔/经常会出现文件I/O操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    System.out.println(System.getSecurityManager());</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"/Users/fangfeng/test.in"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> chr; (chr = fis.read()) != -<span class="number">1</span>;) &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) chr);</span><br><span class="line">    &#125;</span><br><span class="line">    fis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诸如上面这段代码，意在读取外部路径下 <code>test.in</code> 文件(不要放在项目路径下，文本内容为 <code>0123456789</code>)。当然，还包括打印 System.getSecurityManager().toString() 。</p><p>正常情况下，这都是能够执行成功，结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">0123456789</span><br></pre></td></tr></table></figure><p>但是，通过在命令行 <code>java</code> 中添加选项 <code>-Djava.security.manager</code>，再次执行代码，结果为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityManager@4e25154f</span><br><span class="line">Exception in thread &quot;main&quot; java.security.AccessControlException: access denied (&quot;java.io.FilePermission&quot; &quot;/Users/fangfeng/test.in&quot; &quot;read&quot;)</span><br><span class="line">at java.security.AccessControlContext.checkPermission(AccessControlContext.java:472)</span><br><span class="line">at java.security.AccessController.checkPermission(AccessController.java:884)</span><br><span class="line">at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)</span><br><span class="line">at java.lang.SecurityManager.checkRead(SecurityManager.java:888)</span><br><span class="line">at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:127)</span><br><span class="line">at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93)</span><br><span class="line">at me.fangfeng.security.SecurityTest.main(SecurityTest.java:16)</span><br></pre></td></tr></table></figure><p>现在已经能够获取到 <code>System.getSecuriryManager</code> 的实例。<br>但是想要读取 <code>test.in</code> 文件却失败了，表现为 access denied（访问被拒绝）。</p><p>现在，在用户目录下(这里是 /Users/fangfeng, 不同系统不同用户请做相应修改) 添加 <code>.java.policy</code> 文件，添加下列文本:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.io.FilePermission &quot;/Users/fangfeng/test.in&quot;, &quot;read&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再次 <code>java -Djava.security.manager &lt;class&#39;s path&gt;</code>，不仅能够得到 SecurityManager 的实例，同时也读取到了文本内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityManager@3af49f1c</span><br><span class="line">0123456789</span><br></pre></td></tr></table></figure><hr><p>到此为止，应该已经能够感受到 Java 对安全访问的控制在文件I/O上的体现了。</p><h2 id="安全控制下的操作"><a href="#安全控制下的操作" class="headerlink" title="安全控制下的操作"></a>安全控制下的操作</h2><p><strong>在开始下列内容之前，需要提前了解一个前提:</strong><br><strong>Java 对操作权限的控制是通过检查当前线程操作上下文的代码是否存在要求的操作权限实现的(除了特权的声明以及其它还需要控制别的线程上下文权限的情况)</strong></p><p>上一节演示了权限控制下本地代码对本地资源的访问。但是，安全控制真的有必要吗？</p><ul><li>就本地程序而言，不必要。事实上，Java 也确实是这么做的。平时在本地利用 <code>java</code> 命令执行程序，都不会受到任何限制。Java 启动时默认不会装载 SecurityManager，也就不会触发对各种操作的权限验证。</li><li>可如果程序运行与网络上其它程序交互，甚至直接加载来自网络的字节码。那么，权限控制确实是有必要的。至少，如果不存在权限控制，来自网络的恶意代码访问整台机器的任意资源都将畅通无阻。</li></ul><h3 id="SecurityManager"><a href="#SecurityManager" class="headerlink" title="SecurityManager"></a>SecurityManager</h3><p>SecurityManager 是整个访问控制的管理器和基本入口。所有涉及到权限控制的代码，都会类似地存在下列这般的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SecurityManager security = System.getSecurityManager();</span><br><span class="line"><span class="comment">// 如果系统存在安全管理器</span></span><br><span class="line"><span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 SecurityManager 中以 check 开头的方法</span></span><br><span class="line">    security.checkXxx(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>security.checkXxx(...)</code> 是没有返回值的(除了 checkTopLevelWindow)；对于没有操作权限的代码，直接抛出异常</p><p>至于到底在 check 什么，Java 中定义了包括文件(File)、套接字(Socket)、网络(Net)、安全性(Security)、运行时(Runtime)、属性(Property)、AWT、反射(Reflect)和可序列化(Serializable) 九类权限。</p><p>通常，security.checkXxx(…) 方法将构造一个 XxxPermission(…) 对象来调用 SecurityManager 提供的统一方法 checkPermission(Permission) 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 checkRead(name) 为例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkRead</span><span class="params">(String file)</span> </span>&#123;</span><br><span class="line">    checkPermission(<span class="keyword">new</span> FilePermission(file, SecurityConstants.FILE_READ_ACTION));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 checkPermission(Permission) 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(Permission perm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接调用 访问控制器 来对权限进行鉴别</span></span><br><span class="line">    java.security.AccessController.checkPermission(perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AccessController"><a href="#AccessController" class="headerlink" title="AccessController"></a>AccessController</h3><p>AccessController 用于与访问控制相关的操作和决定。</p><blockquote><p>AccessController 类用于以下三个目的：</p><p>基于当前生效的安全策略决定是允许还是拒绝对关键系统资源的访问<br>将代码标记为享有“特权”，从而影响后续访问决定，以及<br>获取当前调用上下文的“快照”，这样便可以相对于已保存的上下文作出其他上下文的访问控制决定</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>总的来说，Java 的访问控制就是通过针对不同的操作构建不同的 Permission 对象，然后通过与 AccessControllerContent 持有的各代码的权限进行比对，<br>从而判断代码是否存在相应的访问权限。</p><p><em>所谓的Permission判断将是对当前线程的调用栈的每个调用者逐一倒序递归，判断是否拥有权限。如果其中的某个代码被声明为 Privileged，则直接认为是拥有权限</em></p><p><strong>更多的关于 checkPermission(…) 调用相关的内容，可以自行查阅资料进行学习，在此不做过多陈述。:)</strong></p><h2 id="为操作赋权"><a href="#为操作赋权" class="headerlink" title="为操作赋权"></a>为操作赋权</h2><p>上一节讲完了如果对当前项目配置了 SecurityManager ，将对各种敏感操作进行访问控制，并且将根据整个调用链被赋予的权限来决定是允许执行还是抛出 access denied。</p><p>但是，究竟怎么才能够给 code 赋予权限呢？</p><p>回顾前一节的内容，在基本探究中，其实一个能够看到<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grant &#123;</span><br><span class="line">    permission java.io.FilePermission <span class="string">"/Users/fangfeng/test.in"</span>, <span class="string">"read"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>这就是一种赋权的操作。</p><p>通过在指定的文件中写入符合特定规则的代码，来完成对 code 的赋权。<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html" target="_blank" rel="noopener">Default Policy Implementation and Policy File Syntax</a></p><p>在项目启动的时候，默认就会读取 $JAVA_HOME/jre/lib/security/java.policy 以及 ${user.home}/.java.policy 两个文件的赋权内容，并做缓存给后面代码使用。</p><p>当然，Java 也提供指定自定义的赋权文件，通过 -Djava.security.policy=<policy file=""> 或者 -Djava.security.policy==<policy file=""> 。</policy></policy></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]. Java Document - Security. <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h2&gt;&lt;p&gt;&lt;em&gt;本文只是对 Java 安全访问与权限控制的基础性探究。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本节与全文内容无关，如无兴趣阅读，可以跳过&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;了解 Java 安全访问相关内容的初衷，是准备在项目中利用 Java 标准库提供的 ServiceLoader 对 SPI 实现类进行”自动发现”和加载。&lt;br&gt;这对于将本项目作为二方库来依赖的上层项目将更为方便，只需要&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 &lt;code&gt;META-INF.services&lt;/code&gt; 目录下配置被命名为 SPI 接口全限定名的文件及添加相关内容&lt;/li&gt;
&lt;li&gt;由项目的注册管理器触发下列 Java 代码&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ServiceLoader&amp;lt;XxxPolicy&amp;gt; xxxPolicyServiceLoader = ServiceLoader.load(XxxPolicy.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Iterator&amp;lt;XxxPolicy&amp;gt; it = xxxPolicyServiceLoader.iterator(); it.hasNext(); ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        XxxPolicy xxxPolicy = it.next();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ... more code ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;就可以完成一个新的 SPI 策略的注册工作。&lt;/p&gt;
&lt;p&gt;但是，在尝试实现，了解了 ServiceLoader 源码，以及 DriverManager 和 mysql-connection-java-&lt;version&gt;.jar 在注册 Driver 相关的代码。&lt;br&gt;发现怎么也绕不开 Java 安全访问相关的内容。诸如下列这段来自 DriverManager.loadInitialDrivers() 的代码:&lt;/version&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AccessController.doPrivileged(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;Void&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Void &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ServiceLoader&amp;lt;Driver&amp;gt; loadedDrivers = ServiceLoader.load(Driver.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Iterator&amp;lt;Driver&amp;gt; driversIterator = loadedDrivers.iterator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(driversIterator.hasNext()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            driversIterator.next();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(Throwable t) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;comment&quot;&gt;// Do nothing&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;诸如 AccessController, Permission, SecurityManager 的代码始终是一个绕不开的主旋律。&lt;/p&gt;
&lt;p&gt;为了探究这部分控制对项目中 ServiceLoader 的真正作用以及其编码意义，开始了对本文所描述的主体内容的初步了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="Security" scheme="https://DorMOUSE-None.github.io/tags/Security/"/>
    
      <category term="Permission" scheme="https://DorMOUSE-None.github.io/tags/Permission/"/>
    
  </entry>
  
  <entry>
    <title>ASM-VerifyError错误信息解决</title>
    <link href="https://DorMOUSE-None.github.io/2018-06-28-ASM-VerifyError/"/>
    <id>https://DorMOUSE-None.github.io/2018-06-28-ASM-VerifyError/</id>
    <published>2018-06-27T16:00:00.000Z</published>
    <updated>2018-06-28T10:46:48.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.VerifyError: <span class="class"><span class="keyword">class</span> <span class="title">net</span>.<span class="title">sf</span>.<span class="title">cglib</span>.<span class="title">core</span>.<span class="title">DebuggingClassWriter</span> <span class="title">overrides</span> <span class="title">final</span> <span class="title">method</span> <span class="title">visit</span>.(<span class="title">IILjava</span>/<span class="title">lang</span>/<span class="title">String</span></span>;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目依赖的 </p><ul><li>CGlib 版本是 2.2.2</li><li>ASM 版本是 3.3.1</li></ul><h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>前两天刚粗略通读了 ASM ，结果就遇上这样一个问题。</p><p>从 <code>net.sf.cglib.core.DebuggingClassWriter</code> 看，这是 CGlib 的一个实现类</p><p>从描述 <code>overrides final method visit.(IILjava/lang/String;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V</code><br>以及 DebuggingClassWriter 类的字节码反编译结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebuggingClassWriter</span> <span class="keyword">extends</span> <span class="title">ClassWriter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.className = name.replace(<span class="string">'/'</span>, <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">this</span>.superName = superName.replace(<span class="string">'/'</span>, <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至少应该是 visit(…) 方法要重载的父类的被声明为 final 的 ClassWriter.visit(…) 才导致的问题。</p><p>但是从 ASM 3.3.1 版本的 ClassWriter 类可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> var1, <span class="keyword">int</span> var2, String var3, String var4, String var5, String[] var6)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>visit 方法并没有被声明为 final 。</p><p>但是，结合一定的背景知识，ASM 项目在加入了 OW2 组织后的新版本(asm-3.3.1 是未加入 OW2 前的最后一个版本)，<br>ClassWriter 类的所有 visitXxx(…) 方法都被添加了 <code>final</code> 限制。</p><p>因此，怀疑是项目实际依赖了高版本的 asm (asm 4.x 及以上)</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>经过确认，由于整个项目依赖关系复杂，有其它项目引入了 asm-4.1.jar。<br>而且由于使用 MAVEN 进行项目依赖管理，asm-4.1.jar 与依赖树根的深度更浅，<br>因此，最终打包的 war 里面确实引入了 asm-4.1.jar 。导致了这个问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;报错信息&quot;&gt;&lt;a href=&quot;#报错信息&quot; class=&quot;headerlink&quot; title=&quot;报错信息&quot;&gt;&lt;/a&gt;报错信息&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;java.lang.VerifyError: &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;net&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;sf&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;cglib&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;core&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;DebuggingClassWriter&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;overrides&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;visit&lt;/span&gt;.(&lt;span class=&quot;title&quot;&gt;IILjava&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;lang&lt;/span&gt;/&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&lt;/span&gt;;Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;)V&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="ASM" scheme="https://DorMOUSE-None.github.io/tags/ASM/"/>
    
      <category term="CGlib" scheme="https://DorMOUSE-None.github.io/tags/CGlib/"/>
    
  </entry>
  
  <entry>
    <title>ASM 核心包基本内容漫谈</title>
    <link href="https://DorMOUSE-None.github.io/2018-06-25-ASM-Core/"/>
    <id>https://DorMOUSE-None.github.io/2018-06-25-ASM-Core/</id>
    <published>2018-06-24T16:00:00.000Z</published>
    <updated>2018-06-25T10:16:37.866Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文描述的 ASM 指的是 OW2 ASM</p></blockquote><h2 id="ASM-Core-的结构"><a href="#ASM-Core-的结构" class="headerlink" title="ASM-Core 的结构"></a>ASM-Core 的结构</h2><p><em>首先是一些概述性的内容。</em></p><p>由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。<br>因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)</p><p>从核心包声明的类来看，主要包括:</p><ol><li><p>ClassReader - 作为结构化对象，将接收(accept)访问者的访问</p></li><li><p>几种访问者抽象类以及相应的实现类</p></li></ol><ul><li>AnnotationVisitor -&gt; AnnotationWriter</li><li>ClassVisitor -&gt; ClassWriter</li><li>FieldVisitor -&gt; FieldWriter</li><li>MethodVisitor -&gt; MethodWriter</li><li>ModuleVisitor -&gt; ModuleWriter</li></ul><ol start="3"><li><p>Opcodes &amp; Constants - ClassFile 中描述的大量常量符号与值</p></li><li><p>其它一些辅助的类</p></li></ol><ul><li>Attribute - 用于处理非标准化的属性(ClassFile 允许<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="noopener">JVMS</a> 中未定义的 Attribute)</li><li>ByteArray - 动态可自适应的 byte[] (字节数组)</li><li>Context - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象</li><li>Symbol - 用于表示 ClassFile 中描述的 Constant 的基类</li><li>SymbolTable - 用于存储常量池对象</li><li>其它内容省略</li></ul><a id="more"></a><h2 id="ClassFile-文件格式"><a href="#ClassFile-文件格式" class="headerlink" title="ClassFile 文件格式"></a>ClassFile 文件格式</h2><p>本节的内容可以参阅 <a href="https://dormouse-none.github.io/2018-06-11-ASM-ClassReader/">ClassFile 文件格式</a></p><p>ClassFile 是 ASM 操作字节码的基础与前提。在 JVMS 定义了 .class 文件格式之后，ASM 才在此基础上进行了对 ClassFile 的字节码操作。</p><p>因此，无论如何，个人认为在真正开始了解 ASM 之前，通读一遍 ClassFile 文件格式是完全有必要的。并且，在基本了解 ClassFile 内容的基础上，<br>尝试对某个 .class 文件进行手工解析也不失为一种加深理解的途径。</p><h2 id="Visitor-Pattern"><a href="#Visitor-Pattern" class="headerlink" title="Visitor Pattern"></a>Visitor Pattern</h2><p>由于 ASM 的实现采用了偏门的访问者模式。因此，了解访问者模式也是一个必不可少的重要环节。同时在了解后也将为源码阅读者提供更清晰的解读思路。</p><p>《设计模式：可复用面向对象软件的基础》一书的“5.11 VISITOR(访问者)——对象行为型模式”提供了很详尽的解释。</p><p>本人对这方面的不甚了解，推荐自行查找资料。</p><h2 id="ClassReader"><a href="#ClassReader" class="headerlink" title="ClassReader"></a>ClassReader</h2><p>ClassReader 是解析现有的 .class 文件的基本工具。同时，ClassReader 也作为一个内容的持有者，与 SymboleTable 配合，来满足访问者基本的访问需求。</p><p>刨除大量的内部私有方法，ClassReader 对外开放的接口相当简单。最核心的方法仅包括 ClassReader(…) 以及 accetp(…)</p><h3 id="ClassReader-…-构造方法"><a href="#ClassReader-…-构造方法" class="headerlink" title="ClassReader(…) 构造方法"></a>ClassReader(…) 构造方法</h3><p>顾名思义，构造方法用于实例化 ClassReader 对象，包括一些必须的变量的初始化。</p><p>在构造函数中完成的初始化内容包括:</p><ul><li>校验版本号</li><li>存储每个常量池项目的起始偏移量 cpInfoOffsets</li><li>存储每个引导方法的起始偏移量 bootstrapMethodOffsets</li><li>存储最长字符串常量的大小 maxStringLength</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">ClassReader(<span class="keyword">final</span> <span class="keyword">byte</span>[] classFileBuffer, <span class="keyword">final</span> <span class="keyword">int</span> classFileOffset, <span class="keyword">final</span> <span class="keyword">boolean</span> checkClassVersion) &#123;</span><br><span class="line">  <span class="keyword">this</span>.b = classFileBuffer;   <span class="comment">// .class 文件缓存</span></span><br><span class="line">  <span class="comment">// 检查主版本号, 第6,7个字节(从0字节开始计数)</span></span><br><span class="line">  <span class="keyword">if</span> (checkClassVersion &amp;&amp; readShort(classFileOffset + <span class="number">6</span>) &gt; Opcodes.V11) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"Unsupported class file major version "</span> + readShort(classFileOffset + <span class="number">6</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节</span></span><br><span class="line">  <span class="keyword">int</span> constantPoolCount = readUnsignedShort(classFileOffset + <span class="number">8</span>);     <span class="comment">// 读取无符号short, 即读取连续两字节作为一个short值</span></span><br><span class="line">  cpInfoOffsets = <span class="keyword">new</span> <span class="keyword">int</span>[constantPoolCount];                         <span class="comment">// 每个常量的偏移位置</span></span><br><span class="line">  cpInfoValues = <span class="keyword">new</span> Object[constantPoolCount];                       <span class="comment">// 每个常量的实例对象</span></span><br><span class="line">  <span class="keyword">int</span> currentCpInfoIndex = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> currentCpInfoOffset = classFileOffset + <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> currentMaxStringLength = <span class="number">0</span>;                                     <span class="comment">// 最长字符串常量</span></span><br><span class="line">  <span class="keyword">while</span> (currentCpInfoIndex &lt; constantPoolCount) &#123;</span><br><span class="line">    cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cpInfoSize;</span><br><span class="line">    <span class="keyword">switch</span> (classFileBuffer[currentCpInfoOffset]) &#123;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_FIELDREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHODREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INTERFACE_METHODREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INTEGER_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_FLOAT_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_NAME_AND_TYPE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_DYNAMIC_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_LONG_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_DOUBLE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">9</span>;</span><br><span class="line">        currentCpInfoIndex++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_UTF8_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">3</span> + readUnsignedShort(currentCpInfoOffset + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (cpInfoSize &gt; currentMaxStringLength) &#123;</span><br><span class="line">          <span class="comment">// The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate</span></span><br><span class="line">          <span class="comment">// of the length in characters of the corresponding string, and is much cheaper to</span></span><br><span class="line">          <span class="comment">// compute than this exact length.</span></span><br><span class="line">          currentMaxStringLength = cpInfoSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHOD_HANDLE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_CLASS_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_STRING_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHOD_TYPE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_PACKAGE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_MODULE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    currentCpInfoOffset += cpInfoSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.maxStringLength = currentMaxStringLength;</span><br><span class="line">  <span class="comment">// The Classfile's access_flags field is just after the last constant pool entry.</span></span><br><span class="line">  <span class="keyword">this</span>.header = currentCpInfoOffset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 BootstrapMethods 属性(如果存在)</span></span><br><span class="line">  <span class="keyword">int</span> currentAttributeOffset = getFirstAttributeOffset();</span><br><span class="line">  <span class="keyword">int</span>[] currentBootstrapMethodOffsets = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = readUnsignedShort(currentAttributeOffset - <span class="number">2</span>); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="comment">// 读取每个 attribute_info 的属性名和属性长度</span></span><br><span class="line">    String attributeName = readUTF8(currentAttributeOffset, <span class="keyword">new</span> <span class="keyword">char</span>[maxStringLength]);</span><br><span class="line">    <span class="keyword">int</span> attributeLength = readInt(currentAttributeOffset + <span class="number">2</span>);</span><br><span class="line">    currentAttributeOffset += <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 如果当前属性名为 BootstrapMethods ，则进入处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.BOOTSTRAP_METHODS.equals(attributeName)) &#123;</span><br><span class="line">      <span class="comment">// Read the num_bootstrap_methods field and create an array of this size.</span></span><br><span class="line">      currentBootstrapMethodOffsets = <span class="keyword">new</span> <span class="keyword">int</span>[readUnsignedShort(currentAttributeOffset)];</span><br><span class="line">      <span class="comment">// Compute and store the offset of each 'bootstrap_methods' array field entry.</span></span><br><span class="line">      <span class="keyword">int</span> currentBootstrapMethodOffset = currentAttributeOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; currentBootstrapMethodOffsets.length; ++j) &#123;</span><br><span class="line">        currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;</span><br><span class="line">        <span class="comment">// Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),</span></span><br><span class="line">        <span class="comment">// as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).</span></span><br><span class="line">        currentBootstrapMethodOffset +=</span><br><span class="line">            <span class="number">4</span> + readUnsignedShort(currentBootstrapMethodOffset + <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    currentAttributeOffset += attributeLength;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.bootstrapMethodOffsets = currentBootstrapMethodOffsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。<br>但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。</p><h3 id="accept-…"><a href="#accept-…" class="headerlink" title="accept(…)"></a>accept(…)</h3><p>访问者模式的核心操作就是结构化对象接受(accept)访问者对象实例的访问，并将结构化内容完全暴露给访问者。</p><p>从抽象的方法角度看，可以理解成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// --- 结构化对象的 accept() 方法 ---</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">  visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 访问者对象的 visit() 方法 ---</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Xxx <span class="title">visit</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 若干关于 element 的读操作 + 其它操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ClassVisitor classVisitor,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Attribute[] attributePrototypes,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> parsingOptions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 Context 作为辅助类，暂存被访问过程的“累积状态”</span></span><br><span class="line">    Context context = <span class="keyword">new</span> Context();</span><br><span class="line">    context.attributePrototypes = attributePrototypes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析选项: </span></span><br><span class="line"><span class="comment">     * 1. SKIP_CODE - 不解析 CODE 属性 </span></span><br><span class="line"><span class="comment">     * 2. SKIP_DEBUG - 不解析 DEBUG 相关的属性(例如SourceFile, SourceDebugExtension, LocalVariableTable, LocalVariableTypeTable, LineNumberTable)</span></span><br><span class="line"><span class="comment">     * 4. SKIP_FRAMES - 跳过对 StackMap 和 StackMapTable 属性的解析</span></span><br><span class="line"><span class="comment">     * ...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    context.parsingOptions = parsingOptions;</span><br><span class="line">    <span class="comment">// 从常量池读取常量所使用的缓冲数字</span></span><br><span class="line">    context.charBuffer = <span class="keyword">new</span> <span class="keyword">char</span>[maxStringLength];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the access_flags, this_class, super_class, interface_count and interfaces fields.</span></span><br><span class="line">    <span class="comment">// 解析访问控制, 当前类, 父类, 接口数量与接口值等</span></span><br><span class="line">    <span class="keyword">char</span>[] charBuffer = context.charBuffer;</span><br><span class="line">    <span class="keyword">int</span> currentOffset = header;</span><br><span class="line">    <span class="keyword">int</span> accessFlags = readUnsignedShort(currentOffset);</span><br><span class="line">    String thisClass = readClass(currentOffset + <span class="number">2</span>, charBuffer);</span><br><span class="line">    String superClass = readClass(currentOffset + <span class="number">4</span>, charBuffer);</span><br><span class="line">    String[] interfaces = <span class="keyword">new</span> String[readUnsignedShort(currentOffset + <span class="number">6</span>)];</span><br><span class="line">    currentOffset += <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; ++i) &#123;</span><br><span class="line">      interfaces[i] = readClass(currentOffset, charBuffer);</span><br><span class="line">      currentOffset += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read the class attributes (the variables are ordered as in Section 4.7 of the JVMS).</span></span><br><span class="line">    <span class="comment">// Attribute offsets exclude the attribute_name_index and attribute_length fields.</span></span><br><span class="line">    <span class="comment">// - The offset of the InnerClasses attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> innerClassesOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the EnclosingMethod attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> enclosingMethodOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the Signature attribute, or null.</span></span><br><span class="line">    String signature = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the SourceFile attribute, or null.</span></span><br><span class="line">    String sourceFile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the SourceDebugExtension attribute, or null.</span></span><br><span class="line">    String sourceDebugExtension = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The offset of the RuntimeVisibleAnnotations attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> runtimeVisibleAnnotationsOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the RuntimeInvisibleAnnotations attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> runtimeInvisibleAnnotationsOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the RuntimeVisibleTypeAnnotations attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> runtimeVisibleTypeAnnotationsOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the RuntimeInvisibleTypeAnnotations attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> runtimeInvisibleTypeAnnotationsOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the Module attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> moduleOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The offset of the ModulePackages attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> modulePackagesOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the ModuleMainClass attribute, or null.</span></span><br><span class="line">    String moduleMainClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The string corresponding to the NestHost attribute, or null.</span></span><br><span class="line">    String nestHostClass = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// - The offset of the NestMembers attribute, or 0.</span></span><br><span class="line">    <span class="keyword">int</span> nestMembersOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// - The non standard attributes (linked with their &#123;@link Attribute#nextAttribute&#125; field).</span></span><br><span class="line">    <span class="comment">//   This list in the &lt;i&gt;reverse order&lt;/i&gt; or their order in the ClassFile structure.</span></span><br><span class="line">    Attribute attributes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 Class 持有的属性</span></span><br><span class="line">    <span class="keyword">int</span> currentAttributeOffset = getFirstAttributeOffset();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = readUnsignedShort(currentAttributeOffset - <span class="number">2</span>); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">      <span class="comment">// Read the attribute_info's attribute_name and attribute_length fields.</span></span><br><span class="line">      String attributeName = readUTF8(currentAttributeOffset, charBuffer);</span><br><span class="line">      <span class="keyword">int</span> attributeLength = readInt(currentAttributeOffset + <span class="number">2</span>);</span><br><span class="line">      currentAttributeOffset += <span class="number">6</span>;</span><br><span class="line">      <span class="comment">// The tests are sorted in decreasing frequency order (based on frequencies observed on</span></span><br><span class="line">      <span class="comment">// typical classes).</span></span><br><span class="line">      <span class="keyword">if</span> (Constants.SOURCE_FILE.equals(attributeName)) &#123;</span><br><span class="line">        sourceFile = readUTF8(currentAttributeOffset, charBuffer);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.INNER_CLASSES.equals(attributeName)) &#123;</span><br><span class="line">        innerClassesOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.ENCLOSING_METHOD.equals(attributeName)) &#123;</span><br><span class="line">        enclosingMethodOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.NEST_HOST.equals(attributeName)) &#123;</span><br><span class="line">        nestHostClass = readClass(currentAttributeOffset, charBuffer);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.NEST_MEMBERS.equals(attributeName)) &#123;</span><br><span class="line">        nestMembersOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.SIGNATURE.equals(attributeName)) &#123;</span><br><span class="line">        signature = readUTF8(currentAttributeOffset, charBuffer);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.RUNTIME_VISIBLE_ANNOTATIONS.equals(attributeName)) &#123;</span><br><span class="line">        runtimeVisibleAnnotationsOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.RUNTIME_VISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) &#123;</span><br><span class="line">        runtimeVisibleTypeAnnotationsOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.DEPRECATED.equals(attributeName)) &#123;</span><br><span class="line">        accessFlags |= Opcodes.ACC_DEPRECATED;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.SYNTHETIC.equals(attributeName)) &#123;</span><br><span class="line">        accessFlags |= Opcodes.ACC_SYNTHETIC;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.SOURCE_DEBUG_EXTENSION.equals(attributeName)) &#123;</span><br><span class="line">        sourceDebugExtension =</span><br><span class="line">            readUTF(currentAttributeOffset, attributeLength, <span class="keyword">new</span> <span class="keyword">char</span>[attributeLength]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.RUNTIME_INVISIBLE_ANNOTATIONS.equals(attributeName)) &#123;</span><br><span class="line">        runtimeInvisibleAnnotationsOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS.equals(attributeName)) &#123;</span><br><span class="line">        runtimeInvisibleTypeAnnotationsOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.MODULE.equals(attributeName)) &#123;</span><br><span class="line">        moduleOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.MODULE_MAIN_CLASS.equals(attributeName)) &#123;</span><br><span class="line">        moduleMainClass = readClass(currentAttributeOffset, charBuffer);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.MODULE_PACKAGES.equals(attributeName)) &#123;</span><br><span class="line">        modulePackagesOffset = currentAttributeOffset;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Constants.BOOTSTRAP_METHODS.equals(attributeName)) &#123;</span><br><span class="line">        <span class="comment">// This attribute is read in the constructor.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Attribute attribute =</span><br><span class="line">            readAttribute(</span><br><span class="line">                attributePrototypes,</span><br><span class="line">                attributeName,</span><br><span class="line">                currentAttributeOffset,</span><br><span class="line">                attributeLength,</span><br><span class="line">                charBuffer,</span><br><span class="line">                -<span class="number">1</span>,</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        attribute.nextAttribute = attributes;</span><br><span class="line">        attributes = attribute;</span><br><span class="line">      &#125;</span><br><span class="line">      currentAttributeOffset += attributeLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一个 .visit() 。让 ClassVisitor 的实现类处理当前类的版本号, 访问控制标志, 当前类, 结构, 父类, 接口</span></span><br><span class="line">    <span class="comment">// 具体 visit() 由实现类随意定制。例如，针对于那些有打印功能的访问者实现类，直接打印也不失为一种有效的访问操作</span></span><br><span class="line">    <span class="comment">// Visit the class declaration. The minor_version and major_version fields start 6 bytes before</span></span><br><span class="line">    <span class="comment">// the first constant pool entry, which itself starts at cpInfoOffsets[1] - 1 (by definition).</span></span><br><span class="line">    classVisitor.visit(</span><br><span class="line">        readInt(cpInfoOffsets[<span class="number">1</span>] - <span class="number">7</span>), accessFlags, thisClass, signature, superClass, interfaces);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问 SourceFile 和 SourceDebugExtenstion 属性</span></span><br><span class="line">    <span class="comment">// Visit the SourceFile and SourceDebugExtenstion attributes.</span></span><br><span class="line">    <span class="keyword">if</span> ((parsingOptions &amp; SKIP_DEBUG) == <span class="number">0</span></span><br><span class="line">        &amp;&amp; (sourceFile != <span class="keyword">null</span> || sourceDebugExtension != <span class="keyword">null</span>)) &#123;</span><br><span class="line">      classVisitor.visitSource(sourceFile, sourceDebugExtension);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the Module, ModulePackages and ModuleMainClass attributes.</span></span><br><span class="line">    <span class="keyword">if</span> (moduleOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      readModule(classVisitor, context, moduleOffset, modulePackagesOffset, moduleMainClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the NestHost attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (nestHostClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">      classVisitor.visitNestHostExperimental(nestHostClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the EnclosingMethod attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (enclosingMethodOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      String className = readClass(enclosingMethodOffset, charBuffer);</span><br><span class="line">      <span class="keyword">int</span> methodIndex = readUnsignedShort(enclosingMethodOffset + <span class="number">2</span>);</span><br><span class="line">      String name = methodIndex == <span class="number">0</span> ? <span class="keyword">null</span> : readUTF8(cpInfoOffsets[methodIndex], charBuffer);</span><br><span class="line">      String type = methodIndex == <span class="number">0</span> ? <span class="keyword">null</span> : readUTF8(cpInfoOffsets[methodIndex] + <span class="number">2</span>, charBuffer);</span><br><span class="line">      classVisitor.visitOuterClass(className, name, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the RuntimeVisibleAnnotations attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (runtimeVisibleAnnotationsOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numAnnotations = readUnsignedShort(runtimeVisibleAnnotationsOffset);</span><br><span class="line">      <span class="keyword">int</span> currentAnnotationOffset = runtimeVisibleAnnotationsOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numAnnotations-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Parse the type_index field.</span></span><br><span class="line">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span><br><span class="line">        currentAnnotationOffset += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span></span><br><span class="line">        currentAnnotationOffset =</span><br><span class="line">            readElementValues(</span><br><span class="line">                classVisitor.visitAnnotation(annotationDescriptor, <span class="comment">/* visible = */</span> <span class="keyword">true</span>),</span><br><span class="line">                currentAnnotationOffset,</span><br><span class="line">                <span class="comment">/* named = */</span> <span class="keyword">true</span>,</span><br><span class="line">                charBuffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the RuntimeInvisibleAnnotations attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (runtimeInvisibleAnnotationsOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numAnnotations = readUnsignedShort(runtimeInvisibleAnnotationsOffset);</span><br><span class="line">      <span class="keyword">int</span> currentAnnotationOffset = runtimeInvisibleAnnotationsOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numAnnotations-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Parse the type_index field.</span></span><br><span class="line">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span><br><span class="line">        currentAnnotationOffset += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span></span><br><span class="line">        currentAnnotationOffset =</span><br><span class="line">            readElementValues(</span><br><span class="line">                classVisitor.visitAnnotation(annotationDescriptor, <span class="comment">/* visible = */</span> <span class="keyword">false</span>),</span><br><span class="line">                currentAnnotationOffset,</span><br><span class="line">                <span class="comment">/* named = */</span> <span class="keyword">true</span>,</span><br><span class="line">                charBuffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the RuntimeVisibleTypeAnnotations attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (runtimeVisibleTypeAnnotationsOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numAnnotations = readUnsignedShort(runtimeVisibleTypeAnnotationsOffset);</span><br><span class="line">      <span class="keyword">int</span> currentAnnotationOffset = runtimeVisibleTypeAnnotationsOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numAnnotations-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Parse the target_type, target_info and target_path fields.</span></span><br><span class="line">        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span><br><span class="line">        <span class="comment">// Parse the type_index field.</span></span><br><span class="line">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span><br><span class="line">        currentAnnotationOffset += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span></span><br><span class="line">        currentAnnotationOffset =</span><br><span class="line">            readElementValues(</span><br><span class="line">                classVisitor.visitTypeAnnotation(</span><br><span class="line">                    context.currentTypeAnnotationTarget,</span><br><span class="line">                    context.currentTypeAnnotationTargetPath,</span><br><span class="line">                    annotationDescriptor,</span><br><span class="line">                    <span class="comment">/* visible = */</span> <span class="keyword">true</span>),</span><br><span class="line">                currentAnnotationOffset,</span><br><span class="line">                <span class="comment">/* named = */</span> <span class="keyword">true</span>,</span><br><span class="line">                charBuffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the RuntimeInvisibleTypeAnnotations attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (runtimeInvisibleTypeAnnotationsOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numAnnotations = readUnsignedShort(runtimeInvisibleTypeAnnotationsOffset);</span><br><span class="line">      <span class="keyword">int</span> currentAnnotationOffset = runtimeInvisibleTypeAnnotationsOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numAnnotations-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Parse the target_type, target_info and target_path fields.</span></span><br><span class="line">        currentAnnotationOffset = readTypeAnnotationTarget(context, currentAnnotationOffset);</span><br><span class="line">        <span class="comment">// Parse the type_index field.</span></span><br><span class="line">        String annotationDescriptor = readUTF8(currentAnnotationOffset, charBuffer);</span><br><span class="line">        currentAnnotationOffset += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// Parse num_element_value_pairs and element_value_pairs and visit these values.</span></span><br><span class="line">        currentAnnotationOffset =</span><br><span class="line">            readElementValues(</span><br><span class="line">                classVisitor.visitTypeAnnotation(</span><br><span class="line">                    context.currentTypeAnnotationTarget,</span><br><span class="line">                    context.currentTypeAnnotationTargetPath,</span><br><span class="line">                    annotationDescriptor,</span><br><span class="line">                    <span class="comment">/* visible = */</span> <span class="keyword">false</span>),</span><br><span class="line">                currentAnnotationOffset,</span><br><span class="line">                <span class="comment">/* named = */</span> <span class="keyword">true</span>,</span><br><span class="line">                charBuffer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问非标准的属性</span></span><br><span class="line">    <span class="comment">// Visit the non standard attributes.</span></span><br><span class="line">    <span class="keyword">while</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Copy and reset the nextAttribute field so that it can also be used in ClassWriter.</span></span><br><span class="line">      Attribute nextAttribute = attributes.nextAttribute;</span><br><span class="line">      attributes.nextAttribute = <span class="keyword">null</span>;</span><br><span class="line">      classVisitor.visitAttribute(attributes);</span><br><span class="line">      attributes = nextAttribute;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the NestedMembers attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (nestMembersOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numberOfNestMembers = readUnsignedShort(nestMembersOffset);</span><br><span class="line">      <span class="keyword">int</span> currentNestMemberOffset = nestMembersOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numberOfNestMembers-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        classVisitor.visitNestMemberExperimental(readClass(currentNestMemberOffset, charBuffer));</span><br><span class="line">        currentNestMemberOffset += <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the InnerClasses attribute.</span></span><br><span class="line">    <span class="keyword">if</span> (innerClassesOffset != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">int</span> numberOfClasses = readUnsignedShort(innerClassesOffset);</span><br><span class="line">      <span class="keyword">int</span> currentClassesOffset = innerClassesOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">while</span> (numberOfClasses-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        classVisitor.visitInnerClass(</span><br><span class="line">            readClass(currentClassesOffset, charBuffer),</span><br><span class="line">            readClass(currentClassesOffset + <span class="number">2</span>, charBuffer),</span><br><span class="line">            readUTF8(currentClassesOffset + <span class="number">4</span>, charBuffer),</span><br><span class="line">            readUnsignedShort(currentClassesOffset + <span class="number">6</span>));</span><br><span class="line">        currentClassesOffset += <span class="number">8</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问字段和方法</span></span><br><span class="line">    <span class="comment">// Visit the fields and methods.</span></span><br><span class="line">    <span class="keyword">int</span> fieldsCount = readUnsignedShort(currentOffset);</span><br><span class="line">    currentOffset += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (fieldsCount-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      currentOffset = readField(classVisitor, context, currentOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> methodsCount = readUnsignedShort(currentOffset);</span><br><span class="line">    currentOffset += <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (methodsCount-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      currentOffset = readMethod(classVisitor, context, currentOffset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Visit the end of the class.</span></span><br><span class="line">    classVisitor.visitEnd();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>其实，将整个 ClassReader 理解成一个对 .class 字节文件的解析器不失为一种可行的认知。</p><ol><li>在构造方法中完成对 .class 文件 minor_version, major_version 的确认。</li><li>继而完成对整个 Constants_pool 的解析</li><li>以及 BootstarpMethod 属性的定位</li><li>之后在 accept(…) 方法中逐一调用相应的访问者实现类实现对不同内容的访问。</li></ol><p>但是，要注意的是，ClassReader 绝对不会涉及到对其解析的 .class 文件内容的写操作。<br>所有的写操作都基于不同的目的，在 ClassVisitor 中实现。</p><h2 id="ClassVisitor"><a href="#ClassVisitor" class="headerlink" title="ClassVisitor"></a>ClassVisitor</h2><p>Java .class 的访问者，按照严格的顺序规范逐一调用 </p><p>visit<br>[ visitSource ] [ visitModule ][ visitNestHost ][ visitOuterClass ]<br>( visitAnnotation | visitTypeAnnotation | visitAttribute )<em><br>( visitNestMember | visitInnerClass | visitField | visitMethod )</em><br>visitEnd.</p><p>各个 visitXXX 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问类的首部</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> version, <span class="keyword">final</span> <span class="keyword">int</span> access, <span class="keyword">final</span> String name, <span class="keyword">final</span> String signature, <span class="keyword">final</span> String superName, <span class="keyword">final</span> String[] interfaces)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问类的源文件名等</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitSource</span><span class="params">(<span class="keyword">final</span> String source, <span class="keyword">final</span> String debug)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问与类关联的模块</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModuleVisitor <span class="title">visitModule</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">int</span> access, <span class="keyword">final</span> String version)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitOuterClass</span><span class="params">(<span class="keyword">final</span> String owner, <span class="keyword">final</span> String name, <span class="keyword">final</span> String descriptor)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(<span class="keyword">final</span> String descriptor, <span class="keyword">final</span> <span class="keyword">boolean</span> visible)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitTypeAnnotation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> typeRef, <span class="keyword">final</span> TypePath typePath, <span class="keyword">final</span> String descriptor, <span class="keyword">final</span> <span class="keyword">boolean</span> visible)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitAttribute</span><span class="params">(<span class="keyword">final</span> Attribute attribute)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInnerClass</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String name, <span class="keyword">final</span> String outerName, <span class="keyword">final</span> String innerName, <span class="keyword">final</span> <span class="keyword">int</span> access)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问类的变量</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FieldVisitor <span class="title">visitField</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> access,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String descriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> Object value)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 访问类的方法</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> <span class="keyword">int</span> access,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String descriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String signature,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String[] exceptions)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着 visitXxx() 方法的逐一执行，ClassVisitor 将对当前的 .class 文件越来越熟悉，并逐渐补全常量池(由 SymbolTable 持有并维护)</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此为止，对整个 ClassReader &amp; ClassVisitor 将有一个基础而简单的印象。</p><p>ClassReader 通过对 .class 文件字节码的解析而获得对这个类的具体印象(更多的偏向是随意访问 .class 的各种细节)。</p><p>ClassVisitor 通过 visitXxx(…) 方法，由其它对象(可以是 ClassReader, 也可以直接是 Coder)逐渐对其开放一些 .class 的细节，<br>但需要 ClassVisitor 自行维护获得的内容(如果有必要的话)。由此得到对 .class 全部内容的了解(当然，如果本身 visitXxx() 得到的内容不全，则了解的自然有限)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文描述的 ASM 指的是 OW2 ASM&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ASM-Core-的结构&quot;&gt;&lt;a href=&quot;#ASM-Core-的结构&quot; class=&quot;headerlink&quot; title=&quot;ASM-Core 的结构&quot;&gt;&lt;/a&gt;ASM-Core 的结构&lt;/h2&gt;&lt;p&gt;&lt;em&gt;首先是一些概述性的内容。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;由于 ASM 操作的 JAVA 字节码有严格的格式规定，且即使随着 JVM 标准的升级也极少出现重大调整。&lt;br&gt;因此适用面狭窄的访问者模式在该项目中被大量地使用，并且已经到了丧心病狂的程度:)&lt;/p&gt;
&lt;p&gt;从核心包声明的类来看，主要包括:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ClassReader - 作为结构化对象，将接收(accept)访问者的访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;几种访问者抽象类以及相应的实现类&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;AnnotationVisitor -&amp;gt; AnnotationWriter&lt;/li&gt;
&lt;li&gt;ClassVisitor -&amp;gt; ClassWriter&lt;/li&gt;
&lt;li&gt;FieldVisitor -&amp;gt; FieldWriter&lt;/li&gt;
&lt;li&gt;MethodVisitor -&amp;gt; MethodWriter&lt;/li&gt;
&lt;li&gt;ModuleVisitor -&amp;gt; ModuleWriter&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;p&gt;Opcodes &amp;amp; Constants - ClassFile 中描述的大量常量符号与值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其它一些辅助的类&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Attribute - 用于处理非标准化的属性(ClassFile 允许&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JVMS&lt;/a&gt; 中未定义的 Attribute)&lt;/li&gt;
&lt;li&gt;ByteArray - 动态可自适应的 byte[] (字节数组)&lt;/li&gt;
&lt;li&gt;Context - ClassReader 在被解析(被访问)过程中用于表示“累积状态”的一个类/对象&lt;/li&gt;
&lt;li&gt;Symbol - 用于表示 ClassFile 中描述的 Constant 的基类&lt;/li&gt;
&lt;li&gt;SymbolTable - 用于存储常量池对象&lt;/li&gt;
&lt;li&gt;其它内容省略&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="ASM" scheme="https://DorMOUSE-None.github.io/tags/ASM/"/>
    
      <category term="Visitor Pattern" scheme="https://DorMOUSE-None.github.io/tags/Visitor-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>java-memory-model</title>
    <link href="https://DorMOUSE-None.github.io/2018-06-21-java-memory-model/"/>
    <id>https://DorMOUSE-None.github.io/2018-06-21-java-memory-model/</id>
    <published>2018-06-20T16:00:00.000Z</published>
    <updated>2018-06-25T10:16:37.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM-运行时数据区"><a href="#JVM-运行时数据区" class="headerlink" title="JVM 运行时数据区"></a>JVM 运行时数据区</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                                                                            </span><br><span class="line">     线程独享                                    多线程共享                </span><br><span class="line">+--------------+                    +------------------------------------+  </span><br><span class="line">|              |                    |                                    | </span><br><span class="line">| +----------+ |                    |              方 法 区              /</span><br><span class="line">| | PC寄存器 | |                    |  +------------------------------+/ </span><br><span class="line">| +----------+ |        栈帧        |  |                              $       包括各接口和类的 .class 文件的字节码信息 </span><br><span class="line">|              |  +--------------+  |  |                              $       例如: Constants Pool, Fields, Methods, Attributes</span><br><span class="line">|   虚拟机栈   | /|              |  |  +------------------------------+\ </span><br><span class="line">| +----------+ |/ |  局部变量表  |  |                                    \</span><br><span class="line">| |          | /  | [][][][][][] |  |              JAVA 堆               |</span><br><span class="line">| +----------+/   |              |  |  +------------------------------+  |</span><br><span class="line">| $          $    |   操作数栈   |  |  |                              |  | </span><br><span class="line">| +----------+    | +----------+ |  |  |                              |  |</span><br><span class="line">| |          |\   | |          | |  |  |                              |  |</span><br><span class="line">| +----------+ \  | +----------+ |  |  |                              |  |</span><br><span class="line">|              |\ | |          | |  |  |                              |  |</span><br><span class="line">|  本地方法栈  | \| +----------+ |  |  |                              |  |</span><br><span class="line">| +----------+ |  |              |  |  |                              |  |</span><br><span class="line">| |          | |  | 运行时常量池 |  |  |                              |  |</span><br><span class="line">| +----------+ |  | [] 的引用    |  |  |                              |  |</span><br><span class="line">| |          | |  |              |  |  |                              |  |</span><br><span class="line">| +----------+ |  +--------------+  |  +------------------------------+  |</span><br><span class="line">|              |                    |                                    |</span><br><span class="line">+--------------+                    +------------------------------------+</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>与操作系统中的PC寄存器功能基本一致。毕竟 JVM 建立的初衷就是模拟一台机器。<br>指向存储在<strong>方法区</strong>的字节码methods_info部分的内存地址。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p><strong>虚拟机栈</strong>用于存储<strong>栈帧</strong></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>用于支持 native 方法的执行</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>存储在<strong>虚拟机栈</strong>中，主要包括<strong>局部变量表</strong>和<strong>操作数栈</strong>(又称<strong>当前栈帧的操作数栈</strong>)以及<strong>运行时常量池的引用</strong>。</p><p><em>仍然有必要区别两个概念: 操作数 &amp; 指令</em><br><em>指令指使操作数进行相关操作的基本命令</em><br><em>操作数通常指整数、浮点数以及类型引用等</em></p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>方法区</strong>是多个线程共享的一块区域，主要用于存储I/O操作中读入的类/接口的字节码(ClassFile 文件)<br>包括有 constant_pool, field_info, method_info, attribute_info 等</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>用于存储各种类的实例对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JVM-运行时数据区&quot;&gt;&lt;a href=&quot;#JVM-运行时数据区&quot; class=&quot;headerlink&quot; title=&quot;JVM 运行时数据区&quot;&gt;&lt;/a&gt;JVM 运行时数据区&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                                            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     线程独享                                    多线程共享                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+--------------+                    +------------------------------------+  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|              |                    |                                    | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| +----------+ |                    |              方 法 区              /&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| | PC寄存器 | |                    |  +------------------------------+/ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| +----------+ |        栈帧        |  |                              $       包括各接口和类的 .class 文件的字节码信息 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|              |  +--------------+  |  |                              $       例如: Constants Pool, Fields, Methods, Attributes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|   虚拟机栈   | /|              |  |  +------------------------------+\ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| +----------+ |/ |  局部变量表  |  |                                    \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| |          | /  | [][][][][][] |  |              JAVA 堆               |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| +----------+/   |              |  |  +------------------------------+  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| $          $    |   操作数栈   |  |  |                              |  | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| +----------+    | +----------+ |  |  |                              |  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| |          |\   | |          | |  |  |                              |  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| +----------+ \  | +----------+ |  |  |                              |  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|              |\ | |          | |  |  |                              |  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|  本地方法栈  | \| +----------+ |  |  |                              |  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| +----------+ |  |              |  |  |                              |  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| |          | |  | 运行时常量池 |  |  |                              |  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| +----------+ |  | [] 的引用    |  |  |                              |  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| |          | |  |              |  |  |                              |  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| +----------+ |  +--------------+  |  +------------------------------+  |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|              |                    |                                    |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+--------------+                    +------------------------------------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://DorMOUSE-None.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://DorMOUSE-None.github.io/tags/JVM/"/>
    
      <category term="Memory Model" scheme="https://DorMOUSE-None.github.io/tags/Memory-Model/"/>
    
  </entry>
  
  <entry>
    <title>ASM - ClassReader 与 Java ClassFile 文件格式</title>
    <link href="https://DorMOUSE-None.github.io/2018-06-11-ASM-ClassReader/"/>
    <id>https://DorMOUSE-None.github.io/2018-06-11-ASM-ClassReader/</id>
    <published>2018-06-10T16:00:00.000Z</published>
    <updated>2018-06-22T08:26:20.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-ClassFile-文件格式"><a href="#Java-ClassFile-文件格式" class="headerlink" title="Java ClassFile 文件格式"></a>Java ClassFile 文件格式</h2><p>读了将近一周的时间，勉强算是把 ClassFile 的文件格式给简单的梳理了个脉络。<br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">The class File Format(Java SE 8)</a> </p><blockquote><p>u1, u2, u4 分别表示无符号的一字节、二字节、四字节数据(以大端存储)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;                                   <span class="comment">// 魔数(magic) 固定为 0xCAFEBABE</span></span><br><span class="line">    u2             minor_version;                           <span class="comment">// 次版本号</span></span><br><span class="line">    u2             major_version;                           <span class="comment">// 主版本号</span></span><br><span class="line">    u2             constant_pool_count;                     <span class="comment">// 常量池 constant_pool 的数量 + 1, 最大为 (2&lt;&lt;16 - 1) = 65535</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count<span class="number">-1</span>];    <span class="comment">// 常量池 取值下标为 [1, constant_pool_count)</span></span><br><span class="line">    u2             access_flags;                            <span class="comment">// 对类 or 接口的访问权限和属性的标志的掩码</span></span><br><span class="line">    u2             this_class;                              <span class="comment">// 值为 constant_pool 的有效下标(且 constant_pool[this_class] 的类型为 CONSTANT_Class_info)</span></span><br><span class="line">    u2             super_class;                             <span class="comment">// 值为 0 或者 constant_pool 的有效下标(同上), 如果是 interface, 则该值一定为有效下标</span></span><br><span class="line">    u2             interfaces_count;                        <span class="comment">// 直接父接口的数量</span></span><br><span class="line">    u2             interfaces[interfaces_count];            <span class="comment">// 值必须是 constant_pool 的有效下标, 且 interfaces[i](0≤i&lt;interfaces_count), 指向的类型为 CONSTANT_Class_info)</span></span><br><span class="line">    u2             fields_count;                            <span class="comment">// 字段数量, 统计所有字段, 包括 class variables(静态变量) 和 instance variables(实例变量)</span></span><br><span class="line">    field_info     fields[fields_count];                    <span class="comment">// 字段的详细声明, 不包含继承来的字段</span></span><br><span class="line">    u2             methods_count;                           <span class="comment">// 方法数量</span></span><br><span class="line">    method_info    methods[methods_count];                  <span class="comment">// 方法的详细声明, 不包括继承来的方法</span></span><br><span class="line">    u2             attributes_count;                        <span class="comment">// 属性数量</span></span><br><span class="line">    attribute_info attributes[attributes_count];            <span class="comment">// 属性的详细声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>通过 <code>javac Xxx.java</code> 命令得到的 <code>Xxx.class</code> 文件严格按照定义的 ClassFile 文件格式以8比特的字节为单位进行存储。</p><p><strong>下面的例子都将通过 Trie.java (实际代码见本文最后) 以及其经编译后的文件 Trie.class 做基本的介绍。</strong></p><h3 id="magic-minor-verion-amp-major-version"><a href="#magic-minor-verion-amp-major-version" class="headerlink" title="magic, minor_verion &amp; major_version"></a>magic, minor_verion &amp; major_version</h3><p>通过命令 <code>xxd Trie.class</code> 查看 Trie.class 的十六进制编码，前16字节的内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.</span><br></pre></td></tr></table></figure></p><p>可以看到前4字节的内容 <code>0xcafebabe</code>，没有实际意义，但是作为其是能否被JVM(Java Virtual Machine, Java虚拟机)接收的Class文件的一个校验。</p><p>紧接着的4个字节包括<code>次版本号</code> 和 <code>主版本号</code>，暂时不做深入。</p><h3 id="常量池-constant-pool"><a href="#常量池-constant-pool" class="headerlink" title="常量池 constant_pool"></a>常量池 constant_pool</h3><p>从第10个字节开始(从第0字节开始计数)，连续的两个字节表示常量池中各种 CONSTANT 的总个数+1 (constant_pool_count)。constant_pool_count 只有2字节也就意味着: 常量池的最大常量数量为 (2&lt;&lt;16 - 1) = 65535 (当然，貌似在这个量级上，也从没见过有谁能够维护这样一个大JAVA类文件了)。</p><p>可以看到 constant_pool_count 的内容为 <code>0x008f = 143</code> ，即对于常量池的声明可以认为是 <code>cp_info constant_pool[142]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u1 info[]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 JDK 自带的 <code>javap</code> 来查看 <code>Trie.class</code> 文件(<code>javap -v Trie.class</code>)，可以对 cp_info 的格式有一个粗浅但形象化的认识(结果见<strong>附录2</strong>)<br>其中第一列的内容 <code>#? = ?</code> <code>#?</code>表示id，<code>= ?</code>表示一个 cp_info 的实际类型，有 <code>cp_info.tag</code> 指定，具体映射表为</p><table><thead><tr><th>Constant Type</th><th>Value</th></tr></thead><tbody><tr><td><code>CONSTANT_Class</code></td><td>7</td></tr><tr><td><code>CONSTANT_Fieldref</code></td><td>9</td></tr><tr><td><code>CONSTANT_Methodref</code></td><td>10</td></tr><tr><td><code>CONSTANT_InterfaceMethodref</code></td><td>11</td></tr><tr><td><code>CONSTANT_String</code></td><td>8</td></tr><tr><td><code>CONSTANT_Integer</code></td><td>3</td></tr><tr><td><code>CONSTANT_Float</code></td><td>4</td></tr><tr><td><code>CONSTANT_Long</code></td><td>5</td></tr><tr><td><code>CONSTANT_Double</code></td><td>6</td></tr><tr><td><code>CONSTANT_NameAndType</code></td><td>12</td></tr><tr><td><code>CONSTANT_Utf8</code></td><td>1</td></tr><tr><td><code>CONSTANT_MethodHandle</code></td><td>15</td></tr><tr><td><code>CONSTANT_MethodType</code></td><td>16</td></tr><tr><td><code>CONSTANT_InvokeDynamic</code></td><td>18</td></tr><tr><td><code>CONSTANT_Module</code></td><td>19</td></tr><tr><td><code>CONSTANT_Package</code></td><td>20</td></tr></tbody></table><p>在 Java ClassFile 的格式定义中，同时定义了每种 <code>CONSTANT</code> 的长度与格式。<br>例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Class_info &#123;</span><br><span class="line">    u1 tag;</span><br><span class="line">    u2 name_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CONSTANT_Fieldref_info &#123;</span><br><span class="line">     u1 tag;</span><br><span class="line">     u2 class_index;</span><br><span class="line">     u2 name_and_type_index;</span><br><span class="line">&#125;</span><br><span class="line">CONSTANT_Methodref_info &#123;</span><br><span class="line">  u1 tag;</span><br><span class="line">  u2 class_index;</span><br><span class="line">  u2 name_and_type_index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的 <code>CONSTANT_XXX</code> 的格式定义见 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4" target="_blank" rel="noopener">ClassFile CONSTANT_XXX 结构</a></p><p>简单解析一下 cp_info[1]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000: cafe babe 0000 0034 008f 0a00 2400 4b09  .......4....$.K.</span><br><span class="line"></span><br><span class="line">#1 = Methodref          #36.#75       // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br></pre></td></tr></table></figure></p><p><code>cp_info[1].tag = 0x0a = 10</code>，即 cp_info[1] 的类型为 Methodref 。<br>之后就直接套用 <code>CONSTANT_Methodref_info</code> 的数据结构定义的格式<br><code>cp_info[1].class_index = 0x0024 = 36</code>，即 cp_info[1].class_index 表示的类名指向常量池第 36 个元素表示的类<br><code>cp_info[1].name_and_type_index = 0x004b = 75</code>。表示指向的是常量池第 75 个元素表示的 NameAndType 结构</p><p>对于这部分内容的理解，如果觉得有能够阅读英文文档，可以参考 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">The Java® Virtual Machine Specification Chap 4.</a><br>否则，可以选择 <a href="http://icyfenix.iteye.com/blog/1256329" target="_blank" rel="noopener">Java 虚拟机规范(Java SE 7 版) 第四章</a><br>并尝试根据经编译后.class文件的二进制码进行人工解析，以加深对此的理解。</p><h3 id="more…"><a href="#more…" class="headerlink" title="more…"></a>more…</h3><p>更多内容于此基本类似，均属于已经被严格预定义的规范化格式，对此进行解析即可得到相应的内容。</p><h2 id="ASM-概览"><a href="#ASM-概览" class="headerlink" title="ASM 概览"></a>ASM 概览</h2><h3 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h3><p>asm, asm-analysis, asm-commons, asm-tree, asm-util, asm-xml 模块基于 Maven 的组织形式，并包含有单元测试的内容。</p><p>asm-test 实现了对上述模块的单元测试的整合。</p><p>benchmarks 定义了一些基本的 JMH 基准测试来衡量ASM的表现</p><p>gradle 包含了一些 Gradle 包装器，来辅助 Linux or Windows 脚本的调用请求</p><p>tools 包含两个 Gradle 项目来帮助 ASM 生成 Artifacts 。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1frywra01upj308g0akmxr.jpg" alt="ASM Structure"></p><h3 id="代码组织形式"><a href="#代码组织形式" class="headerlink" title="代码组织形式"></a>代码组织形式</h3><p><img src="http://asm.ow2.io/asm-package-dependencies.svg" alt="Code Organization"></p><ul><li>org.objectweb.asm 作为核心包，定义了 ASM 访问者 API 以及两个核心类 ClassReader &amp; ClassWriter 来读写编译后的 Java 类。该包不依赖于其他包，且可单独使用</li><li>org.objectweb.asm.signature 提供了读写泛型签名的 API</li><li>org.objectweb.asm.tree 提供了类 DOM API 与类 SAX API。</li><li>org.objectweb.asm.tree.analysis 基于 .tree 提供了静态字节码分析框架</li><li>org.objectweb.asm.commons 提供了一些基于 core 和 tree 包的类适配器。</li><li>org.objectweb.asm.util 提供了一些用于 DEBUG 的访问者类与适配器类</li><li>org.objectweb.asm.xml 目前已经被 @Deprecated 。提供了类文件与 XML 互相转换的能力</li></ul><p>综上，asm 核心包是最为复杂的一个模块，而其它诸如 tree, util, xml 等都只是提供了将 JAVA 类从一种高级表示形态转换为另一种的能力。signature 也相当简单，提供了解析和打印简单语法的能力。</p><h3 id="主要数据结构"><a href="#主要数据结构" class="headerlink" title="主要数据结构"></a>主要数据结构</h3><p>核心包由 28 个类(接口) 组成。如果不考虑 Opcodes 接口, 5 个抽象访问者类(AnnotationVistitor, ClassVisitor, FieldVisitor, MethodVisitor and ModuleVisitor), 6 个工具类(ConstantDynamic, Contants, Handle, Type, TypePath and TypeReference), 剩下 16 个类的由下图提供一个粗略的展示。</p><p><img src="http://asm.ow2.io/asm-package-overview.svg" alt=""></p><p>编译类到访问事件的转换只由一个类 ClassReader 以及辅助类 Context 完成。其逆过程由以 ClassWriter 为核心的其它 14 个类完成。</p><h3 id="ClassReader"><a href="#ClassReader" class="headerlink" title="ClassReader"></a>ClassReader</h3><p>ClassReader 作为 ASM 核心包解析现有 .class 的唯一工具，组织形式相当简单。</p><ul><li>在构造函数中完成对常量池和引导方法的解析<ul><li>存储每个常量池项目的起始偏移量 cpInfoOffsets</li><li>存储每个引导方法的起始偏移量 bootstrapMethodOffsets</li><li>存储最长字符串常量的大小 maxStringLength</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">ClassReader(<span class="keyword">final</span> <span class="keyword">byte</span>[] classFileBuffer, <span class="keyword">final</span> <span class="keyword">int</span> classFileOffset, <span class="keyword">final</span> <span class="keyword">boolean</span> checkClassVersion) &#123;</span><br><span class="line">  <span class="keyword">this</span>.b = classFileBuffer;   <span class="comment">// .class 文件缓存</span></span><br><span class="line">  <span class="comment">// 检查主版本号, 第6,7个字节(从0字节开始计数)</span></span><br><span class="line">  <span class="keyword">if</span> (checkClassVersion &amp;&amp; readShort(classFileOffset + <span class="number">6</span>) &gt; Opcodes.V11) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">        <span class="string">"Unsupported class file major version "</span> + readShort(classFileOffset + <span class="number">6</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建常量池数组，常量池长度的定义 constant_pool_count 在第8,9字节</span></span><br><span class="line">  <span class="keyword">int</span> constantPoolCount = readUnsignedShort(classFileOffset + <span class="number">8</span>);     <span class="comment">// 读取无符号short, 即读取连续两字节作为一个short值</span></span><br><span class="line">  cpInfoOffsets = <span class="keyword">new</span> <span class="keyword">int</span>[constantPoolCount];                         <span class="comment">// 每个常量的偏移位置</span></span><br><span class="line">  cpInfoValues = <span class="keyword">new</span> Object[constantPoolCount];                       <span class="comment">// 每个常量的实例对象</span></span><br><span class="line">  <span class="keyword">int</span> currentCpInfoIndex = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> currentCpInfoOffset = classFileOffset + <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> currentMaxStringLength = <span class="number">0</span>;                                     <span class="comment">// 最长字符串常量</span></span><br><span class="line">  <span class="keyword">while</span> (currentCpInfoIndex &lt; constantPoolCount) &#123;</span><br><span class="line">    cpInfoOffsets[currentCpInfoIndex++] = currentCpInfoOffset + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cpInfoSize;</span><br><span class="line">    <span class="keyword">switch</span> (classFileBuffer[currentCpInfoOffset]) &#123;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_FIELDREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHODREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INTERFACE_METHODREF_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INTEGER_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_FLOAT_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_NAME_AND_TYPE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_INVOKE_DYNAMIC_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_DYNAMIC_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_LONG_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_DOUBLE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">9</span>;</span><br><span class="line">        currentCpInfoIndex++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_UTF8_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">3</span> + readUnsignedShort(currentCpInfoOffset + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (cpInfoSize &gt; currentMaxStringLength) &#123;</span><br><span class="line">          <span class="comment">// The size in bytes of this CONSTANT_Utf8 structure provides a conservative estimate</span></span><br><span class="line">          <span class="comment">// of the length in characters of the corresponding string, and is much cheaper to</span></span><br><span class="line">          <span class="comment">// compute than this exact length.</span></span><br><span class="line">          currentMaxStringLength = cpInfoSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHOD_HANDLE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_CLASS_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_STRING_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_METHOD_TYPE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_PACKAGE_TAG:</span><br><span class="line">      <span class="keyword">case</span> Symbol.CONSTANT_MODULE_TAG:</span><br><span class="line">        cpInfoSize = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    currentCpInfoOffset += cpInfoSize;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.maxStringLength = currentMaxStringLength;</span><br><span class="line">  <span class="comment">// The Classfile's access_flags field is just after the last constant pool entry.</span></span><br><span class="line">  <span class="keyword">this</span>.header = currentCpInfoOffset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 BootstrapMethods 属性(如果存在)</span></span><br><span class="line">  <span class="keyword">int</span> currentAttributeOffset = getFirstAttributeOffset();</span><br><span class="line">  <span class="keyword">int</span>[] currentBootstrapMethodOffsets = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = readUnsignedShort(currentAttributeOffset - <span class="number">2</span>); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="comment">// 读取每个 attribute_info 的属性名和属性长度</span></span><br><span class="line">    String attributeName = readUTF8(currentAttributeOffset, <span class="keyword">new</span> <span class="keyword">char</span>[maxStringLength]);</span><br><span class="line">    <span class="keyword">int</span> attributeLength = readInt(currentAttributeOffset + <span class="number">2</span>);</span><br><span class="line">    currentAttributeOffset += <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 如果当前属性名为 BootstrapMethods ，则进入处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (Constants.BOOTSTRAP_METHODS.equals(attributeName)) &#123;</span><br><span class="line">      <span class="comment">// Read the num_bootstrap_methods field and create an array of this size.</span></span><br><span class="line">      currentBootstrapMethodOffsets = <span class="keyword">new</span> <span class="keyword">int</span>[readUnsignedShort(currentAttributeOffset)];</span><br><span class="line">      <span class="comment">// Compute and store the offset of each 'bootstrap_methods' array field entry.</span></span><br><span class="line">      <span class="keyword">int</span> currentBootstrapMethodOffset = currentAttributeOffset + <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; currentBootstrapMethodOffsets.length; ++j) &#123;</span><br><span class="line">        currentBootstrapMethodOffsets[j] = currentBootstrapMethodOffset;</span><br><span class="line">        <span class="comment">// Skip the bootstrap_method_ref and num_bootstrap_arguments fields (2 bytes each),</span></span><br><span class="line">        <span class="comment">// as well as the bootstrap_arguments array field (of size num_bootstrap_arguments * 2).</span></span><br><span class="line">        currentBootstrapMethodOffset +=</span><br><span class="line">            <span class="number">4</span> + readUnsignedShort(currentBootstrapMethodOffset + <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    currentAttributeOffset += attributeLength;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.bootstrapMethodOffsets = currentBootstrapMethodOffsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，ClassReader 已经解析了包括 magic, minor version, major version, constant pool 。<br>但是，诸如 field_info, method_info, attribute_info 等仍然没有得到处理。</p><p>这部分的内容在 accept(…) 和 readXXX(…) 中将得到解析。</p><p>主要流程类似:</p><ol><li>读取当前内容的偏移量(相较于整个 byte[])</li><li>解析当前的内容</li><li>调用 visitXXX 方法</li><li>在 visitXXX 方法中进行相关的处理</li><li>visitEnd</li></ol><h2 id="附录1-Trie-java"><a href="#附录1-Trie-java" class="headerlink" title="附录1 Trie.java"></a>附录1 Trie.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fangfeng.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangfeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/5/16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_ITEM = <span class="number">700000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> AVG_LENGTH = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_NODE = MAX_ITEM * AVG_LENGTH;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> CHAR_NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] nxt = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_NODE][CHAR_NUM];</span><br><span class="line">    <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_NODE];</span><br><span class="line">    <span class="keyword">int</span> trieIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmpIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;number != <span class="number">0</span>;number /= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)] == <span class="number">0</span>) &#123;</span><br><span class="line">                nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)] = ++trieIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpIndex = nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        flag[tmpIndex] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">query</span><span class="params">(<span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmpIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;number != <span class="number">0</span>;number /= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpIndex = nxt[tmpIndex][(<span class="keyword">int</span>) (number % <span class="number">10</span>)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag[tmpIndex];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        String ruleFilePath = args[<span class="number">0</span>];</span><br><span class="line">        String sendFilePath = args[<span class="number">1</span>];</span><br><span class="line">        String outFilePath = args[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        BufferedReader ruleReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(ruleFilePath)));</span><br><span class="line">        BufferedReader sendReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(sendFilePath)));</span><br><span class="line"></span><br><span class="line">        BufferedWriter outWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(outFilePath)));</span><br><span class="line"></span><br><span class="line">        Trie trie = <span class="keyword">new</span> Trie();</span><br><span class="line">        String mobile;</span><br><span class="line">        <span class="keyword">while</span>((mobile = ruleReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            trie.insert(Long.parseLong(mobile));</span><br><span class="line">        &#125;</span><br><span class="line">        ruleReader.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((mobile = sendReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(trie.query(Long.parseLong(mobile)) == <span class="keyword">false</span>) &#123;</span><br><span class="line">                outWriter.write(mobile);</span><br><span class="line">                outWriter.newLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sendReader.close();</span><br><span class="line"></span><br><span class="line">        outWriter.flush();</span><br><span class="line">        outWriter.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(String.format(<span class="string">"exec success! used %d ms"</span>, end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录2-Constant-pool"><a href="#附录2-Constant-pool" class="headerlink" title="附录2 Constant pool"></a>附录2 Constant pool</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">    #1 = Methodref          #36.#75       // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    #2 = Fieldref           #23.#76       // me/fangfeng/filter/Trie.MAX_NODE:I</span><br><span class="line">    #3 = Fieldref           #23.#77       // me/fangfeng/filter/Trie.CHAR_NUM:I</span><br><span class="line">    #4 = Class              #49           // &quot;[[I&quot;</span><br><span class="line">    #5 = Fieldref           #23.#78       // me/fangfeng/filter/Trie.nxt:[[I</span><br><span class="line">    #6 = Fieldref           #23.#79       // me/fangfeng/filter/Trie.flag:[Z</span><br><span class="line">    #7 = Fieldref           #23.#80       // me/fangfeng/filter/Trie.trieIndex:I</span><br><span class="line">    #8 = Long               10l</span><br><span class="line">   #10 = Methodref          #81.#82       // java/lang/System.currentTimeMillis:()J</span><br><span class="line">   #11 = Class              #83           // java/io/BufferedReader</span><br><span class="line">   #12 = Class              #84           // java/io/InputStreamReader</span><br><span class="line">   #13 = Class              #85           // java/io/FileInputStream</span><br><span class="line">   #14 = Methodref          #13.#86       // java/io/FileInputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">   #15 = Methodref          #12.#87       // java/io/InputStreamReader.&quot;&lt;init&gt;&quot;:(Ljava/io/InputStream;)V</span><br><span class="line">   #16 = Methodref          #11.#88       // java/io/BufferedReader.&quot;&lt;init&gt;&quot;:(Ljava/io/Reader;)V</span><br><span class="line">   #17 = Class              #89           // java/io/BufferedWriter</span><br><span class="line">   #18 = Class              #90           // java/io/OutputStreamWriter</span><br><span class="line">   #19 = Class              #91           // java/io/FileOutputStream</span><br><span class="line">   #20 = Methodref          #19.#86       // java/io/FileOutputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">   #21 = Methodref          #18.#92       // java/io/OutputStreamWriter.&quot;&lt;init&gt;&quot;:(Ljava/io/OutputStream;)V</span><br><span class="line">   #22 = Methodref          #17.#93       // java/io/BufferedWriter.&quot;&lt;init&gt;&quot;:(Ljava/io/Writer;)V</span><br><span class="line">   #23 = Class              #94           // me/fangfeng/filter/Trie</span><br><span class="line">   #24 = Methodref          #23.#75       // me/fangfeng/filter/Trie.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #25 = Methodref          #11.#95       // java/io/BufferedReader.readLine:()Ljava/lang/String;</span><br><span class="line">   #26 = Methodref          #96.#97       // java/lang/Long.parseLong:(Ljava/lang/String;)J</span><br><span class="line">   #27 = Methodref          #23.#98       // me/fangfeng/filter/Trie.insert:(J)V</span><br><span class="line">   #28 = Methodref          #11.#99       // java/io/BufferedReader.close:()V</span><br><span class="line">   #29 = Methodref          #23.#100      // me/fangfeng/filter/Trie.query:(J)Z</span><br><span class="line">   #30 = Methodref          #17.#101      // java/io/BufferedWriter.write:(Ljava/lang/String;)V</span><br><span class="line">   #31 = Methodref          #17.#102      // java/io/BufferedWriter.newLine:()V</span><br><span class="line">   #32 = Methodref          #17.#103      // java/io/BufferedWriter.flush:()V</span><br><span class="line">   #33 = Methodref          #17.#99       // java/io/BufferedWriter.close:()V</span><br><span class="line">   #34 = Fieldref           #81.#104      // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #35 = String             #105          // exec success! used %d ms</span><br><span class="line">   #36 = Class              #106          // java/lang/Object</span><br><span class="line">   #37 = Methodref          #96.#107      // java/lang/Long.valueOf:(J)Ljava/lang/Long;</span><br><span class="line">   #38 = Methodref          #108.#109     // java/lang/String.format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">   #39 = Methodref          #110.#111     // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #40 = Integer            700000</span><br><span class="line">   #41 = Fieldref           #23.#112      // me/fangfeng/filter/Trie.MAX_ITEM:I</span><br><span class="line">   #42 = Fieldref           #23.#113      // me/fangfeng/filter/Trie.AVG_LENGTH:I</span><br><span class="line">   #43 = Utf8               MAX_ITEM</span><br><span class="line">   #44 = Utf8               I</span><br><span class="line">   #45 = Utf8               AVG_LENGTH</span><br><span class="line">   #46 = Utf8               MAX_NODE</span><br><span class="line">   #47 = Utf8               CHAR_NUM</span><br><span class="line">   #48 = Utf8               nxt</span><br><span class="line">   #49 = Utf8               [[I</span><br><span class="line">   #50 = Utf8               flag</span><br><span class="line">   #51 = Utf8               [Z</span><br><span class="line">   #52 = Utf8               trieIndex</span><br><span class="line">   #53 = Utf8               &lt;init&gt;</span><br><span class="line">   #54 = Utf8               ()V</span><br><span class="line">   #55 = Utf8               Code</span><br><span class="line">   #56 = Utf8               LineNumberTable</span><br><span class="line">   #57 = Utf8               insert</span><br><span class="line">   #58 = Utf8               (J)V</span><br><span class="line">   #59 = Utf8               StackMapTable</span><br><span class="line">   #60 = Utf8               query</span><br><span class="line">   #61 = Utf8               (J)Z</span><br><span class="line">   #62 = Utf8               main</span><br><span class="line">   #63 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">   #64 = Class              #114          // &quot;[Ljava/lang/String;&quot;</span><br><span class="line">   #65 = Class              #115          // java/lang/String</span><br><span class="line">   #66 = Class              #83           // java/io/BufferedReader</span><br><span class="line">   #67 = Class              #89           // java/io/BufferedWriter</span><br><span class="line">   #68 = Class              #94           // me/fangfeng/filter/Trie</span><br><span class="line">   #69 = Utf8               Exceptions</span><br><span class="line">   #70 = Class              #116          // java/io/FileNotFoundException</span><br><span class="line">   #71 = Class              #117          // java/io/IOException</span><br><span class="line">   #72 = Utf8               &lt;clinit&gt;</span><br><span class="line">   #73 = Utf8               SourceFile</span><br><span class="line">   #74 = Utf8               Trie.java</span><br><span class="line">   #75 = NameAndType        #53:#54       // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #76 = NameAndType        #46:#44       // MAX_NODE:I</span><br><span class="line">   #77 = NameAndType        #47:#44       // CHAR_NUM:I</span><br><span class="line">   #78 = NameAndType        #48:#49       // nxt:[[I</span><br><span class="line">   #79 = NameAndType        #50:#51       // flag:[Z</span><br><span class="line">   #80 = NameAndType        #52:#44       // trieIndex:I</span><br><span class="line">   #81 = Class              #118          // java/lang/System</span><br><span class="line">   #82 = NameAndType        #119:#120     // currentTimeMillis:()J</span><br><span class="line">   #83 = Utf8               java/io/BufferedReader</span><br><span class="line">   #84 = Utf8               java/io/InputStreamReader</span><br><span class="line">   #85 = Utf8               java/io/FileInputStream</span><br><span class="line">   #86 = NameAndType        #53:#121      // &quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">   #87 = NameAndType        #53:#122      // &quot;&lt;init&gt;&quot;:(Ljava/io/InputStream;)V</span><br><span class="line">   #88 = NameAndType        #53:#123      // &quot;&lt;init&gt;&quot;:(Ljava/io/Reader;)V</span><br><span class="line">   #89 = Utf8               java/io/BufferedWriter</span><br><span class="line">   #90 = Utf8               java/io/OutputStreamWriter</span><br><span class="line">   #91 = Utf8               java/io/FileOutputStream</span><br><span class="line">   #92 = NameAndType        #53:#124      // &quot;&lt;init&gt;&quot;:(Ljava/io/OutputStream;)V</span><br><span class="line">   #93 = NameAndType        #53:#125      // &quot;&lt;init&gt;&quot;:(Ljava/io/Writer;)V</span><br><span class="line">   #94 = Utf8               me/fangfeng/filter/Trie</span><br><span class="line">   #95 = NameAndType        #126:#127     // readLine:()Ljava/lang/String;</span><br><span class="line">   #96 = Class              #128          // java/lang/Long</span><br><span class="line">   #97 = NameAndType        #129:#130     // parseLong:(Ljava/lang/String;)J</span><br><span class="line">   #98 = NameAndType        #57:#58       // insert:(J)V</span><br><span class="line">   #99 = NameAndType        #131:#54      // close:()V</span><br><span class="line">  #100 = NameAndType        #60:#61       // query:(J)Z</span><br><span class="line">  #101 = NameAndType        #132:#121     // write:(Ljava/lang/String;)V</span><br><span class="line">  #102 = NameAndType        #133:#54      // newLine:()V</span><br><span class="line">  #103 = NameAndType        #134:#54      // flush:()V</span><br><span class="line">  #104 = NameAndType        #135:#136     // out:Ljava/io/PrintStream;</span><br><span class="line">  #105 = Utf8               exec success! used %d ms</span><br><span class="line">  #106 = Utf8               java/lang/Object</span><br><span class="line">  #107 = NameAndType        #137:#138     // valueOf:(J)Ljava/lang/Long;</span><br><span class="line">  #108 = Class              #115          // java/lang/String</span><br><span class="line">  #109 = NameAndType        #139:#140     // format:(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">  #110 = Class              #141          // java/io/PrintStream</span><br><span class="line">  #111 = NameAndType        #142:#121     // println:(Ljava/lang/String;)V</span><br><span class="line">  #112 = NameAndType        #43:#44       // MAX_ITEM:I</span><br><span class="line">  #113 = NameAndType        #45:#44       // AVG_LENGTH:I</span><br><span class="line">  #114 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #115 = Utf8               java/lang/String</span><br><span class="line">  #116 = Utf8               java/io/FileNotFoundException</span><br><span class="line">  #117 = Utf8               java/io/IOException</span><br><span class="line">  #118 = Utf8               java/lang/System</span><br><span class="line">  #119 = Utf8               currentTimeMillis</span><br><span class="line">  #120 = Utf8               ()J</span><br><span class="line">  #121 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #122 = Utf8               (Ljava/io/InputStream;)V</span><br><span class="line">  #123 = Utf8               (Ljava/io/Reader;)V</span><br><span class="line">  #124 = Utf8               (Ljava/io/OutputStream;)V</span><br><span class="line">  #125 = Utf8               (Ljava/io/Writer;)V</span><br><span class="line">  #126 = Utf8               readLine</span><br><span class="line">  #127 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #128 = Utf8               java/lang/Long</span><br><span class="line">  #129 = Utf8               parseLong</span><br><span class="line">  #130 = Utf8               (Ljava/lang/String;)J</span><br><span class="line">  #131 = Utf8               close</span><br><span class="line">  #132 = Utf8               write</span><br><span class="line">  #133 = Utf8               newLine</span><br><span class="line">  #134 = Utf8               flush</span><br><span class="line">  #135 = Utf8               out</span><br><span class="line">  #136 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #137 = Utf8               valueOf</span><br><span class="line">  #138 = Utf8               (J)Ljava/lang/Long;</span><br><span class="line">  #139 = Utf8               format</span><br><span class="line">  #140 = Utf8               (Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;</span><br><span class="line">  #141 = Utf8               java/io/PrintStream</span><br><span class="line">  #142 = Utf8               println</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1]: <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a> “Java Virtual Machine Specification”<br>[2]: <a href="http://icyfenix.iteye.com/blog/1256329" target="_blank" rel="noopener">http://icyfenix.iteye.com/blog/1256329</a> “Java虚拟机规范（Java SE 7 中文版）”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java-ClassFile-文件格式&quot;&gt;&lt;a href=&quot;#Java-ClassFile-文件格式&quot; class=&quot;headerlink&quot; title=&quot;Java ClassFile 文件格式&quot;&gt;&lt;/a&gt;Java ClassFile 文件格式&lt;/h2&gt;&lt;p&gt;读了将近一周的时间，勉强算是把 ClassFile 的文件格式给简单的梳理了个脉络。&lt;br&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The class File Format(Java SE 8)&lt;/a&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;u1, u2, u4 分别表示无符号的一字节、二字节、四字节数据(以大端存储)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ClassFile &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u4             magic;                                   &lt;span class=&quot;comment&quot;&gt;// 魔数(magic) 固定为 0xCAFEBABE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             minor_version;                           &lt;span class=&quot;comment&quot;&gt;// 次版本号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             major_version;                           &lt;span class=&quot;comment&quot;&gt;// 主版本号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             constant_pool_count;                     &lt;span class=&quot;comment&quot;&gt;// 常量池 constant_pool 的数量 + 1, 最大为 (2&amp;lt;&amp;lt;16 - 1) = 65535&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cp_info        constant_pool[constant_pool_count&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;];    &lt;span class=&quot;comment&quot;&gt;// 常量池 取值下标为 [1, constant_pool_count)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             access_flags;                            &lt;span class=&quot;comment&quot;&gt;// 对类 or 接口的访问权限和属性的标志的掩码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             this_class;                              &lt;span class=&quot;comment&quot;&gt;// 值为 constant_pool 的有效下标(且 constant_pool[this_class] 的类型为 CONSTANT_Class_info)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             super_class;                             &lt;span class=&quot;comment&quot;&gt;// 值为 0 或者 constant_pool 的有效下标(同上), 如果是 interface, 则该值一定为有效下标&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             interfaces_count;                        &lt;span class=&quot;comment&quot;&gt;// 直接父接口的数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             interfaces[interfaces_count];            &lt;span class=&quot;comment&quot;&gt;// 值必须是 constant_pool 的有效下标, 且 interfaces[i](0≤i&amp;lt;interfaces_count), 指向的类型为 CONSTANT_Class_info)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             fields_count;                            &lt;span class=&quot;comment&quot;&gt;// 字段数量, 统计所有字段, 包括 class variables(静态变量) 和 instance variables(实例变量)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    field_info     fields[fields_count];                    &lt;span class=&quot;comment&quot;&gt;// 字段的详细声明, 不包含继承来的字段&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             methods_count;                           &lt;span class=&quot;comment&quot;&gt;// 方法数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    method_info    methods[methods_count];                  &lt;span class=&quot;comment&quot;&gt;// 方法的详细声明, 不包括继承来的方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    u2             attributes_count;                        &lt;span class=&quot;comment&quot;&gt;// 属性数量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    attribute_info attributes[attributes_count];            &lt;span class=&quot;comment&quot;&gt;// 属性的详细声明&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>区块链技术概述</title>
    <link href="https://DorMOUSE-None.github.io/2018-03-01-%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://DorMOUSE-None.github.io/2018-03-01-区块链简单介绍/</id>
    <published>2018-02-28T16:00:00.000Z</published>
    <updated>2018-06-14T01:24:24.421Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg" alt="区块链简单结构"></p><center><small>图1. 区块链简单结构</small></center><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg" alt="Merkle tree"></p><center><small>图2. 单个区块的抽象结构</small></center><a id="more"></a><h2 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h2><h3 id="新交易发起流程"><a href="#新交易发起流程" class="headerlink" title="新交易发起流程"></a>新交易发起流程</h3><ol><li>用户通过公/私钥与区块链网络进行交互</li><li>处理用户交易的节点向网络邻节点广播用户交易</li><li>邻节点验证交易的有效性；可信，继续向其它邻节点广播；不可信，丢弃。</li></ol><h3 id="新区块产生流程"><a href="#新区块产生流程" class="headerlink" title="新区块产生流程"></a>新区块产生流程</h3><ol><li>矿工尝试将一个时间区间内的交易进行打包形成新区块（怎么打包，看下文）</li><li>生产出新区块的矿工节点向网络广播新区块</li><li>收到新区块的网络节点验证该区块的有效性</li></ol><p><a href="https://blockchain.info/zh-cn" target="_blank" rel="noopener">比特币区块浏览器</a>      更多<a href="https://en.wikipedia.org/wiki/Metric_prefix" target="_blank" rel="noopener">国际单位制前缀</a></p><h2 id="网络共识"><a href="#网络共识" class="headerlink" title="网络共识"></a>网络共识</h2><p>所有区块链网络节点需要对交易以及其在新区块里面的顺序达成一致（交易的有效性以及交易的打包顺序）。</p><p>可能出现：</p><ul><li>女巫攻击——单一实体以多重身份重复对新区块结果进行表决（少数人抓住了网络的投票权）</li><li><a href="https://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">拜占庭将军问题</a>——分布式对等网络的通信容错问题<ul><li>不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动<ul><li>成员计算机可能出错而发送错误信息</li><li>网络的不可靠性</li><li>从而影响网络共识的达成，破坏一致性。</li></ul></li><li>不解决的话可能导致——区块链分叉</li></ul></li></ul><p>解决方案：</p><ul><li>工作量证明（proof-of-work, PoW），权益证明(proof-of-stake, PoS)，白名单机制（仅适用于私有网络）等</li><li>实用拜占庭容错算法</li></ul><h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><p>网络共识机制的实现导致了：</p><ol><li>交易吞吐量</li><li>更高的交易时延。交易确认时间（只有打包的新区块中才交易才会被承认）。</li></ol><p>共识机制的伸缩可以一定程度上解决上述问题</p><h2 id="资产交易"><a href="#资产交易" class="headerlink" title="资产交易"></a>资产交易</h2><p>简单交易状态描述，以集中式数据库为例</p><p>假设初始状态为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-------------------------</span><br><span class="line">| 资产类型 | 所有者 | 数量 |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  防风  |  10 |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  红薯  |  0  |</span><br><span class="line">-------------------------</span><br></pre></td></tr></table></figure><p>防风 向 红薯 转账 2 CNY </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-------------------------</span><br><span class="line">| 资产类型 | 所有者 | 数量 |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  防风  |  8  |</span><br><span class="line">-------------------------</span><br><span class="line">|   CNY   |  红薯  |  2  |</span><br><span class="line">-------------------------</span><br></pre></td></tr></table></figure><p>数据库中相应记录的更改完成了资产的交易过程。</p><p>在区块链中，仍然将分布式链看作是一个达成共识的集中式数据库</p><p>那么现在的初始状态可以表示成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------</span><br><span class="line">| 资产类型 |     所有者     | 数量 |</span><br><span class="line">---------------------------------</span><br><span class="line">|   IOTA  |  防风 pub_key  | 10  |</span><br><span class="line">---------------------------------</span><br></pre></td></tr></table></figure><p>现在的所有者由公钥表示，想要修改记录必须提供对应的密钥。</p><p>例如，防风 向 红薯 转账 2 IOTA ，需要提供防风的私钥和红薯的公钥。交易记录修改结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------</span><br><span class="line">| 资产类型 |     所有者     | 数量 |</span><br><span class="line">---------------------------------</span><br><span class="line">                                 被删除了         |   IOTA  |  防风 pub_key  | 10  |</span><br><span class="line">---------------------------------</span><br><span class="line">|   IOTA  |  红薯 pub_key  |  2  |</span><br><span class="line">---------------------------------</span><br><span class="line">|   IOTA  |  防风 pub_key  |  8  |</span><br></pre></td></tr></table></figure><p>交易的概念流程：</p><ol><li>定位防风所有的资产记录行</li><li>删除该行前验证密钥</li><li>确认该记录没有被别的交易使用（双花问题，双重交易）</li><li>写入新的正确的记录（红薯获得的资产 &amp; 防风剩余的资产），确保交易前与交易后资产总额不变</li></ol><p>上面的模型 —— 基于比特币的交易模型(UTXO <em>model</em>)</p><p><strong>适合于数字标记资产的传输与追踪</strong></p><ul><li>概念：UTXO (unspent transaction outputs) 未花费的交易输出：数据库现有的记录</li></ul><p>-——————————–</p><p>另一种模型常用于智能合约 —— 基于账号的模型(account-based <em>model</em>)</p><p><strong>提供了建立多步骤执行的基本机制</strong> </p><h3 id="资产如何产生"><a href="#资产如何产生" class="headerlink" title="资产如何产生"></a>资产如何产生</h3><ul><li>比特币：<ul><li>矿工节点允许在挖出的新节点中加入一种 coinbase 类型的交易（不存在交易输入，新资产数额有比特币链提前定义）</li></ul></li><li>在创始新代币的时候全额发行</li><li>其它机制</li></ul><h2 id="区块链特性"><a href="#区块链特性" class="headerlink" title="区块链特性"></a>区块链特性</h2><ol><li>一种健壮的、真正的分布式对等系统，它能容忍节点故障。</li><li>能够识别冲突和分叉并自动解决的网络，以便收敛到单一的、公认的唯一状态。（区块链永远选择最长的分支来达成网络上的共识）</li><li>网络活动的透明性、可验证性、可审计性。我们能获取可验证的过程，无论它们是否交换和跟踪数字资产，还是数据驱动的交互。每一个行为，都存有公开的与网络交互的记录，并以此来消除人为的矛盾。</li><li>这是一种可以标记不同信息的触发者的方法，并且能够在没有中央权威的情况下强制执行。</li><li>这是一个使得不信任双方根据可预测的、确定性的方式交互的系统。</li></ol><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p>自动化地执行一系列合约条款的交易协议</p><p>智能合约是存储在区块链中的脚本（认识上可以与关系型数据库的存储过程类似）。</p><p>以基于账号的模型为例对合约执行进行描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设定义一个合约，包括三个方法</span><br><span class="line"></span><br><span class="line">(1) “存储”——合约的“存款”功能允许 防风（通过防风的密钥验证）将若干单位的X存入合约中；</span><br><span class="line">(2) “交易”——“交易”功能允许任何人向合约发送5单位Y，并从合约持有的X中返回1单位给交易方；</span><br><span class="line">(3) “撤销”——“撤销”功能允许 防风 取出合约中存有的所有资产。</span><br><span class="line"></span><br><span class="line">请注意，上述“存款”和“撤销”功能被限制为只允许被 防风（实际上是防风的私钥）调用。当然，这只有由于上述合约由防风制定。若人为的制定一个所有人都能调用任何功能的合约也是允许的（虽然这在事实上没有意义）。</span><br></pre></td></tr></table></figure><p>那么在基于账户的模型下，可以认为 拥有“存储”、“交易”、“撤销”方法的合约持有一个单独的账户（与用户所持有的账户等价）。</p><p>在上述合约下，这个账户将可能持有一定数量的资产。除了只能按照预定的合约步骤对资产进行处置之外，其它与用户持有的账户别无二致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __</span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _</span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fs8oc4ri7qj30mq055aap.jpg&quot; alt=&quot;区块链简单结构&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;small&gt;图1. 区块链简单结构&lt;/small&gt;&lt;/center&gt;



&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1foxcpmmpfhj31kw107n2e.jpg&quot; alt=&quot;Merkle tree&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;small&gt;图2. 单个区块的抽象结构&lt;/small&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="BlockChain" scheme="https://DorMOUSE-None.github.io/tags/BlockChain/"/>
    
      <category term="Smart Contract" scheme="https://DorMOUSE-None.github.io/tags/Smart-Contract/"/>
    
  </entry>
  
  <entry>
    <title>Spring JDBC 源码学习</title>
    <link href="https://DorMOUSE-None.github.io/2018-01-15-Spring-JDBC-Code-Reading/"/>
    <id>https://DorMOUSE-None.github.io/2018-01-15-Spring-JDBC-Code-Reading/</id>
    <published>2018-01-14T16:00:00.000Z</published>
    <updated>2018-06-14T01:24:16.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * copied from https://www.tutorialspoint.com/jdbc/jdbc-sample-code.htm</span></span><br><span class="line"><span class="comment"> * updated by DorMOUSENone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//STEP 1. 引入必须的包</span></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"><span class="comment">// JDBC 驱动名 与 DB URL </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据库登录验证 (用户名、密码等)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"username"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"password"</span>;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//STEP 2: 注册驱动(注册到驱动管理器 DriverManager 类中)</span></span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//STEP 3: 创建一个连接</span></span><br><span class="line">          System.out.println(<span class="string">"Connecting to database..."</span>);</span><br><span class="line">          conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//STEP 4: 执行一个查询</span></span><br><span class="line">          System.out.println(<span class="string">"Creating statement..."</span>);</span><br><span class="line">          stmt = conn.createStatement();</span><br><span class="line">          String sql;</span><br><span class="line">          sql = <span class="string">"SELECT id, first, last, age FROM Employees"</span>;</span><br><span class="line">          ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//STEP 5: 将结果从结果集(ResultSet)中取出</span></span><br><span class="line">          <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">             <span class="comment">//根据列名逐一取出数据</span></span><br><span class="line">             <span class="keyword">int</span> id  = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">             <span class="keyword">int</span> age = rs.getInt(<span class="string">"age"</span>);</span><br><span class="line">             String first = rs.getString(<span class="string">"first"</span>);</span><br><span class="line">             String last = rs.getString(<span class="string">"last"</span>);</span><br><span class="line"></span><br><span class="line">             <span class="comment">//展示结果</span></span><br><span class="line">             System.out.print(<span class="string">"ID: "</span> + id);</span><br><span class="line">             System.out.print(<span class="string">", Age: "</span> + age);</span><br><span class="line">             System.out.print(<span class="string">", First: "</span> + first);</span><br><span class="line">             System.out.println(<span class="string">", Last: "</span> + last);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//STEP 6: 清理环境</span></span><br><span class="line">          rs.close();</span><br><span class="line">          stmt.close();</span><br><span class="line">          conn.close();</span><br><span class="line">       &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">          <span class="comment">//处理 JDBC 错误</span></span><br><span class="line">          se.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">          <span class="comment">//处理 Class.forName() 引起的错误</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">          <span class="comment">// finally 代码库来关闭资源</span></span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)</span><br><span class="line">                stmt.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">          &#125;<span class="comment">// 不做任何处理</span></span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">               se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"Goodbye!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的通用 JDBC 代码可以看到，利用 Java 原生提供的 java.sql.* 包可以完成注册驱动，创建连接，执行查询，处理结果等一系列一整套操作。</p><p>而 Spring-JDBC 对于 Java 原生提供的 JDBC ，对一系列数据及操作进行了整合：</p><ol><li>实现了 DataSource 接口，用于整合数据源配置，将各种零散的属性值（诸如 URL、用户名、 密码等）整合成完整的一个对象，便于重用；也实现了 getConnection(…) 接口，便于直接通过 DataSource 获取连接。</li><li>对执行查询的流程进行了封装。</li><li>对结果集的处理提供了多种接口，针对不同的应用场景可自由选择所必须的实现类。例如直接通过 JDBC 获得 Bean ，而无需如上例 39-42 行所示，逐一编码进行提取。</li></ol><p>本节提供对《Spring-JDBC 源码学习》完整学习过程的一个梳理：</p><ol><li><a href="http://blog.csdn.net/dormousenone/article/details/79035440" target="_blank" rel="noopener">JdbcTemplate</a> 一节作为学习 Spring-jdbc 的切入点，是 org.springframework.jdbc.core 包中的核心类，是一个提供不同场景下数据库操作的模板类。主要描述其持有的属性 DataSource 等以及其实现的方法。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79037012" target="_blank" rel="noopener">DataSource</a> 一节承接 JdbcTemplate 一节，提供 Spring-jdbc 对数据源的一个包装与应用。同时描述其核心方法 getConnection(…) 的实现。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79042212" target="_blank" rel="noopener">DriverManager</a> 描述其对不同数据库供应商提供的驱动的管理与使用方法。同时简单描述通过具体驱动获得一个连接的实现。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79046865" target="_blank" rel="noopener">PreparedStatement &amp; CallableStatement</a> 一节主要表述 Spring-jdbc 如何对执行查询的流程进行了封装。特别是对于 PreparedStatement 与 CallableStatement 这类预置可变 SQL 语句，在执行前必须对其中可变参数进行补全的 Statement 。</li><li><a href="http://blog.csdn.net/dormousenone/article/details/79062275" target="_blank" rel="noopener">ResultSet</a> 描述 Spring-jdbc 如何对结果集进行处理，提供了多种不同的接口实现不同的处理逻辑。这种封装后的操作可以极大地简化直接使用 Java 原生 JDBC 所必须的硬编码提取数据的问题。</li></ol><h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fn90ghu9ufj30ki0jm75t.jpg" alt=""></p><p>JdbcTemplate 类作为 org.springframework.core 包下的核心类，对 Java 实现的 JDBC 进行了一定程度的封装，可以简化 JDBC 的使用，同时避免许多常见的错误。由该类来执行 JDBC 工作流，应用程序只需要提供 SQL 语句就可以获得 DB 执行结果（😀，当然实际操作上没有描述的这么简单）。</p><p><strong>使用 JdbcTemplate 类只需要实现两个回调接口 PreparedStatementCreator (创建一个 PreparedStatement，给定连接，提供 SQL 语句以及必要的参数), ResultSetExtractor (用于花式获取结果集)。当然，不实现上述两个接口也可以进行简单的数据库操作，比如只通过 JdbcTemplate 获取一个连接(Connection) 或者执行一个静态 SQL Update。</strong></p><p><em>看不懂无所谓，先继续向下看，会做更详细的讲解。</em></p><h3 id="JdbcAccessor"><a href="#JdbcAccessor" class="headerlink" title="JdbcAccessor"></a>JdbcAccessor</h3><p>首先了解 JdbcTemplate 的实现，JdbcTemplate 继承了 JdbcAccessor 抽象类，该抽象类有两个主要属性—— <strong>DataSource dataSource</strong> &amp; <strong>SQLExceptionTranslator exceptionTranslator</strong> ，以及一个懒加载标识符 <strong>lazyInit</strong> 。</p><p>其中，</p><ul><li>DataSource 可以认为是一个存储有与数据库相关的属性实例，主要方法包括 <code>Connection getConnection()</code> &amp; <code>Connection getConnection(String username, String password)</code> 。</li><li>SQLExceptionTranslator 利用策略模式将 Java 定义的 SQLException 转换成 Spring 声明的 DataAccessException。</li></ul><p>JdbcAccessor 实现的 InitializingBean 接口，InitializingBean 接口为 Bean 提供了一个初始化实例的方法 —— afterPropertiesSet() 方法，凡是继承该接口的类，一般都在类构造方法中执行该方法。同样的，声明初始化实例调用的方法还可采用 <code>&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;myInitMethod&quot;/&gt;</code> 在初始化 bean 时执行 myInitMethod() 方法。具体执行顺序为 ：</p><ol><li>bean 的属性注入</li><li>调用 afterPropertiesSet() 方法</li><li>执行 myInitMethod() 方法</li></ol><p>此处继承该接口是为了实现 DataSource 验证以及 SQLExceptionTranslator 的懒加载 OR NOT 的选择。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (getDataSource() == <span class="keyword">null</span>) &#123;<span class="comment">// 判断是否注入了 DataSource</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Property 'dataSource' is required"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!isLazyInit()) &#123;<span class="comment">// 根据懒加载标识符选择执行与否</span></span><br><span class="line">getExceptionTranslator();<span class="comment">// 获取一个 SQLExceptionTranslator 实例</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法在 BeanFactory 完成该 bean 的依赖注入后执行，将首先判断 DataSource 是否已经被注入，再根据懒加载标识符来决定是否实例化一个 SQLExceptionTranslator 。</p><h3 id="JdbcOperations"><a href="#JdbcOperations" class="headerlink" title="JdbcOperations"></a>JdbcOperations</h3><p>同时，JdbcTemplate 类实现了 JdbcOperations 接口，该接口定义了基本的 JDBC 操作。基本方法如下：</p><ol><li><code>&lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action);</code></li></ol><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fncp2ncqd6j31j00au0uv.jpg" alt=""></p><p>其它的 execute(…) , query(…), update(…) 等最终都将调用上述 4 种方法其一来完成目的。</p><p>详细观察上述方法的入参， ConnectionCallback, StatementCallback, PreparedStatementCallback 和 CallableStatementCallback 四个 Callback 接口，分别都是函数式接口，其中的唯一方法 doInXXX() 将在 execute() 中被调用，以此实现获得 ResultSet 并返回 Result 。execute 中调用 doInXXX() 的通用代码如下 （以 Statement 为例）：</p><p><em>对于不理解<strong>回调</strong>的同学，请自行了解概念</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"><span class="comment">// 通过工具类 DataSourceUtils 获取一个连接</span></span><br><span class="line">  Connection con = DataSourceUtils.getConnection(obtainDataSource());</span><br><span class="line">  <span class="comment">// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似</span></span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stmt = con.createStatement();<span class="comment">// 通过连接(Connection)获取一个 Statement</span></span><br><span class="line">applyStatementSettings(stmt);<span class="comment">// 配置 Statement 参数</span></span><br><span class="line">      <span class="comment">// 回调执行 doInXXX() 方法, 并获得 result</span></span><br><span class="line">T result = action.doInStatement(stmt);</span><br><span class="line">handleWarnings(stmt);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line"><span class="comment">// Release Connection early, to avoid potential connection pool deadlock</span></span><br><span class="line"><span class="comment">// in the case when the exception translator hasn't been initialized yet.</span></span><br><span class="line">String sql = getSql(action);</span><br><span class="line">JdbcUtils.closeStatement(stmt);</span><br><span class="line">stmt = <span class="keyword">null</span>;</span><br><span class="line">DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">con = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">throw</span> translateException(<span class="string">"StatementCallback"</span>, sql, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">JdbcUtils.closeStatement(stmt);</span><br><span class="line">DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Statement, PreparedStatement, CallableStatement 的区别，首先下图表现了三个接口的继承关系。</p><ul><li>Statement 可以支持静态 SQL 语句</li><li>PreparedStatement 支持可变参数的 SQL 语句</li><li>CallableStatement 支持可变参数的 SQL 语句，并且支持定制 DB 的输出结果</li></ul><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fncpaec17yj30ew0hcdh7.jpg" alt=""></p><h2 id="DataSource"><a href="#DataSource" class="headerlink" title="DataSource"></a>DataSource</h2><p>上一节在粗略地了解了 JdbcTemplate 提供的方法之后，下面先来对 DataSource 做一点了解。</p><h3 id="Java-提供的-DataSource-定义"><a href="#Java-提供的-DataSource-定义" class="headerlink" title="Java 提供的 DataSource 定义"></a>Java 提供的 DataSource 定义</h3><p>DataSource 是 Java 核心库提供的接口。位于 javax.sql package 下。</p><p>DataSource 接口可以被视作是一个提供物理 DB 实例连接(Connection) 的工厂，通过 DataSource 持有的各种属性（包括 DB Url, Username, Password 等）来获取一个连接(Connection) 。DataSource 接口有三种不同的实现方案：</p><ol><li>最基本的实现——生产一个标准连接(Connection) 对象</li><li>连接池方案——生产会被自动添加到连接池的对象</li><li>分布式事物实现——生产一个可以支持分布式事物，并默认被添加到连接池的连接对象</li></ol><p>包括两个对外提供连接(Connection) 对象的方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function">Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>其父接口 CommonDataSource 提供设置/获取 LogWriter，登录 DB 超时时间和获取父 Logger 的方法。</p><h3 id="Spring-JDBC-扩展的-DataSource-定义"><a href="#Spring-JDBC-扩展的-DataSource-定义" class="headerlink" title="Spring-JDBC 扩展的 DataSource 定义"></a>Spring-JDBC 扩展的 DataSource 定义</h3><p>在 Spring-jdbc 下，DataSources 最顶级的类是 AbstractDataSource ，对 DataSource 的所有父接口方法做了实现。但保留 getConnection() 方法由子类实现。</p><p>在 AbstractDriverBasedDataSource 中，定义了大量的参数，诸如 url, username 等，这些都被用来定位并定义与数据库实例的连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDriverBasedDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String catalog;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String schema;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="comment">// 可以看到此处有一个 Properties 类</span></span><br><span class="line">   <span class="keyword">private</span> Properties connectionProperties;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 省略若干方法</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">// 调用内部方法 getConnectionFromDriver()</span></span><br><span class="line"><span class="keyword">return</span> getConnectionFromDriver(getUsername(), getPassword());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="comment">// 调用内部方法 getConnectionFromDriver()</span></span><br><span class="line"><span class="keyword">return</span> getConnectionFromDriver(username, password);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 定义了一个获取 Connection 的方法，由 getConnection() 方法调用，</span></span><br><span class="line">   <span class="comment">// 此方法主要是将属性做了一个整合</span></span><br><span class="line">   <span class="comment">// 具体获取 Connection 的逻辑仍然下放到子类实现 见 40 行</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(@Nullable String username, @Nullable String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">Properties mergedProps = <span class="keyword">new</span> Properties();</span><br><span class="line">Properties connProps = getConnectionProperties();</span><br><span class="line"><span class="keyword">if</span> (connProps != <span class="keyword">null</span>) &#123;</span><br><span class="line">mergedProps.putAll(connProps);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (username != <span class="keyword">null</span>) &#123;</span><br><span class="line">mergedProps.setProperty(<span class="string">"user"</span>, username);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">mergedProps.setProperty(<span class="string">"password"</span>, password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取 Connection 逻辑下放</span></span><br><span class="line">Connection con = getConnectionFromDriver(mergedProps);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.catalog != <span class="keyword">null</span>) &#123;</span><br><span class="line">con.setCatalog(<span class="keyword">this</span>.catalog);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.schema != <span class="keyword">null</span>) &#123;</span><br><span class="line">con.setSchema(<span class="keyword">this</span>.schema);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 该类中获取 Connection 的方法是抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整合方案为将除 url 外的所有参数整合在同一个 Properties 对象中 (其中，Properties 可以被认为是一个线程安全的 Hash Map) 。最终调用 <code>Connection getConnectionFromDriver(Properties props)</code> 获取连接。</p><p>AbstractDriverBasedDataSource 抽象类的两个子类 DriverManagerDataSource 和 SimpleDriverDataSource 都以不同方式获得了连接(Connection)，但总结而言，获取连接(Connection) 的任务被委托给了 Driver 来实现（其中，Driver 有 Java 定义接口，并由各数据库提供商提供，例如 MySQL 提供了 mysql-connector-java-XXX.jar 来完成针对相应数据库的具体实现）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="comment">// SimpleDriverDataSource 的实现</span></span><br><span class="line"><span class="comment">// ----------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">Driver driver = getDriver();</span><br><span class="line">String url = getUrl();</span><br><span class="line">Assert.notNull(driver, <span class="string">"Driver must not be null"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating new JDBC Driver Connection to ["</span> + url + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 哈哈，重点在这... driver 在该类中被预先注入</span></span><br><span class="line"><span class="keyword">return</span> driver.connect(url, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="comment">// DriverManagerDataSource 的实现</span></span><br><span class="line"><span class="comment">// -----------------------------</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriver</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">String url = getUrl();</span><br><span class="line">Assert.state(url != <span class="keyword">null</span>, <span class="string">"'url' not set"</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Creating new JDBC DriverManager Connection to ["</span> + url + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 调了个内部函数</span></span><br><span class="line"><span class="keyword">return</span> getConnectionFromDriverManager(url, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Connection <span class="title">getConnectionFromDriverManager</span><span class="params">(String url, Properties props)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="comment">// 委托给 DriverManager 类来获取连接</span></span><br><span class="line">    <span class="comment">// DriverManager 的主要操作是遍历在该管理类中注册的 Driver</span></span><br><span class="line">    <span class="comment">// 每个 Driver 实例都去尝试一下，能不能获得一个连接</span></span><br><span class="line">    <span class="comment">// 第一次在某个 Driver 中拿到一个连接即返回连接 (Connection)</span></span><br><span class="line"><span class="keyword">return</span> DriverManager.getConnection(url, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简要的类图如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fncrgqcjqoj31es15ajxj.jpg" alt=""></p><h2 id="DriverManager"><a href="#DriverManager" class="headerlink" title="DriverManager"></a>DriverManager</h2><p>上面提到 DataSource 获取连接(Connection) 的操作实质上将委托具体的 Driver 来提供 Connection 。有两种不同的方式，包括经由 DriverManager 遍历所有处于管理下的 Driver 尝试获取连接，或者在 DataSource 实例中直接声明一个特定的 Driver 来获取连接。</p><p>对于获取连接的具体操作，挖坑-待填。只描述简单的数据库供应商提供的 Driver 如何与 java 相联系。</p><p>###在 DriverManager 中注册 Driver 实例</p><p>通常在与数据库交互逻辑的 Java 代码中，都会有 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> (此处以 MySQL 提供的 mysql-connector-java-XXX.jar 为例，下同）的代码块，加载指定的 com.mysql.jdbc.Driver 为 java.lang.Class 类。</p><p><em>当然，在 JDBC 4.0 标准下，可以不必再显示声明 <code>Class.forName(&quot;&quot;)</code> 语句，Driver 也同样会在 DriverManager 初始化时自动注册。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Class 类中对于 forName(String className) 的方法</span></span><br><span class="line"><span class="comment">// 作用为返回一个 java.lang.Class 实例。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;...&#125;</span><br></pre></td></tr></table></figure><p>同时， JVM 在加载类的过程中会执行类中的 static 代码块。下述 row 10 ~ 16 的代码片段将被执行。唯一的逻辑就是 new 一个 com.mysql.jdbc.Driver 实例，并将实例注册(registerDriver) 到 <strong>java.sql.DriverManager</strong> 中。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mysql.jdbc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line"><span class="comment">// ~ Static fields/initializers</span></span><br><span class="line"><span class="comment">// ---------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ~ Constructors</span></span><br><span class="line"><span class="comment">// -----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> *             if a database error occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面再来看一下 DriverManager 中的 registerDriver() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DriverManager 维护一个线程安全的 Driver 列表</span></span><br><span class="line">  <span class="comment">// 此处的 DriverInfo 里面即包装了 Driver </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = </span><br><span class="line">      <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 DriverManager 中注册 Driver</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        registerDriver(driver, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver,</span></span></span><br><span class="line"><span class="function"><span class="params">            DriverAction da)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 如果当前 Driver 不在列表中，即添加到列表。 */</span></span><br><span class="line">        <span class="keyword">if</span>(driver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            registeredDrivers.addIfAbsent(<span class="keyword">new</span> DriverInfo(driver, da));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This is for compatibility with the original DriverManager</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"registerDriver: "</span> + driver);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过-DriverManager-获取连接-Connection"><a href="#通过-DriverManager-获取连接-Connection" class="headerlink" title="通过 DriverManager 获取连接(Connection)"></a>通过 DriverManager 获取连接(Connection)</h3><p>上一节有提到过可以通过 DriverManager 来遍历获取连接，也可以直接声明具体 Driver 并获取连接。下面代码展示的是通过 DriverManager 获取连接的操作。 <del>哈哈哈，反正最后都是由具体驱动实现获取连接。</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取连接的 public 接口 (1)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></span><br><span class="line"><span class="function"><span class="params">java.util.Properties info)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取连接的 public 接口 (2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url,</span></span></span><br><span class="line"><span class="function"><span class="params">        String user, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        java.util.Properties info = <span class="keyword">new</span> java.util.Properties();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            info.put(<span class="string">"user"</span>, user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">            info.put(<span class="string">"password"</span>, password);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 获取连接的 public 接口 (3)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        java.util.Properties info = <span class="keyword">new</span> java.util.Properties();</span><br><span class="line">        <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 获取连接的内部逻辑实现</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * When callerCl is null, we should check the application's</span></span><br><span class="line"><span class="comment">         * (which is invoking this class indirectly)</span></span><br><span class="line"><span class="comment">         * classloader, so that the JDBC driver class outside rt.jar</span></span><br><span class="line"><span class="comment">         * can be loaded from here.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ClassLoader callerCL = caller != <span class="keyword">null</span> ? caller.getClassLoader() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(DriverManager.class) &#123;</span><br><span class="line">            <span class="comment">// synchronize loading of the correct classloader.</span></span><br><span class="line">            <span class="keyword">if</span> (callerCL == <span class="keyword">null</span>) &#123;</span><br><span class="line">                callerCL = Thread.currentThread().getContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// url 是定位 DBMS 最重要的参数，不能为空</span></span><br><span class="line">        <span class="keyword">if</span>(url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"The url cannot be null"</span>, <span class="string">"08001"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"DriverManager.getConnection(\""</span> + url + <span class="string">"\")"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历所有注册的 Driver ，并都尝试获取连接(Connection)</span></span><br><span class="line">        SQLException reason = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">          <span class="comment">// 判断注册的 Driver 是否由 ClassLoader callerCL 加载，不是则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    println(<span class="string">"    trying "</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="comment">// 获取连接，:) 还是由 driver 实例自行提供</span></span><br><span class="line">                  Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                    <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// Success!</span></span><br><span class="line">                        println(<span class="string">"getConnection returning "</span> + </span><br><span class="line">                                aDriver.driver.getClass().getName());</span><br><span class="line">                        <span class="keyword">return</span> (con);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        reason = ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                println(<span class="string">"    skipping: "</span> + aDriver.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果运行到下列代码，则表明获取连接失败，抛出错误</span></span><br><span class="line">        <span class="keyword">if</span> (reason != <span class="keyword">null</span>)    &#123;</span><br><span class="line">            println(<span class="string">"getConnection failed: "</span> + reason);</span><br><span class="line">            <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"getConnection: no suitable driver found for "</span>+ url);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"No suitable driver found for "</span>+ url, <span class="string">"08001"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>简单的提一嘴，Connection 仍然只是一个针对 Java -&gt; DB Server 的上层接口，如果想要更深层次地了解 Connection 与 DB Server 的交互，可以尝试去看一下 com.mysql.jdbc.MysqlIO 类，MySQL 实现的 JDBC4Connection 类也是在使用该类来实现对 DB Server 交互。（哈哈，只看过 MySQL 提供的 Driver 包）。</em></p><h2 id="PreparedStatement-amp-CallableStatement"><a href="#PreparedStatement-amp-CallableStatement" class="headerlink" title="PreparedStatement &amp; CallableStatement"></a>PreparedStatement &amp; CallableStatement</h2><p>在了解了 DataSource 获取连接(Connection) 的实质以及 JdbcTemplate 的通用接口之后，使用 Spring-jdbc 进行数据库相关的操作可以直截了当的利用如下代码进行实现（此处仅展示通过 Java 硬编码的形式进行实现，XML 配置方法类似）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义数据源</span></span><br><span class="line">DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">  <span class="comment">// 配置参数</span></span><br><span class="line">dataSource.setUrl(<span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;?&lt;props&gt;"</span>);</span><br><span class="line">   dataSource.setUsername(<span class="string">"&lt;username&gt;"</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">"&lt;passwd&gt;"</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 实例化一个 JDBC 工具类</span></span><br><span class="line">  JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">  <span class="comment">// 执行相关 CRUD 操作</span></span><br><span class="line">  jdbcTemplate.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回顾第一节所讲的 JdbcTemplate 的 4 个基础方法：</p><ol><li><code>&lt;T&gt; T execute(ConnectionCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(PreparedStatementCreator psc, PreparedStatementCallback&lt;T&gt; action);</code></li><li><code>&lt;T&gt; T execute(CallableStatementCreator csc, CallableStatementCallback&lt;T&gt; action);</code></li></ol><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fndsm5tl7aj30zg0byq47.jpg" alt=""></p><p>四个基础方法都有一个特定的回调函数将通过预配置的 DataSource 得到的 Connection 或 更进一步的 Statement or PreparedStatement or CallableStatement 作为入参来执行定义的唯一方法。</p><p>以 <code>&lt;T&gt; T execute(StatementCallback&lt;T&gt; action);</code> 为例来了解一下方法的核心逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"><span class="comment">// 通过工具类 DataSourceUtils 获取一个连接</span></span><br><span class="line">  Connection con = DataSourceUtils.getConnection(obtainDataSource());</span><br><span class="line">  <span class="comment">// 一个 Statement 空实例，PreparedStatement, CallableStatement 类似</span></span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">stmt = con.createStatement();<span class="comment">// 通过连接(Connection)获取一个 Statement</span></span><br><span class="line">applyStatementSettings(stmt);<span class="comment">// 配置 Statement 参数</span></span><br><span class="line">      <span class="comment">// 回调执行 doInXXX() 方法, 并获得 result</span></span><br><span class="line">T result = action.doInStatement(stmt);</span><br><span class="line">handleWarnings(stmt);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span>() &#123;</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，对于 PreparedStatement 和 CallableStatement 而言，获取一个 <em>XXX</em>Statement 的方式就有所不同了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Statement 实例</span></span><br><span class="line">Statement stmt = con.createStatement();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 PreparedStatement 实例</span></span><br><span class="line"><span class="comment">// psc 是一个 PreparedStatementCreator 接口实现的实例</span></span><br><span class="line">PreparedStatement ps = psc.createPreparedStatement(con);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 CallableStatement 实例</span></span><br><span class="line"><span class="comment">// csc 是一个 CallableStatementCreator 接口实现的实例</span></span><br><span class="line">CallableStatement cs = csc.createCallableStatement(con);</span><br></pre></td></tr></table></figure><p>可以看到 Statement 直接通过 Connection 获取实例，但是 PreparedStatement 和 CallableStatement 就有所不同，其区别就在于 PreparedStatement 和 CallableStatement 两个 Statement 都是可以定制入参的，更甚者， CallableStatement 可以定制 DB 执行结果的出参。当然，核心还是 <code>con.prepareStatement() OR con.prepareCall()</code> 方法，只不过是将获取 XXXStatement 的操作下放给 XXXStatementCreator 实例类实现，给予使用者重复的自主权，同时也是逻辑解耦的一种操作。</p><p>例如：</p><p>SimplePreparedStatementCreator 这个 PreparedStatementCreator 接口的实现类，只是简单的调用了 <code>con.prepareStatement(sql)</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePreparedStatementCreator</span> </span></span><br><span class="line"><span class="class">  <span class="keyword">implements</span> <span class="title">PreparedStatementCreator</span>, <span class="title">SqlProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">createPreparedStatement</span><span class="params">(Connection con)</span> </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> con.prepareStatement(<span class="keyword">this</span>.sql);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于 PreparedStatementCreatorImpl ，在 createPreparedStatement(Connection con) 的实现上，又添加了更多的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementCreatorImpl</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">PreparedStatementCreator</span>, <span class="title">PreparedStatementSetter</span>, <span class="title">SqlProvider</span>, <span class="title">ParameterDisposer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String actualSql;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;?&gt; parameters;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">createPreparedStatement</span><span class="params">(Connection con)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">PreparedStatement ps;</span><br><span class="line"><span class="keyword">if</span> (generatedKeysColumnNames != <span class="keyword">null</span> || returnGeneratedKeys) &#123;</span><br><span class="line"><span class="keyword">if</span> (generatedKeysColumnNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// 获取一个 PreparedStatement 实例，下同</span></span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, </span><br><span class="line">                                          generatedKeysColumnNames);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, </span><br><span class="line">                                         PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (resultSetType == ResultSet.TYPE_FORWARD_ONLY </span><br><span class="line">                 &amp;&amp; !updatableResults) &#123;</span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ps = con.prepareStatement(<span class="keyword">this</span>.actualSql, resultSetType,</span><br><span class="line">updatableResults ? ResultSet.CONCUR_UPDATABLE : </span><br><span class="line">                                      ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 将可变 SQL (例如 SELECT * FROM msg WHERE id = ?) 的 ? 用实际参数替换</span></span><br><span class="line">setValues(ps);</span><br><span class="line"><span class="keyword">return</span> ps;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述两种 PreparedStatementCreator 接口的不同实现，也可以从另一种角度理解到，函数式接口将获取目标出参的具体逻辑交给使用者定义，给予了使用者充分的自主权，同时也是一种业务逻辑的解耦。</p><p>在上面代码 PreparedStatementCreatorImpl 类的实现中，我们看到第 32 行代码 <code>setValue(ps)</code> 。此处的方法是由接口 PreparedStatementSetter 定义的。主要目的是将可变 SQL 中的 ? 参数用实际参数进行一个替换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以 SQL (SELECT * FROM msg WHERE id = ? AND day = ?) 为例</span></span><br><span class="line"><span class="comment">/** 纯 Java 核心库的实现 PreparedStatement 参数注入 */</span></span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">1763</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">"2018-01-01"</span>);</span><br><span class="line">ps.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 以 Spring-jdbc 实现 PreparedStatement 参数注入 */</span></span><br><span class="line"><span class="comment">// setValues() 由接口 PreparedStatementSetter 定义，封装了注入参数的具体实现逻辑</span></span><br><span class="line"><span class="comment">// 可以由使用者自行定义</span></span><br><span class="line">setValues(ps);</span><br><span class="line">ps.executeQuery();</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fndyybh4q1j31kw0u3afx.jpg" alt=""></p><p>上面类图表示了 PreparedStatementSetter 及其实现类的相关依赖。</p><p>Setter 的主要目标即为对 SQL 中的 ? 参数进行注入。</p><p><del>个人精力有限，对Spring-jdbc在Statement上对参数注入的回调理解有限。</del></p><h2 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h2><p>在前几节已经提到讲了数据源、驱动管理器以及 Statement 之后，利用 JDBC 的最重要的目的就是对 DB 进行操作，并获得预期结果。对于查询语句而言，结果应该是若干记录行；就更新语句而言，结果可能是影响的行数。而 Spring-jdbc 对 ResultSet 额外进行的封装，即是将原本散乱的结果进行一个整合，例如整合成一个(一组)完整的 Bean 来进行展示。</p><p>在 JdbcTemplate 中，四个基本方法入参都包括一个回调接口，而在执行回调获得 ResultSet 之后，方法并不是直接返回，而是进行了一定的操作。</p><p>以一个 PreparedStatementCallback 的实例类为例，在 doInPreparedStatement() 方法中，获得了 ResultSet ，但是仍通过 rse.extractData(rs) 语句进行了处理后再返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个 ResultSet </span></span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (pss != <span class="keyword">null</span>) &#123;<span class="comment">// setValues() 方法填充 PreparedStatement 中的可变参数 ? </span></span><br><span class="line">pss.setValues(ps);</span><br><span class="line">&#125;</span><br><span class="line">rs = ps.executeQuery();<span class="comment">// 执行查询 sql ，获取结果</span></span><br><span class="line"><span class="keyword">return</span> rse.extractData(rs);<span class="comment">// 重点... 该语句一定是对结果进行了一些操作.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">JdbcUtils.closeResultSet(rs);</span><br><span class="line"><span class="keyword">if</span> (pss <span class="keyword">instanceof</span> ParameterDisposer) &#123;</span><br><span class="line">((ParameterDisposer) pss).cleanupParameters();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在来看一下究竟在返回结果前进行了什么操作。</p><p>由于是一个回调接口的实现类，rse 应该在外部方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">PreparedStatementCreator psc, @Nullable <span class="keyword">final</span> PreparedStatementSetter pss, </span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> execute(psc, <span class="keyword">new</span> PreparedStatementCallback&lt;T&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">doInPreparedStatement</span><span class="params">(PreparedStatement ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 rse 是一个 ResultSetExtractor<t> 的实例。从名称上可以看出 Extractor 即为提取器，结果集提取器。</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 函数式接口，提供的唯一方法为 extractData(...) */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSetExtractor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">T <span class="title">extractData</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException, DataAccessException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fndzz0pqnrj31a60i676v.jpg" alt=""></p><p>Spring-jdbc 中现有的实现有三个类，其中 RowCallbackHandlerResultSetExtractor 和 RowMapperResultSetExtractor 两个类从上面类图及命名即可看出，两个是作为一个适配器而存在的，将 extractData() 进行转换，分别由 RowCallbackHandler 和 RowMapper 实例进行具体操作。而 AbstractLobStreamingResultSetExtractor 类从名称上看，也是一个类似流操作的实现类(其中的 Lob 指的是 DB 中的 BLOB 与 CLOB 类型，在 Spring-jdbc 中也加入了额外的支持) 。</p><h3 id="RowCallbackHandler"><a href="#RowCallbackHandler" class="headerlink" title="RowCallbackHandler"></a>RowCallbackHandler</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fnh2uw3a0aj30h20jeta4.jpg" alt=""></p><p>从名称上看，这是一个与 ResultSet 结果集行相关的回调接口。processRow(ResultSet rs) 方法将处理行相关的逻辑。</p><p>从它的一个实现类 RowCountCallbackHandler 来说，其最主要的私有属性 rowCount 即是统计 ResultSet 的结果行数。下面是一个具体使用的该类的案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    DriverManagerDataSource dataSource = <span class="keyword">new</span> DriverManagerDataSource();</span><br><span class="line">    dataSource.setUrl(<span class="string">"jdbc:mysql://&lt;host&gt;:&lt;port&gt;/&lt;dbName&gt;"</span>);</span><br><span class="line">    dataSource.setUsername(<span class="string">"&lt;username&gt;"</span>);</span><br><span class="line">    dataSource.setPassword(<span class="string">"&lt;password&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line">    RowCountCallbackHandler rcch = <span class="keyword">new</span> RowCountCallbackHandler();</span><br><span class="line"></span><br><span class="line">    jdbcTemplate.query(<span class="string">"SELECT * FROM info WHERE id='2018'"</span>, (RowCallbackHandler) rcch);</span><br><span class="line"></span><br><span class="line">  System.out.println(rcch.getRowCount());<span class="comment">//获取结果集行数</span></span><br><span class="line">    System.out.println(rcch.getColumnCount());<span class="comment">// 获取结果集列数</span></span><br><span class="line">    <span class="keyword">for</span> (String arg : rcch.getColumnNames()) &#123;<span class="comment">// 打印结果集每一列名称</span></span><br><span class="line">        System.out.println(<span class="string">"ColumnNames : "</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : rcch.getColumnTypes()) &#123;<span class="comment">// 打印结果集每一列类型(Types 为枚举类)</span></span><br><span class="line">        System.out.println(<span class="string">"ColumnTypes : "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体查看 RowCountCallbackHandler 类的 processRow() 方法可以看到，其获取列相关信息都来自于 ResultSetMetaData 。而结果行数来源于 Iterator 迭代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRow</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.rowCount == <span class="number">0</span>) &#123;</span><br><span class="line">ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"><span class="keyword">this</span>.columnCount = rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">this</span>.columnTypes = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.columnCount];</span><br><span class="line"><span class="keyword">this</span>.columnNames = <span class="keyword">new</span> String[<span class="keyword">this</span>.columnCount];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.columnCount; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>.columnTypes[i] = rsmd.getColumnType(i + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">this</span>.columnNames[i] = JdbcUtils.lookupColumnName(rsmd, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// could also get column names</span></span><br><span class="line">&#125;</span><br><span class="line">processRow(rs, <span class="keyword">this</span>.rowCount++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RowMapper"><a href="#RowMapper" class="headerlink" title="RowMapper"></a>RowMapper</h3><p>上面 RowCallbackHandler 接口从逻辑上划分是用于处理 ResultSet 元数据信息的。而 RowMapper 较上一个接口而言，有更高的实用性。</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fnh3h739kaj30z60nago4.jpg" alt=""></p><p>特别是其实现类 BeanPropertyRowMapper<t> 可以将散乱的 ResultSet 的结果数据整理成一个个 Object Bean 作为返回结果。而省去了对逐一读取 ResultSet 行记录并填充 Bean 属性的麻烦。</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line"></span><br><span class="line">BeanPropertyRowMapper&lt;Model&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Model.class);</span><br><span class="line">List&lt;Model&gt; list = jdbcTemplate.query(<span class="string">"SELECT * FROM info WHERE id = '2018'"</span>, rowMapper);</span><br><span class="line"><span class="comment">/** 获得的 Model list 的对应属性将通过 Java 的反射机制进行填充</span></span><br><span class="line"><span class="comment"> *List&lt;Model&gt; list 即结果</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>当然，要求是 Model 类中的属性与 DB table 中的列名保持一致（大小写无要求）。</p><p>而其它两个类的实现也是基于反射机制，实现其相应的业务逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  __                    __                  </span><br><span class="line"> / _| __ _ _ __   __ _ / _| ___ _ __   __ _ </span><br><span class="line">| |_ / _` | &apos;_ \ / _` | |_ / _ \ &apos;_ \ / _` |</span><br><span class="line">|  _| (_| | | | | (_| |  _|  __/ | | | (_| |</span><br><span class="line">|_|  \__,_|_| |_|\__, |_|  \___|_| |_|\__, |</span><br><span class="line">                 |___/                |___/</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;在学习 Spring-JDBC 之前，我们有必要从 Java 原生提供的 JDBC 开始，对 JDBC 操作的一整套完整的流程有一个清晰的概念。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://DorMOUSE-None.github.io/tags/Spring/"/>
    
      <category term="JDBC" scheme="https://DorMOUSE-None.github.io/tags/JDBC/"/>
    
  </entry>
  
</feed>
